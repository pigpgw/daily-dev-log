# TIL | 2025.03.29

## 📌 TIL 요약

### 알고리즘

-   정렬과 그리디 결정 알고리즘 10 ~ 12

### 소켓 적용

### 스마게

-   비즈니스 로직이란 무엇인가 공부
-   우선 로그인 api 부분 비즈니스 로직 분리
    -   api 파일에서 api만 호출하게 비즈니스 로직을 우선 컴포넌트로 분리함
    -   기존 로그인 회원가입 로직이 개 더러운데 어떻게 핸들링 해야할까?
        -   최대한 불필요한 코드 삭제하고 유지보수 용이하게 하려함
-   axios와 react query 혼재해도 괜찮나?

    -   api 파일에서 비즈니스 로직을 빼내고나서 생각하니 우리팀 컨벤션은 axios react query 인데 hook으로 또 모든 요청을 뺴려니 파일이 너무 늘어나고 구지 빼야할까? 라는 생각이 들은 구지 리엑트 쿼리를 써야할까 라는 생각이 들어서 고민하고 찾아봄
        -   구지 안쓸필요가 없다. 그럴거면 차라리 axios 쓰지말고 fetch써서 혼합해라

# 패턴으로 익히고 설계로 완성하는 리액트

## ch3 리액트 애플리케이션 구조

### 자주 사용되는 4가지 구조

-   기능 기반 구조
    -   애플리케이션을 기능과 모듈 중심으로 구조화하는 것을 의미
        -   features : 애플리케이션의 기능을 의미
        -   기능마다 components,containers,pages,sevices,types, utils
        -   shared: 여러 기능에서 공유하여 재사용하는 components, containers,services, types, utils
        -   store
        -   router
    -   장점
        -   명확한 관심사 분리
            -   각 기능과 관련된 코드를 쉽게 찾고 수정할 수 있음
        -   모듈화
        -   확장성
        -   팀협업
    -   단점
        -   코드 중보그이 가능성
    -   컴포넌트와 뷰, API 호출, 상태 관리를 캡슐화하여 관리
-   컴포넌트 기반 구조

    -   재사용할 수 있는 컴포넌트 단위로 구조화하는 것
    -   컴포넌트는 기능 단위로 분류하고 이를 조합하여 더 큰 뷰를 만듬
        -   components 폴더는 애플리케이션의 여러 기능에서 사용하는 개별 컴포넌트를 가지게 됨, 각각의 컴포넌트는 폴더에 존재하며, 필요할 경우 자식 컴포넌트를 가짐
        -   routes
        -   api
    -   장점
        -   모듈화
        -   관심사 분리 : 컴포넌트의 개별 기능에 집중하게 되어 코드가 간결해지고 디버깅하기 쉬움, 관심사를 분리하면 유지보수하기 쉽고 코드 가독성이 높아짐
        -   높은 코드 재사용성
    -   단점
        -   프로젝트 복잡도 증가
        -   높은 진입장벽
        -   코드 중복의 가능성

-   아토믹 디자인 구조
    -   사용자 인터페이스를 원자라고 부르는 재사용 가능한 작은 단위로 나누고 이를 합성하여 분자 유기체 템플릿 페이지등의 큰 단위를 만들어냄
    -   아토믹 디자인의 UI 컴포넌트 분류 방법
        -   원자 : UI를 구성하는 가장 작은 요소, 보통 단순하여 독립된 단일 기능
        -   분자 : 원자들을 조합하여 복잡한 UI 컴포넌트를 표현함, 여러 원자가 상호작용을 하여 기능 단위를 구성
            -   폼 입력, 내비게이션 바 등이 있음
        -   유기체 : 더 커다란 컴포넌트이며 분자 또는 원자들을 결합하여 기능 영역의 UI를 표현
            -   헤더, 사이드바, 카드 컴포넌트 등 사용자 인터페이스의 기능 영역을 표현
        -   템플릿
            -   분자 또는 유기체들을 배치하는 레이아웃 구조, 페이지의 전반적인 구조와 UI의 기능 영역을 표시한
        -   페이지
            -   템플릿과 유기체, 분자, 원자 등을 모두 결합하한 온전한 사용자 화면 구성 전체를 의미
    -   구조
        -   atoms,molecules,organisms, templates,pages 디렉터리는 컴포넌트 합성과 추상화의 다양한 레벨을 나타냄
        -   api 디렏터리는 api호출과 관련된 파일을 담고 있음
        -   views 디렉터리는 컴포넌트를 렌더링하는 개별 단위의 View 파일이 있음
    -   장점
        -   재사용성
        -   일관성
        -   확장성
        -   유지보수성
        -   쉬운 협업
    -   단점
        -   높은 진입장벽
        -   복잡도
        -   오버 엔지니어링
-   MVVM 구조

    -   모델
    -   뷰
    -   뷰 모델
    -   구조
        -   views : 뷰 모델의 상태에 따라 화면에 보여주는 UI 컴포넌트
        -   models : 애플리케이션 도메인 객체를 나타내는 데이터 모델 또는 엔티티
        -   view models : 디렉터리에는 상태와 로직을 관리하고 뷰와 상호작용을 하는 훅
        -   servieces : api 호출과 외부 서비스와의 연결을 위한 파일
        -   components : 각각의 기능 단위로 재사용 가능한 UI 컴포넌트
    -   장점
        -   관심사 분리 : 뷰 모델은 UI 컴포넌트에서 비즈니스 로직을 분리하여 유지보수하기 쉽고 깔끔한 코드를 작성 가능
        -   쉬운 테스팅 : 뷰 모델은 실제 UI 컴포넌트 없이도 쉽게 단위 테스트 가능
        -   높은 재사용성 : 컴포넌트와 모델, 서비스는 다른 기능이나 뷰에서 쉽게 재사용 가능
        -   높은 확장성 ㅣ 기존에 사용하던 뷰모델에 새로운 기능이나 뷰를 쉽게 추가할 수 있음
    -   단점
        -   복합도 ㅈ으가 : mvvm 패턴을 도입하면 추상화 계층을 추가하게 되며, 특히 프로젝트 규모가 작다면 이로인한 애플리케이션 복잡도 증가
        -   높은 진입장벽 : mvvm 개념과 사용법에 대한 이해가 필요

### 3.4 프로젝트 구조를 체계적으로 유지하기

-   기능기반 구조는 프로젝트 초기에 유용한 전략, 프로젝트가 커지고 비슷한 패턴들이 반복되기 시작한다면, 추가 계층을 만들어 중복을 피할 수 있음
-   **초기단계에서 페이지를 기능 단위로 구성하는 것은 일반적인 접근 방식** 기능별로 폴더를 만들고 관련된 컴포넌트와 스타일, 테스트 등을 넣음

#### 3.4.1 초기 설계 구현하기

-   초기 폴더 구조를 기능 기반 접근 방식을 가져감, 각 페이지별로 폴더가 구분됨
-   하지만 프로젝트가 커질수록, 서로 다른 페이지에서 컴포넌트나 기능의 중복이 발생하게 됨
    -   이를 해결하기 위해서 추상화 계층을 도입해야함
        -   예를 들어 login과 order 페이지 모두 button 컴포넌트가 필요하다고 페이지별로 각각 이를 구현하는것은 올지 않음
        -   버튼을 분맇하여 별도의 계층에 넣을 수 있음 그러면 여러 페이지에서 중복 없이 재사용 가능

#### 3.4.2 중복 제거를 위한 계층 추가

-   위와같이 계층 추가하면 재사용 및 유지보수 높이기 가능, 일반성 확보, components 폴더에 재사용 가능한 모든 컴포넌트 넣고, pages 폴더에 페이지와 관련된 모든 컴포넌트 넣음

#### 3.4.3 파일 이름 짓기

-   index.tsx를 사용하여 명시적인 컴포넌트 이름과 파일 이름 짓기
    ```
    components/Button
    |-- Button.test.tsx
    |-- Button.tsx
    |-- index.tsx
    --- style.css
    ```
-   케밥 케이스로 파일 이름 짓기
    -   components 폴더 하위에 케밥 케이스 규칙으로 이름을 정함
    -   케밥 케이스는 단어를 소문자로 쓰고 하이픈으로 나누는 방식
    -   파나의 단어라면 단순하게 소문자로 표시
    ```
    components/Button
    |-- button.test.tsx
    |-- button.tsx
    |-- index.tsx
    --- style.css
    ```

### 키워드

-   응집력
-   관심사의 분리
-   추상화 계층
-   팩토리 함수
-   인터페이스
