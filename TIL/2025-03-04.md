# TIL | 2025.03.04

## 📌 TIL 요약

### ✅ 스마일게이트 프로젝트 기능 구현

-   초대 링크 로직 설계 및 정리
-   쿼리 키 팩토리

### ✅ 스마일게이트 기술 멘토링

-   스마게 캠프장님 기술 멘토링 내용 공부 및 정리

---

# TIL 상세

## 🔗 초대 링크

슬랙 클론 프로젝트에서 초대 링크 복사하기 기능을 구현해야하는데 명확히 정한바가 없어서 먼저 로직을 생각하고 말씀을 드리고자 정리하였다.

현재 초대 링크 복사 로직은 다음과 같다.

-   `POST`로 `workspaceId`를 전송하면, 응답으로 초대 링크를 반환한다.

여기서 내 고민은 다음과 같다.

-   또한 초대 링크 요청 로직을 커스텀 훅으로 따로 분리했는데, `isLoading`, `isError`를 어디에서 선언하고 사용하는 것이 더 적절할지 고민이다.
    -   (커스텀 훅 내부에서 관리할지, 훅을 사용하는 컴포넌트에서 처리할지)

## ✅ 초대 링크 수락

유저가 초대 링크를 통해 초대 수락 페이지에 들어왔을 때의 다양한 상황에서의 고민이 많았다.

-   만약 우리 서비스 유저가 아니라면

    -   로그인 페이지로 이동시켜 이메일 인증을 완료하게 하고, 인증 완료 후 다시 초대 수락 페이지로 돌아오게 해야 한다.

-   만약 우리 서비스 유저라면

    -   로그인 여부를 어떻게 확인할 것인지부터 로직이 필요하다. (쿠키, 토큰 등을 이용해 체크하는 방식 검토)

> 여기서 문제는, 인증 및 권한 검증을 처리하기 위한 구체적인 로직이 정해지지 않았다.

## ✅ 초대 링크 수락 로직

### 🔐 일반 로그인 시 권한 인가 처리

1. 로그인 시 서버 응답으로

    - `Access Token`은 Response Header에, `Refresh Token`은 Response Cookie에 담겨온다.

2. 받은 토큰들을 쿠키에 저장한다. (쿠키 동작방식 공부 필요)

3. 이후 요청 시 쿠키에 저장된 Access Token을 꺼내서 `Request Header`에 담아 전송한다.

    - 이때, `withCredentials: true` 설정을 해줘야 하는지 잘 몰라서 공부해야한다.
    - 단순히 쿠키로 자동 전송할지, 쿠키에서 꺼내서 Header에 `Bearer Token`에 담아서 보내야하는건지 공부가 필요하다.

4. 로그인한 이력이 있는 유저라면, 쿠키에 저장된 Access Token을 이용해 권한 인가용 API에 요청을 보낸다. (브라우저를 닫아도 쿠키에 저장된 토큰은 유지된다.)

### 🔗 초대 수락 페이지 로직

-   서버에서 초대 수락 URL을 `domain/invite/${workspaceId}` 형태로 제공하면, 프론트엔드에서 해당 URL에 대응하는 초대 수락 페이지를 만든다.

-   초대 수락 페이지에 접속한 유저가 초대 수락 액션을 수행하면, 서버에 본인 확인 API를 호출해 유저 정보를 검증한다.

    -   이때 인증 정보는 `withCredentials` 설정을 통해 쿠키를 자동으로 전송할지, 혹은 Header에 Bearer Token을 담아 보내야하는건지 공부가 필요하다.

## ✅ 권한 인가 및 접근

비정상적인 접근(예: 권한 없는 페이지 접근)에 대한 처리는 다음과 같이 구상하고 있다.

-   유저가 우리 서비스 유저가 아니라면 → 로그인/회원가입 페이지로 이동
-   로그인은 했지만, 해당 워크스페이스에 속해있지 않은 경우 → 워크스페이스 참여 페이지로 이동
-   정상적인 유저이고, 워크스페이스에 속해있다면 → 정상 접근 허용

## ✅ 기술 멘토링

스마게 캠프장님께 마지막 기술 멘토링을 받았던걸 정리하려한다.

---

# 3월 4일 회의 후 결론

## 인증/인가 로직 정리

-   로그인 시 서버 응답으로

    -   `Access Token`은 **Response Body**로 전달.
    -   `Refresh Token`은 **HttpOnly 쿠키**로 저장 (서버에서 `Set-Cookie`로 내려줌).

-   프론트엔드는

    -   Body에서 받은 **Access Token**을 꺼내서 메모리에 저장하거나 상태로 관리.
    -   이후 API 요청 시, `Authorization` 헤더에 `Bearer ${Access Token}` 형태로 담아 요청을 보냄.

-   API 요청 중 Access Token이 만료되었다는 응답(예: `401 Unauthorized`)을 받으면,

    -   `withCredentials: true` 설정을 통해 자동으로 전송된 **HttpOnly 쿠키의 Refresh Token**을 이용해 **Access Token 재발급 요청**을 한다.

-   Refresh Token도 만료되었을 경우:
    -   만료되면 쿠키가 삭제되기 때문에, 더 이상 재발급 요청을 보낼 수 없는 상태가 된다.
    -   이 경우 클라이언트는 Refresh Token 유무를 체크하거나, 재발급 실패 응답을 받으면 **바로 로그인 페이지로 리다이렉트**한다.

---

### ✅ 유저 권한 인가 체크 로직

-   우리 서비스 유저인지 확인:

    -   Access Token이 없다면 → 로그인 페이지로 이동 (로그아웃 상태 또는 만료).
    -   Access Token이 있다면 → 초대 링크 클릭 시 워크스페이스 소속 여부를 확인하는 API 요청.

-   워크스페이스 소속 여부에 따른 처리:
    -   ✅ 소속 O → 해당 워크스페이스 페이지로 이동.
    -   ❌ 소속 X → 워크스페이스 프로필 등록 페이지로 이동.

---

### ✅ 초대 수락 로직

-   서버가 제공한 초대 수락 URL을 `domain/invite/${inviteCode}` 형태로 구성.

-   프론트엔드는 해당 URL에 대응하는 초대 수락 페이지를 라우팅.

-   초대 수락 페이지에서 inviteCode를 본인 확인 API에 전달하면, 서버는 inviteCode로 해당 워크스페이스 정보를 조회하고, workspaceId를 추출하여 유저 정보를 검증한 후 응답을 반환.
-   domain/invite?type=link&code=${invitecode} 통일

## --

## ✅ 핵심 포인트 요약

| 항목           | 방법                                                                      |
| -------------- | ------------------------------------------------------------------------- |
| Access Token   | Body로 받아서 메모리/상태에 저장 후 요청 시 헤더에 넣기                   |
| Refresh Token  | HttpOnly 쿠키로 받아서 재발급 요청 시 자동 전송 (`withCredentials: true`) |
| 만료 처리      | Access 만료 → Refresh로 재발급, Refresh 만료 → 로그인 페이지 이동         |
| 인증 상태 확인 | Access Token 존재 여부로 확인                                             |
| 권한 확인      | 워크스페이스 소속 여부 API로 판단                                         |

## 알게된것

-   토큰을 발급받을때 response body로 받는 방법과 서버에서 쿠키로 넘겨주는 방법이 존재한다.

    -   현재 우리 프로젝트는 엑세스 토큰도 로그인에대한 response body로 받는게 아니라 cookie로 받는다.

-   엑세스 토큰으로 request했을때 권한 오류 응답? 만료 응답을 받으면 리프레시 토큰을 통해서 엑세스 토큰 재발급을 요청한다.
-   리프레시 토큰이 만료되면 로그인으로 유저를 리다이렉트 한다

## 공부할 키워드

-   인증 인가
-   JWT 기반 인증
-   권한 인가 라우팅
-   401

## 나의 고민

-   현재 인증 인가 방식이 좋은 방식인지
-   현재 내가 설계한 로직이 올바른 로직인지

### 공부 관련 링크

-   https://velog.io/@chuu1019/Access-Token%EA%B3%BC-Refresh-Token%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B4%EA%B3%A0-%EC%99%9C-%ED%95%84%EC%9A%94%ED%95%A0%EA%B9%8C
