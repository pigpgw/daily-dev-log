# TIL | 2025.03.04

## 📌 TIL 요약

### ✅ 스마일게이트 프로젝트 기능 구현

-   초대 링크 로직 설계 및 정리
-   쿼리 키 팩토리
-   Axios 인터셉터를 통한 Access Token 재발급 및 Refresh Token 만료 처리 로직 설계

# TIL 상세

## 🔗 초대 링크

슬랙 클론 프로젝트에서 초대 링크 복사하기 기능을 구현해야 했는데, 명확하게 정해진 로직이 없어서 먼저 고민해보고 백엔드에 제안하기 위해 정리했다.

현재 초대 링크 복사 로직은 다음과 같다.

-   `POST`로 `workspaceId`를 전송하면, 응답으로 초대 링크를 반환한다.

여기서 내가 고민한 부분은 다음과 같다.

-   초대 링크 요청 로직을 커스텀 훅으로 분리해두었는데, `isLoading`, `isError`를 어디에서 관리하는 것이 더 적절할지 고민이 되었다.  
    (커스텀 훅 내부에서 처리할지, 사용하는 컴포넌트에서 처리할지)

---

## ✅ 초대 링크 수락

초대 링크를 통해 초대 수락 페이지에 들어온 유저가 어떤 상태인지에 따라 라우팅이 달라지게 된다. 이 과정에서 여러 경우의 수를 고려하면서 고민했던 내용들이다.

-   우리 서비스에 가입하지 않은 유저라면 → 로그인 페이지로 이동 후 이메일 인증 완료 후 다시 초대 수락 페이지로 이동.
-   우리 서비스에 가입한 유저라면 → 로그인 여부를 확인 후 처리.
    -   (Access Token, 쿠키 등을 이용한 인증 확인 로직 필요)

> 문제는, 이런 인증 및 권한 검증을 어떤 방식으로 깔끔하게 처리할지가 정해지지 않은 상태였다는 점이다.

---

## ✅ 초대 링크 수락 로직

### 🔐 일반 로그인 시 권한 인가 처리

1. 로그인 성공 시 서버가 응답으로

    - `Access Token`은 Response Body로,
    - `Refresh Token`은 HttpOnly 쿠키로 내려준다.

2. 받은 Access Token을 상태나 메모리에 저장한다. (쿠키 동작 방식에 대한 추가 학습 필요)

3. 이후 요청 시 저장한 Access Token을 꺼내서 `Authorization` 헤더에 담아 전송한다.

    - 이때 `withCredentials: true` 설정이 필요한지,
    - 쿠키로 자동 전송할지, Header에 Bearer Token으로 담아야 하는지 등 학습할 부분이 남아있다.

4. 로그인한 유저라면, 저장한 Access Token을 이용해 권한 인가용 API에 요청을 보낸다. (브라우저를 닫아도 쿠키에 저장된 Refresh Token은 유지된다.)

---

### 🔗 초대 수락 페이지 로직

-   서버에서 초대 수락 URL을 `domain/invite/${workspaceId}` 형식으로 제공하면, 프론트엔드에서 해당 URL에 대응하는 초대 수락 페이지를 만든다.

-   초대 수락 페이지에 접속한 유저가 초대 수락 액션을 수행하면, 서버에 본인 확인 API를 호출해 유저 정보를 검증한다.
    -   이때 인증 정보는 `withCredentials`로 쿠키를 자동 전송할지,  
        Header에 Bearer Token으로 담아 전송할지 고민이 필요한 부분이다.

---

## ✅ 권한 인가 및 접근

비정상적인 접근(권한 없는 페이지 접근 등)에 대해서는 다음과 같이 구상했다.

-   유저가 우리 서비스 유저가 아니라면 → 로그인/회원가입 페이지로 이동
-   로그인은 했지만 해당 워크스페이스에 속해있지 않은 경우 → 워크스페이스 참여 페이지로 이동
-   정상적인 유저이고, 해당 워크스페이스에 속해있다면 → 정상 접근 허용

---

# 나만의 설계 및 고민

## 인증/인가 로직 정리

-   로그인 성공 시 서버 응답

    -   `Access Token`은 **Response Body**로 전달.
    -   `Refresh Token`은 **HttpOnly 쿠키**로 저장 (`Set-Cookie`).
        -   (_단, MSW 환경에서는 쿠키 mock이 어렵다는 이슈가 있음_)

-   프론트엔드는

    -   Body에서 받은 Access Token을 메모리에 저장하거나 상태로 관리.
    -   이후 API 요청 시 Authorization 헤더에 Bearer Token으로 담아 요청.

-   Access Token 만료(예: 401 Unauthorized 응답) 시

    -   withCredentials 설정으로 자동 전송되는 HttpOnly 쿠키의 Refresh Token을 통해 Access Token 재발급 요청.

-   Refresh Token도 만료된 경우
    -   쿠키가 삭제되어 더 이상 재발급 요청이 불가능.
    -   이때는 재발급 실패 응답을 받으면 로그인 페이지로 리다이렉트.

---

### ✅ 유저 권한 인가 체크 로직

-   우리 서비스 유저인지 확인

    -   Access Token이 없다면 → 로그인 페이지 이동 (로그아웃 상태 or 만료).
    -   Access Token이 있다면 → 초대 링크 클릭 시 워크스페이스 소속 여부를 확인하는 API 요청.

-   워크스페이스 소속 여부에 따른 처리
    -   ✅ 소속 O → 해당 워크스페이스 페이지로 이동.
    -   ❌ 소속 X → 워크스페이스 프로필 등록 페이지로 이동.

---

### ✅ MSW 고민

-   MSW에서는 쿠키에 값을 넣는 처리가 제한적이다.
-   백엔드는 Access Token이 쿠키에 있는지 확인하라고 했지만, HttpOnly 쿠키는 JS 접근이 불가하기에 이 방식은 어렵다.
    -   그래서 임시로 로컬스토리지에 리프레시 토큰을 저장해 mock 처리하고, 추후 연동 시 수정할 예정.

---

### ✅ 초대 수락 로직

-   초대 수락 URL은 `domain/invite/${inviteCode}` 형태로 제공.
-   프론트엔드는 해당 URL에 대응하는 초대 수락 페이지 라우팅.
-   초대 수락 페이지에서 inviteCode를 본인 확인 API에 전달하면, 서버가 해당 워크스페이스 정보를 조회하고, workspaceId를 추출 후 유저 검증 후 응답.
    -   URL은 `domain/invite?type=link&code=${inviteCode}`로 통일.

---

# 마무리

## ✅ 백엔드 의견

-   리프레시 토큰 만료 시 쿠키에서 사라지기 때문에, 브라우저 쿠키에 리프레시 토큰이 없으면 이메일 인증(로그인/회원가입) 페이지로 이동하자고 제안.

---

## ✅ 백엔드 의견에 따른 내 생각

> 백엔드 분의 의견을 듣고 잘못된 부분이 있다고 판단하여 아래와같이 제안드렸습니다.

-   HttpOnly 쿠키는 JS로 접근이 불가능하기 때문에 쿠키 유무 확인 자체가 불가능.
-   따라서 Access Token 존재 여부로 판단하는 게 맞다고 판단.
    -   Access Token이 없으면 이메일 인증 페이지(로그인/회원가입)로 이동.
    -   Access Token이 있다면, 유저 확인 API로 서버에 요청을 보내 해당 유저가 워크스페이스에 속해있는지 여부를 확인 후 라우팅.

## ✅ 나의 고민

-   현재 인증/인가 방식이 적절한지.
-   내가 설계한 로직이 올바른 방향인지.

---
