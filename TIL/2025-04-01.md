# TIL | 2025.03.29

### 오늘 진행 순서 예정

> 패턴으로 읽히고 설계로 완성하는 리액트 -> 스마게 작업 -> 주시 회의 -> 주시 작업 -> 알고리즘

## 📌 TIL 요약

### 알고리즘

-   []정렬과 그리디 결정 알고리즘 10 ~ 12

### 소켓 적용

-   [] 메인페이지에 다른사람이 눌렀을때 실시간으로 해당 시위 위에 이팩트 나오기
    -   [ ] 이펙트 선정
    -   [ ] 컴포넌트 추가

# 스마게

## ConfirmEmailPage 리팩토링하기

### 리팩토링 진행하기

#### 1. **로직 분리**

-   [x] 각 단계(API 호출)의 **비즈니스 로직을 컴포넌트 밖으로 분리**하여 테스트 가능하게 리팩토링

-   [x] `postConfirmEmail`, `postSignIn`, `postLogin`, `postSignUp` 호출 흐름을 **명확히 분리**
-   [] 반복되는 로직은 공통 유틸이나 훅으로 추상화 (진행중)

#### 2. **React Query 적용**

-   [] `useMutation`, `mutate`, `mutateAsync`등 제공하는 기능의 역할을 명확히 구분하여 사용

#### 3. **토큰 저장 로직 고민**

-   [] 단순한 토큰 저장/초기화는 유틸 함수로 분리해야하나

---

### 고민 중인 부분

-   [] **회원가입/로그인 흐름 통합 여부**

    -   백엔드가 설계해둔 로직을 내가 바꾸긴 어려운상황 회원가입하고 로그인은 그냥 유저를 서버에 등록하냐 차이밖에 없기에 분리할 예정(근데 어떻게 이쁘게? 테스트 용이하게?)

-   [] **예외 처리 방향**

    -   모든 인증 단계(postConfirmEmail, postSignIn, postLogin, postSignUp) 중 하나라도 실패하면 전체 흐름 중단(3가지중 하나라도 안되면 어차피 서비스 사용 불가)
    -   실패 시 사용자에게 **toast 알림**을 띄우고, 안내 메시지 또는 “문의하기” 버튼 제공 고려 중

-   [] **로딩 처리 및 에러**
    -   전체적인 예외처리 부족
        -   로딩
        -   에러

---

# 패턴으로 익히고 설계로 완성하는 리액트

-   ch4 리액트 컴포넌트 설계하기 ~

---

# 📌 TIL 상세

## 알고리즘

-   정렬과 그리디 결정 알고리즘
    -   10
    -   11
    -   12

### 소켓 적용

-   [] 메인페이지에 다른사람이 눌렀을때 실시간으로 해당 시위 위에 이팩트 나오기
    -   [ ] 이펙트 선정
    -   [ ] 컴포넌트 추가

## 스마게

### ConfirmEmailPage 리팩토링하기

### 기존 문제점

-   비즈니스 로직이 API 호출부 안에 섞여 있어 **역할 분리가 되지 않음**
-   여러 기능(로그인/회원가입/이메일 인증)을 **하나의 함수로 처리**하려 하면서, **관련 없는 로직도 함께 수행**
-   같은 API를 **중복 호출**하거나 불필요하게 연결된 구조
-   예외 처리 로직이 없어, 오류 발생 시 **사용자 피드백이 불가능**
-   로직 테스트가 어려워 유지보수성 및 확장성이 떨어짐
-   기존 로직
-   <img width="951" alt="스크린샷 2025-03-31 오전 1 00 50" src="https://github.com/user-attachments/assets/d03c8bf6-c7a8-4ff8-b2e4-5614904bdd66" />
-   1차 수정 후 로직
-   <img width="848" alt="스크린샷 2025-03-31 오전 1 02 21" src="https://github.com/user-attachments/assets/9d28f638-e045-463e-9b75-4263f290483c" />
-   나머지 로직은 백엔드 로직이 그러하여 더이상 수정 불가 함 최대한 불필요한 api 요청과 코드실행을 줄이고 유지보수나 테스트가 용이하게 하는것 말고는 없었음

### 리팩토링 방향

#### 1. **로직 분리**

-   [] 반복되는 로직은 공통 유틸이나 훅으로 추상화 (진행중)

#### 2. **React Query 적용**

-   [] `useMutation`, `mutate`, `mutateAsync`의 역할을 명확히 구분하여 사용
    -   `mutate`: 콜백 중심 처리 (빠른 피드백)
    -   `mutateAsync`: async/await 문법과 어울려 **가독성 및 에러 처리 용이**

#### 3. **토큰 저장 로직 고민**

-   [] 단순한 토큰 저장/초기화는 유틸 함수로 분리해야하나

---

### 고민 중인 부분

-   [] **회원가입/로그인 흐름 통합 여부**

    -   백엔드가 설계해둔 로직을 내가 바꾸긴 어려운상황 회원가입하고 로그인은 그냥 유저를 서버에 등록하냐 차이밖에 없기에 분리할 예정(근데 어떻게 이쁘게? 테스트 용이하게?)

-   [] **예외 처리 방향**

    -   모든 인증 단계(postConfirmEmail, postSignIn, postLogin, postSignUp) 중 하나라도 실패하면 전체 흐름 중단(3가지중 하나라도 안되면 어차피 서비스 사용 불가)
    -   실패 시 사용자에게 **toast 알림**을 띄우고, 안내 메시지 또는 “문의하기” 버튼 제공 고려 중

-   [] **로딩 처리 및 에러** (현재 처리중인 작업 기준)
    -   이메일 발송 실패시
    -   로그인 실패시
    -   회원가입 실패시
    -   이메일 인증 실패시

---

## 패턴으로 익히고 설계로 완성하는 리액트

### ch4 리액트 컴포넌트 설계하기

#### 4.1 단일 책임 원칙

-   단일 책임 원칙(SRP)
    -   함수, 클래스 혹은 리액트 컴포넌트는 변경해야 할 이유가 단 하나만 있어야 함(하나의 컴포넌트는 하나의 작업이나 기능만을 수행하는 것이 이상적이다.)

---

## 공부하고 싶은 키워드

## 1. **소프트웨어 설계 원칙 관련**

| 주요 개념                                  | 설명                                           | 함께 공부하면 좋은 개념                                                                   |
| ------------------------------------------ | ---------------------------------------------- | ----------------------------------------------------------------------------------------- |
| **관심사의 분리 (Separation of Concerns)** | 기능/책임/영역을 나눠서 복잡도를 낮추는 원칙   | - SRP (단일 책임 원칙)<br>- 모듈화(Modularity)<br>- MVC/MVVM 패턴<br>- 레이어드 아키텍처  |
| **추상화 계층 (Abstraction Layer)**        | 하위 로직을 숨기고 필요한 기능만 노출하는 구조 | - 캡슐화<br>- 인터페이스 / 추상 클래스<br>- 레이어드 아키텍처<br>- 의존성 역전 원칙 (DIP) |
| **비즈니스 로직 (Business Logic)**         | 애플리케이션의 핵심 규칙/기능을 수행하는 부분  | - 도메인 모델<br>- 서비스 계층<br>- 유스케이스<br>- 엔티티(Entity), DTO                   |

---

## 2. **프론트엔드 구조/설계**

| 주요 개념                                | 설명                                        | 함께 공부하면 좋은 개념                                                     |
| ---------------------------------------- | ------------------------------------------- | --------------------------------------------------------------------------- |
| **Container vs Presentational 컴포넌트** | 비즈니스 로직과 UI 로직을 나누는 React 설계 | - 관심사 분리<br>- 컴포넌트 책임 분리<br>- Hooks 구조화                     |
| **상태 관리 구조 (Zustand, Redux, etc)** | 상태를 어디서/어떻게 다룰지 정의            | - 비즈니스 로직 위치<br>- Store 분리 전략<br>- Selector, middleware         |
| **API Layer 분리**                       | API 요청을 별도 레이어로 나눔               | - Axios 커스텀 인스턴스<br>- Query Hook abstraction<br>- Service Layer 구조 |

---

## 3. **OOP (객체지향 프로그래밍) 관점**

| 주요 개념                      | 설명                               | 함께 공부하면 좋은 개념                                                 |
| ------------------------------ | ---------------------------------- | ----------------------------------------------------------------------- |
| **캡슐화 (Encapsulation)**     | 내부 로직 숨기고 인터페이스만 노출 | - 추상화<br>- 정보 은닉<br>- 인터페이스 설계                            |
| **상속 vs 조합 (Composition)** | 기능 재사용 및 책임 분리 방식      | - 관심사 분리<br>- SOLID 원칙                                           |
| **SOLID 원칙**                 | OOP 설계의 핵심 원칙 5가지         | - SRP: 단일 책임 원칙 → 관심사 분리<br>- DIP: 의존성 역전 → 추상화 계층 |

---

## 4. **실무 적용 관점 (실제로 설계할 때 유용한 개념)**

| 실무에서 접하는 개념    | 연관 개념                                     |
| ----------------------- | --------------------------------------------- |
| 서비스 레이어 설계      | 비즈니스 로직 분리, 추상화 계층, 관심사 분리  |
| 공통 API 오류 처리      | Axios 인터셉터, API 추상화 계층               |
| 유저 인증 흐름          | 상태 관리 분리, 관심사 분리, 로직 단위 모듈화 |
| 파일 구조 설계          | 기능/도메인 기반 구조 → 관심사 분리           |
| 테스트 설계 (단위/통합) | 비즈니스 로직과 UI 로직 분리 필요             |
