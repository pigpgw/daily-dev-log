# TIL | 2025.03.29

### 오늘 진행 순서 예정

> 알고리즘 강의 수강 -> 주시 작업 -> 주시 회의 -> 주시 작업 -> 공부할 키워드 공부 -> 스마게 작업

## 📌 TIL

## 알고리즘

-   강의 수강

### 소켓 폴링 구현

-   리엑트 쿼리의 도입이 올바른가
-   구현한 폴링 방식 올바른가 (그려보기)
    -   필요한 데이터와 상태 흐름을 정리한다
    -   UI 렌더링을 위한 로직과 비즈니스 로직(기능 흐름이나 데이터 처리에 필요한 로직) 생각한다
    -   API 요청 및 응답 흐름을 설계한다
    -   예외 상황(빈 값, 실패, 에러 등)을 예상하고 대응 방식을 고민한다
    -   전체 UI 구조와 컴포넌트 트리를 대략 그려본다

## 스마게

-   DM
    -   연아님이 작성하신 다이렉트 메세지 컴포넌트 분리(워크스페이스 홈의 사이드바에서 다이렉트 메세지 누르면 해당 다이렉트 메세지 나와야하는데 안되어있음)
-   채팅
    -   싹 다 고쳐야함

---

# 한 입 크기로 잘라먹는 타입스크립트

# 패턴으로 익히고 설계로 완성하는 리액트

-   ch4 리액트 컴포넌트 설계하기 ~

---

# 공부할 키워드

-   css
    -   css 잘 설계하는법
    -   css 잘하는법
    -   css variant
-   js
    -   abortcontroller
-   타입 스크립트
    -   타입스크립트의 컴파일 과정
-   공통 컴포넌트 설계
    -   rest
    -   기본 타입 확장
        -   공통 버튼 ㄱ컴포넌트 만드는데 어떻게 해야할지 모르겠음,
-   React
    -   리엑트에서의 단일 책임 원칙
-   next
    -   next Image
    -   next 에서 fetch
    -   next에서 react query
    -   Next.js 에서 local, development, production 환경 셋팅하기

## 1. 타입스크립트 동작 원리

### 타입스크립트의 컴파일 과정

-   TypeScript는 `.ts` 파일을 **JavaScript로 컴파일**하는 정적 타입 언어이다.
-   실제 실행은 브라우저나 Node.js가 하며, TypeScript는 **타입 검사 후 JavaScript 코드로 트랜스파일**된다.
-   타입 정보는 런타임에서 제거되고 **개발 시점에서만 존재**한다.

```txt
.ts (타입 검사 + 트랜스파일) → .js → Node.js 또는 브라우저 실행
```

-   컴파일러(tsc)는 설정(`tsconfig.json`)에 따라 코드 검사 및 변환을 수행한다.

---

### `implements`로 추상 클래스 구현

-   TypeScript에서 `implements`는 클래스가 인터페이스나 추상 클래스의 **타입 구조를 만족**하도록 강제하는 키워드이다.
-   추상 클래스는 실제 JavaScript에서는 **컴파일 시 사라진다**.
-   즉, 타입 수준에서만 체크되며, 런타임에는 **interface나 abstract class 모두 존재하지 않음**.

---

## 2. 구조적 타이핑 (Structural Typing)

-   TypeScript는 **구조적 타입 시스템**을 가진다.
-   이름보다 **형태(shape)** 를 기준으로 타입을 비교한다.
-   명시적으로 `Point` 타입이 아니어도 **구조만 맞으면 통과**된다.

---

## 3. `extends` vs `implements` 차이

| 구분        | `extends`                        | `implements`          |
| ----------- | -------------------------------- | --------------------- |
| 대상        | 클래스, 추상 클래스              | 인터페이스            |
| 의미        | 상속 (상위 클래스 기능 물려받음) | 구조(인터페이스) 만족 |
| 런타임 영향 | 있음 (프로토타입 체인)           | 없음 (타입 체크만)    |

-   `extends`는 실제 실행 코드에도 영향을 줌.
-   `implements`는 **타입 검사**를 위한 선언에 불과함.

---

## 4. `class`와 `interface` 차이

| 항목        | `class`             | `interface`              |
| ----------- | ------------------- | ------------------------ |
| 런타임 존재 | 있음                | 없음                     |
| 인스턴스화  | 가능                | 불가능                   |
| 상속 방식   | extends (단일 상속) | extends (다중 상속 가능) |
| 목적        | 구현체              | 타입 정의                |

-   `interface`는 오직 **타입 검사 용도**
-   `class`는 실제 **코드 구조와 동작을 포함**

---

## React Query는 HTTP 요청 외의 비동기 작업에도 사용할 수 있다.

React Query는 **"비동기 작업"을 캐시하고 관리하는 라이브러리**지, 꼭 HTTP 요청에만 국한되지 않는다.

### 주의

-   **queryKey**는 식별자 역할
-   side-effect가 없고, 순수하게 캐시 가능한 작업에 적합

---

# 프론트엔드 아키텍처

## 뷰 로직과 비즈니스 로직의 분리

### 목적

-   **컴포넌트 재사용성 증가**
-   **유지보수성 향상**
-   **테스트 용이성 확보**

### 예시

#### 뷰 로직 (UI 컴포넌트)

```tsx
const ProductCard = ({ product, onBuy }: Props) => {
    return (
        <div>
            <p>{product.name}</p>
            <button onClick={() => onBuy(product.id)}>구매</button>
        </div>
    );
};
```

#### 비즈니스 로직 (커스텀 훅)

```ts
const useBuyProduct = () => {
    const mutation = useMutation((productId) => buyAPI(productId));
    return mutation;
};
```

### 좋은 구조

-   UI: 입력 → 출력에 집중 (props 기반)
-   로직: 상태 관리, 요청 처리 등은 **hooks나 service 파일로 분리**

## 공부하고 싶은 키워드

## 1. **소프트웨어 설계 원칙 관련**

| 주요 개념                                  | 설명                                           | 함께 공부하면 좋은 개념                                                                   |
| ------------------------------------------ | ---------------------------------------------- | ----------------------------------------------------------------------------------------- |
| **관심사의 분리 (Separation of Concerns)** | 기능/책임/영역을 나눠서 복잡도를 낮추는 원칙   | - SRP (단일 책임 원칙)<br>- 모듈화(Modularity)<br>- MVC/MVVM 패턴<br>- 레이어드 아키텍처  |
| **추상화 계층 (Abstraction Layer)**        | 하위 로직을 숨기고 필요한 기능만 노출하는 구조 | - 캡슐화<br>- 인터페이스 / 추상 클래스<br>- 레이어드 아키텍처<br>- 의존성 역전 원칙 (DIP) |
| **비즈니스 로직 (Business Logic)**         | 애플리케이션의 핵심 규칙/기능을 수행하는 부분  | - 도메인 모델<br>- 서비스 계층<br>- 유스케이스<br>- 엔티티(Entity), DTO                   |

---

## 2. **프론트엔드 구조/설계**

| 주요 개념                                | 설명                                        | 함께 공부하면 좋은 개념                                                     |
| ---------------------------------------- | ------------------------------------------- | --------------------------------------------------------------------------- |
| **Container vs Presentational 컴포넌트** | 비즈니스 로직과 UI 로직을 나누는 React 설계 | - 관심사 분리<br>- 컴포넌트 책임 분리<br>- Hooks 구조화                     |
| **상태 관리 구조 (Zustand, Redux, etc)** | 상태를 어디서/어떻게 다룰지 정의            | - 비즈니스 로직 위치<br>- Store 분리 전략<br>- Selector, middleware         |
| **API Layer 분리**                       | API 요청을 별도 레이어로 나눔               | - Axios 커스텀 인스턴스<br>- Query Hook abstraction<br>- Service Layer 구조 |

---

## 4. **실무 적용 관점 (실제로 설계할 때 유용한 개념)**

| 실무에서 접하는 개념    | 연관 개념                                     |
| ----------------------- | --------------------------------------------- |
| 서비스 레이어 설계      | 비즈니스 로직 분리, 추상화 계층, 관심사 분리  |
| 공통 API 오류 처리      | Axios 인터셉터, API 추상화 계층               |
| 유저 인증 흐름          | 상태 관리 분리, 관심사 분리, 로직 단위 모듈화 |
| 파일 구조 설계          | 기능/도메인 기반 구조 → 관심사 분리           |
| 테스트 설계 (단위/통합) | 비즈니스 로직과 UI 로직 분리 필요             |

### 참조

-   https://ssocoit.tistory.com/253
