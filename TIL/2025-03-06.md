# TIL | 2025.03.04

## 📌 TIL 요약

### Next 공부

-   한입 크기로 잘라먹는 Next.js

    -   ## app Router

### smiletogether

-   기본 동작 체크
    -   리엑트 쿼리
        -   부족한 부분
        -   올바른 사용법
        -   쿼리 키 팩토리
    -   리팩토링
        -   네이게이터 객체
            -   비동기 v7
            -   뒤로가기
                -   뒤로가기 nav(-1)
                -   뒤로가기 방지
        -   에러 핸들링 고민
            -   interceptor에서
            -   리엑트 쿼리에서 에러
        -   api request, response type
        -   type
            -   재활용 가능한 타입 사용

### 주시

### 알고리즘

-   스택, 큐
-   재귀
-   dfs
    -   행렬 코드는 y x 로 작성하는걸 추천함 그 이유는 몇차원 배열이든 결국 1차원 배열(줄)단위로 저장되는데 행 기준으로 접근해야 메모리적으로 올바름 x y로 작성하면 다른 열에 접근을 해야함
-   bfs

### 개인 공부

-   프론트엔드 TDD
-   Next

---

# TIL 상세

### Next 공부

-   한입 크기로 잘라먹는 Next.js

    -   ## app Router

        -   페이지에거 전달괴는 쿼리 스트링 url 파라미터 경로상에 포함되는 값들은 props로 전달됨
            -   searchParams : 쿼리스트링 - 빌드타임에 페이지를 생성하기 위해서 빌드타임에 값을 알 수 없는 쿼리스트링 같은 훅을 실행하려하면 오류가 남( 오직 클라이언트 측에서만 실행되게 사전 렌더링에서 배제되게 리엑트 내장 컴포넌트인 suspense로 감싸주면됨)
                -   suspense 클라이언트 컴포넌트를 감싸주면 사전 렌더링에서 제외되고 오직 클라이언트에서만 실행됨
            -   params : url 파라미터
        -   서버 컴포넌트
            -   페이지 라우터 버전에는 없었음
            -   서버측에서만 실행됨
            -   서버측에서 실행될때 딱 한번만 실행됨
            -   사전 렌더링 과정중에 화면에 상호작용을 추가하기 위해 하이드레이션을 추가하기 위해 모든 컴포넌트를 묶어서 js bundle을 보내주는데 브라우저에 그렇게 보내진 컴포넌트들은 하이드레이션을 위해서 한번 더 실행된다.
                -   근데 모든 컴포넌트가 포함될 필요가 없었음 (꼭 필요한 친구들만 상호작용이 필요 없는 정적인 친구들)
                -   상호작용이 필요 없는 친구들은 구지 브라우저에서 한번 더 실행될 필요가 없었음 근데 번들로 보내줄때 모두 다 보내줘서 어쩔수없이 실행됬음 (js bundle이 쓸대없이 커짐 -> 그렇게되면 하이드레이션 시간 오래걸리고 tti 시간 증가)
                    -   사전 렌더링 과정중에 js bundle에 포함될 필요가 없는것(상호작용이 없는 컴포넌트)들은 하이드레이션 될 필요 없는 것들은 제거
                        -   넥스트 서버측에서 사전 렌더링 할때 UI 렌더링을 위해서 한번만하고 그 이후에는 필요 없는것들을 위해서 서버 컴포넌트(브라우저에서 실행되지 않는)가 나옴
                            -   클라이언트 컴포넌트 : 사전 렌더링 진행할때 한번, 하이드레이션 진행할 떄 한번 총 2번 실행
                            -   서버 컴포넌트 : 서버측에서 가전 렌더링을 진행할 때 딱 한번만 실행 됨
                                -   js bundle 전송시 클라이언트 컴포넌트만 포함
                -   > 페이지 대부분을 서버 컴포넌트로 구성할 것을 권장 클라이언트 컴포넌트는 꼭 필요한 경우에만 사용할 것
            -   엡 라우터에서느 기본적으로 서버컴포넌트임 따로 만들어줄 필요가 없음
                -   서버 컴포넌트는 브라우저에서 실행되지 않기에 콘솔 찍어도 브라우저에 안찍힘
                -   반대로 브라우저에서만 할 수 있는것을 하지 못함
                    -   리엑트 훅스(브라우저에서만 동작함)
                        -   만약 사용하고 싶다면 클라이언트 컴포넌트로 만들어줘야함 : "use client" 파일 상단에 작성해주기
                            -   클라이언트 컴포넌트로 바꿔주고 콘솔 확인하면 서버에서 한번 찍히고 브라우저에 한번 찍힘
            -   서버컴포넌트 클라이언트 컴포넌트 기준
                -   상호작용이 있는가
                    -   html의 고유 기능(link 등등)말고 js 상호작용이 필요한 부분은 클라이언트 컴포넌트
                    -   최대한 클라이언트 컴포넌트를 줄이는게 좋기에 클라이언트 컴포넌트만 분리해서 하는게 좋음
            -   주의사항
                1. 서버 컴포넌트에는 브라우저에서 실행될 코드가 포함되면 안된다.
                2. 클라이언트 컴포넌트는 클라이언트에서만 실행되지 않는다.
                    - 사전 렌더링을 위해 서버에서 1번 실행, 하이드레이션을 위해 브라우저에서 1번 실행 = 서버와 클라이언트에서 모두 실행됨
                        - 어쩔수 없이 클라이언트 컴포넌트가 서버 컴포넌트를 자식으로 둬야한다면 children으로 받아서 렌더링해라
                3. 클라이언트 컴포넌트에서 서버 컴포넌트를 import 할 수 없다.
                    - 서버 컴포넌트는 서버에서만 실행되기 때문에 (자바스크립트 번들의 용량을 줄이기위해 번들에서 제외됨 브라우저에 코드가 존재하지 않기에)
                        - 서버 컴포넌트를 클라이언트 컴포넌트에서 호출시 Next는 해당 컴포넌트를 클라이언트 컴포넌트로 바뀌버림
                4. 서버 컴포넌트에서 클라리언트 컴포넌트에게 직렬화 되지 않는 Props는 전달 불가하다.
                    - 직렬화 : 객체, 배열, 클래스 등의 복잡한 구조의 데이터를 네트워크 상으로 전송하기 위해 아주 단순한 형태(문자열,Byte)로 변환하는 것
                        - 함수는 직렬화가 불가능 함(서버 컴포넌트에서 클라이언트 컴포넌트 Props로 전달 불가능)
                            - 자바스크립트 함수는 어떠한 값이 아닌 코드블록들을 포함하고 있는 특수한 형태를 가지고 심지어 클로저나 렉시컬 스코프등의 환경에 의존하여 모든 정보들을 문자열이나 Byte로 표현 불가능함
                    - 모든 컴포넌트들이 한방에 실행되지는 않음
                        - 사전 렌더링 과정중에는 서버 컴포넌트들이 먼저 실행되고 그 이후에 클라이언트 컴포넌트들이 실행됨 - 서버 컴포넌트들이 실행되면 문자열과 비슷한 RSC Payload가 생성됨(리엑트 서버 컴포넌트의 순수한 데이터)(직렬화 한 결과) - RSC Payload - 서버 컴포넌트의 렌더링 결과 - 연결된 클라이언트 컴포넌트의 위치 - 클라리언트 컴포넌트에게 전달하는 Props 값
        -   라우팅
            -   [id] : 동적 라우팅
            -   [...id] : 캐치 올 세그먼트 : 여러개 파라미터 처리 가능, 근데 url 파라미터가 아예 없는 값에는 대응이 되지 않음
            -   [[...id]] : 옵셔널 캐치 올 세그먼트로 해주면 경로 뒤에 파라미터가 있든 없든 페이지로 보냄
        -   레이아웃
            -   layout.tsx 하위 페이지에 모두 적용됨, 중첨됨
            -   라우트 그룹
                -   경로와 관계없이 특정 페이지에만 적용하는 레이아웃
                -   이름을 소관호로 감싸서 사용 (~~~) 경로상에는 아무런 영향을 미치지 않는 그런 폴더
                -   라우트 그룹 아래에 페이지 넣으면 경로상에 영향을 미치지 않으며 레이아웃만 동일하게 가져갈 수 있다는게 장점
        -   Co-Location : 파일의 이름이 page, layout 이 아니면 일반적인 타입스크립트 파일로 여김

        -   hook

            -   useSearchParams 현재 페이지에 전달된 쿼리 스트링 꺼내옴 searchParams.get("쿼리스트링 값")

        -   데이터 패칭
            -   page Router
                -   getServerSideProps
                -   getStaticProps
                -   getStaticPaths
                -   서버에서만 실행되려면 위 3가지 함수를 이용해야했음
                -   이렇게되면 서버측에서 불러오는 모든 테이터는 결국 컴포넌트 트리의 최상단에 위치하는 페이지 컴포넌트에게만 전달되어 하위 컴포넌트들에서 사용하려면 힘들게 넘겨줘야했다.
            -   App router
                -   서버컴포넌트 추가로 async를 붙여서 해당 컴포넌트에서 데이터를 직접 불러옴녀 됬음
                -   클라이언트 컴포넌트에는 Async 키워드를 사용할 수 없었음 : 브라우저에서 동작시 문제를 일으킬 수 있기 때문에 권장되지 않음
                -   그냥 데이터가 필요한 컴포넌트에서 데이터 불러와라 : 공식문서에서 데이터는 필요한 곳에서 직접 불러와라고 적어둠
            -   env
                -   NEXT_PUBLIC 이라는 접두사가 없으면 자동으로 서버측에서만 접근하게 해버림
            -   데이터 캐시 : 백엔드 서버로부터 불러온 데이터를 거의 영구적으로 보관하기 위해 사용됨, 서버 가동중에는 영구적으로 보관됨
                -   force-cache : 요청의 결과를 무조건 캐싱함, 한번 호출 된 이후에는 다시는 호출되지 않음
                -   no-store : 데이터 패칭의 결과를 저장하지 않는 옵션, 캐싱을 아예 하지 않도록 설정하는 옵션
                -   revalidate: 10 : 특정 시간을 주기로 캐시를 업데이트 함, 마치 페이지 라우터의 isr 방식과 유사
                -   tags : ['a']
            -   리퀘스트 메모이제이션 : 다양한 api 요청중 중복된 요청 캐싱해서 딱 한번만 하게하는 것 데이터 패칭 최적화
                -   하나의 페이지를 렌더링 하는 동안에 중복된 api 요청을 캐싱하기 위해 존재함, 렌더링이 종료되면 몯느 캐시가 소멸됨
                -   그냥 중복요청 안보내면 되는거 아닌가? => 서버 컴포넌트의 도입때문
                    -   엡라우터 버전에서는 데이터를 필요한 부분에서 부르기에 동일한 api이지만 중복되는 요청이 많아짐
            -   풀 라우트 캐시
                -   Next 서버측에서 빌드 타임에 특정 페이지의 렌더링 결과를 캐싱하는 기능
                    -   빌드타임에 미리 랜더링해서 리퀘스트 메모이제이션하고 데이터 캐시 등의 캐시 를 거쳐서렌더링 완료하게 되면 풀라우트 캐시라는 이름으로 결과를 저장함
                        -   이미 빌드타임에 저장하였기에 캐싱된거 보내줌
                -   어떤 파일이 풀 라우트 캐시가 되는가 ? => 어떤 기능을 사용하느냐에 따라 자동으로 나뉜다
                    -   페이지 종류
                        -   정적 페이지 (풀 라우트 캐시가 적용 됨)
                            -   정적 페이지로 설정되는 기준 : 동적 페이지가 아니면 모두 정적 페이지가 된다 (동적 함수 사용하지 않고 데이터 캐싱 사용하는 것)
                            -   풀라우트 캐시 적용됨 : 빌드타임에 미리 해당 페이지가 렌더링됨
                        -   동적 페이지
                            -   동적 페이지로 분류되는 기준 : (특정 페이지가 접속 요청을 받을 때 마다 매번 변화가 생기거나, 데이터가 달라질 경우 (\*주의 : 서버 컴포넌트만 해당됨 클라이언트 컴포넌트는 유형에 영향을 미치지 않음))
                                -   캐시가 되지 않는 Data Fetching을 사용할 경우
                                -   동적 함수(쿠키, 헤더, 쿼리스트링)을 사용하는 컴포넌트가 있을 때
            -   generateStaticParams
            -   dynamicParams
            -   fallback
                -   미완성이라는 뜻
                -   suspense로 묶여있는건 일단 사전렌더링때 미완성으로 놔둠 해당 컴포넌트의 비동기 작업이 끝날때까지 미완성으로 남아있음

### smiletogether

-   기본 동작 체크
    -   리엑트 쿼리
        -   부족한 부분
            -   enabled
                -   false 면 실행 안함, 조건이 아직 없을때, 값이 들어올 때만 호출하고 싶을때
                -   없으면 매개변수가 없어도 실행이 되버림
                    -   enabled 값에 !!를 붙이는데 그 이유는 !!는 값을 boolean으로 강제 변환하기에 사용한다 값이 없는 false이면 멈추고 true이면 실행되는 이유이다
            -   staleTime
                -   데이터 신선도 지정한 시간동안은 호출해도 재호출 안함
            -   cacheTime
                -   쿼리를 쓰지 않아도 얼마나 오래 메모리에 남길지 시간
            -   refetchOnWindowFocus
                -   창이 다시 활성화될 때 새로 요청할지 여부
            -   retry
                -   실패시 몇번 재시도할지
            -   select
                -   받아온 데이터를 미리 가공해서 전달
        -   올바른 사용법
        -   쿼리 키 팩토리
    -   리팩토링
        -   네이게이터 객체
            -   비동기 v7
            -   뒤로가기
                -   뒤로가기 nav(-1)
                -   뒤로가기 방지
        -   에러 핸들링 고민
            -   interceptor에서
            -   리엑트 쿼리에서 에러
        -   api request, response type
        -   type
            -   재활용 가능한 타입 사용

### 주시

### 알고리즘

-   스택, 큐
-   재귀

### 개인 공부

-   프론트엔드 TDD
-   Next
