# TIL | 2026.01.13 (화요일)

## 26년도 목표

-   인스타/유튜브 시간제한 : 불필요하게 접속해 타임 킬링하는 것을 줄인다. → 하루 30분 목표
-   계획한 데일리 루틴을 확립하여 점진적 성장을 이룬다. -> 주말은 평일에 수행하지 못한 것과 부족한 공부를 보충한다.
-   알고리즘 골드 달성
-   취뽀or 취뽀 전까지 싸피 합격해서 용돈 + 취업지원 받기
-   정처기 취득
-   오픽 취득
-   컴포넌트 패턴, 디자인 패턴, 객체 지향 코드 작성 방법 학습 및 터득
-   면접 대비 : 면접 질문에 답변할 수 있는 기본 실력 다지기, 모르는 키워드/질문에 대한 사고 확장을 위한 배경 지식 쌓기, 두괄식 설명 습관 기르기, 간결하고 핵심적인 답변 연습
-   매일매일 서비스에서 받은 면접질문들 상세 개념까지 이해하고 설명 가능하게 정리및 공부

## 일정

-   [ ] 01.16 ~ 01.17 : 스키장 (금요일 휴가 써야함)
-   [ ] ~ 01.31 : 근무 (실업급여 신청)
-   [ ] 03.23 : 정처기 실기 원서 접수
-   [ ] 04.18일 : 실기 시헝

## 월별 목표

-   1월 : 작성한 루틴 생활화, 첫 번째 회사에서 작업한 것 정리 및 포트폴리오화
-   2월 : 오픽 시험 보기
-   3월 : 백준 골드 달성하기 (새 계정으로)
-   4월 : 정처기 취득

## 학습하고 싶은 것들

> **참고**: 반복 루틴이 아닌, 하고 싶은 공부나 학습 주제를 기록합니다.

-   [x] 패턴으로 익히고 설계로 완성하는 리액트 챕터 11 내용 학습 및 구현
    -   [x] 다시 읽기
    -   [x] ACL 구현
    -   [x] 클래스 기반 모델 학습 및 추상 클래스 활용
    -   [x] 계층 구조 설계 및 적용
-   [x] 인터넷 구조 (ISP, 라우터 개념) 처음부터 끝까지 자세하게 보완하기
-   [ ] 패턴으로 익히고 설계로 완성하는 리액트 챕터 13 내용 학습 및 구현

    -   [ ] 모르는 내용들 구현

        -   [ ] 기본 설계 원칙
            -   [ ] 단일 책임 원칙
            -   [ ] 의존관계 역전 원칙
            -   [ ] 중복 배제 원칙
            -   [ ] ACL
            -   [ ] 합성
        -   [ ] 비즈니스 로직

            -   [ ] 비즈니스 로직을 코드로 분리한다
            -   [ ] 서비스 로직을 코드로 분리한다
            -   [ ] 도메인 로직을 코드로 분리한다
            -   [ ] 비즈니스 / 서비스 / 도메인 로직 차이를 코드로 구분한다
            -   [ ] 각 로직에서 하면 안 되는 책임을 제거한다

        -   [ ] 비즈니스 · 도메인 · 서비스

            -   [ ] Business / Service / Domain 역할을 코드로 구분한다
            -   [ ] 실제 코드 기준으로 각 계층의 위치를 고정한다
            -   [ ] 로직 배치 판단 기준을 적용한다

        -   [ ] 비즈니스 로직 누수

            -   [ ] 비즈니스 로직 누수를 코드에서 찾아낸다
            -   [ ] 대표적인 누수 패턴을 직접 제거한다
                -   [ ] View(Component)의 조건 판단 로직 제거
                -   [ ] Custom Hook에서 도메인 규칙 제거
                -   [ ] Service가 도메인 규칙을 침범하는 코드 제거
            -   [ ] 누수 발생 원인을 코드 기준으로 정리한다
            -   [ ] 해결 전략을 코드에 적용한다
                -   [ ] 1순위: Custom Hook / Service / Domain 함수 책임 재정의
                -   [ ] 2순위: Layered Architecture 강화
                -   [ ] 계층 간 의존성 방향을 제한한다
                -   [ ] 상위 → 하위 의존성만 허용한다
                -   [ ] 필요 시 ACL (Anti-Corruption Layer)을 적용한다

        -   [ ] 뷰 로직 · 비즈니스 로직 분리

            -   [ ] View에서 비즈니스 판단 로직을 제거한다
            -   [ ] Business 로직을 View 밖으로 이동한다
            -   [ ] View가 데이터 표현만 담당하게 만든다
            -   [ ] 비즈니스 로직이 View로 새지 않도록 구조를 고정한다

            -   [ ] MVC 구조를 코드로 적용한다

                -   [ ] 각 계층 책임을 코드로 분리한다
                -   [ ] View–Controller–Model 관계를 명확히 한다

            -   [ ] MVVM 구조를 코드로 적용한다

                -   [ ] View–ViewModel–Model 책임을 코드로 분리한다
                -   [ ] ViewModel의 역할을 코드로 구현한다

            -   [ ] MVC vs MVVM을 실제 코드 기준으로 비교한다
            -   [ ] 프론트엔드에서 MVVM을 선택하는 기준을 적용한다

        -   [ ] 고차 컴포넌트
        -   [ ] 헤드리스 컴포넌트
        -   [ ] 계층화된 아키텍처

-   [ ] SDD 학습하여 나만의 이력서/포트폴리오 디벨롭용 가이드 만들기
    -   로사와 아키가 SDD해둔 커서룰과 커맨드 참고
-   [ ] 윤성이가 설명한 프로젝트에 도커 도입 이유 및 관련 내용 자세히 정리하기
-   [ ] 리엑트 훅별 사용법 마스터 (상황별?)
-   [ ] 마스터 공유자료 학습

## 데일리 루틴

-   [x] 09:00 ~ 10:00 : 알고리즘
-   [x] 10:00 ~ 18:00 : 일
-   [ ] 18:10 ~ 19:30 : 운동
-   [x] 19:30 ~ 21:00 : 저녁 식사 및 휴식
-   [x] 21:00 ~ 21:30 : 책 읽고 정리 (하루에 한 챕터씩)
    -   [x] [패턴으로 익히고 설계로 완성하는 리액트](../books/패턴으로 익히고 설계로 완성하는 리액트/)
-   [x] 22:30 ~ 23:30 : 개인 프로젝트
-   [x] 00:00 ~ 00:30 : CS 공부
    -   [x] 매일 매일 서비스 주제 한개 공부
    -   [x] 매일 매일 면접질문 한개씩 우선 노션 정리 구조 잡히면 피그마에([참고 블로그](https://velog.io/@chy8165/2025-%ED%9A%8C%EA%B3%A0-%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4%EB%B6%80%ED%84%B0-%EC%9A%B0%EC%95%84%ED%95%9C%ED%98%95%EC%A0%9C%EB%93%A4-%ED%95%A9%EA%B2%A9%EA%B9%8C%EC%A7%80))

---

# TIL - 오늘 배운 것

> **기록 방법 안내**: 막연한 표현이 아닌 **구체적인 사실**을 나열하고, 각 사실에 **이름(범주)**을 붙여 구조적으로 정리.

### **예시**

-   "오늘 스크롤 버그 고쳤다" ❌
-   → "특정 브라우저(IE11)에서만 position: sticky가 작동하지 않았다" **[문제 정의]**
-   → "개발자 도구로 디버깅해보니 상위 DOM의 transform 속성과 충돌했다" **[기술적 원인]**
-   → "애니메이션 때문에 transform을 제거할 수는 없었다" **[제약 조건]**
-   → "DOM 구조를 변경하여 해결했다" **[최종 해결책]**

---

## 알고리즘

**풀이 과정(사고)**:

-   **30분간 문제의 접근법**을 고민해본다.
-   30분이 지났을 때 **접근법이 떠오르지 않았다면, 인터넷에 검색하여 풀이**를 찾아본다.
-   접근법이 떠올랐다면 **30분 동안 구현하고 풀어본다**.
-   30분이 지났을 때 **풀지 못했다면 인터넷에 검색하여 풀이**를 찾아본다.
-   다른사람의 코드를 본다
-   **solved.ac 기준 플래티넘을 목표로**
-   **그렇다고 티어에 집착해선 안된다.**
-   **시간복잡도를 계산하라**
-   **예제 입력은 테스트 케이스의 일부이다.**
    -   **저희가 짠 코드의 반례를 직접 찾는겁니다.**

---

### 문제 1: [퇴사](https://www.acmicpc.net/problem/14501)

**두괄식 요약** (오늘의 핵심 1-2문장): 다양한 문제를 많이 풀어봐야한다.

-   **구체적인 사실들**: bfs돌릴려고함 하지만 너무 단순하게 생각함 선택하지 않는 경우를 고려하지 못하고 무작정 기본 틀만 작성하고 기본 사고를 깨지 못하고 틀림

**다른 사람 코드에서 배운 점**: 선택한경우, 선택하지 않은경우, 1차원적으로 생각 우선 단순하게 자세하게 생각하고 디벨롭 해야한다. 근데 나는 깊게 대충 생각해 버리니 문제가 된다.

## 책 읽기

### 13. 일반적인 안티패턴

#### 1 Props Driling

-   해결책 : Context API를 사용하여 해결

#### 2.긴 props 목록과 너무 많은 기능을 가진 컴포넌트

-   긴 props 목록과 많은 양의 로직을 품고 있는 거대한 컴포넌트는 재사용과 유지보수 어려움 : SRP 위반
-   해결책
    -   컴포넌트를 더 작고 다루기 쉬운 컴포넌트로 나누고 관심사 분리
    -   각 컴포넌트는 명확한 단 하나의 책임을 구현해야 함
    -   사용자 정의 훅 또한 컴포넌트 코드를 단순하게 하고 크기를 줄이는 강력한 수단

#### 3. 비즈니스 로직 누수

-   순수한 렌더링만 담당해야 할 컴포넌트에 비즈니스 로직이 추가될 때 발생 -> 애플리케이션 관리를 복잡하게 만들고 컴포넌트 재사용 가능성을 낮춤
-   해결책
    -   사용자 정의 훅을 사용하여 프레젠테이션 로직에서 비즈니스 로직을 분리하거나, 비즈니스 로직을 별도의 모듈 또는 계층으로 재배치하면 해결 가능
    -   또한 AC(오류 방지 계층)을 적용하는것도 방법
        -   비즈니스 로직 누수란 : UI 계층이 비느지느 규칙을 알게되는 현상
        -   왜 문제냐
            -   UI가 정책을 앎
            -   규칙 바뀌면 화면 코드 수정
            -   테스트도 UI 테스트로 해야 함
        -   해결방법
            -   1순위
                -   커스텀 훅
                -   서비스 도메인 레이어 : “규칙·정책·판단을 담당하는 순수한 로직”

#### 4, 뷰 영역의 복잡한 로직

-   뷰는 가능한한 깔끔하게 유지되어야 하며, 오직 데이터 랜더링에 대한 책임만 있

#### 5. 단계별 테스트 부족

-   애플리케이션 기능을 확인하기 위한 적절한 단위, 통합, E@E 테스트가 없다면, 버그 발생으로 이어지고 리팩터링 확장 어려움
-   해결챔 : TDD, 단위, 통합,E2E 테스트를 포함하는 강력한 테스팅 전략

#### 6.중복된 코드

-   해결책 : 중복 배제 원칙(DRY)을 준수하고 공통의 기능을 유틸리티 함수, 컴포넌트 또는 훅으로 추상화하여 코드 중복을 줄이고 유지 보수성을 높일 수 있음

### 13.2 디자인 패턴

#### 13.2.1 고차 컴포넌트

-   HOC는 컴포넌트 로직을 재사용하기 위한 유용한 패턴
-   해결되는 것들 : 컴포넌트간 공통된 동작 추출 및 공유, props driling 및 코드 중복과 같은 문제를 완화하는데 도욷뫼

#### 13.2.2 render prop

#### 13.2.3 헤드리스 컴포넌트

-   동작과 로직을 관리하지만 UI를 렌더링하지 않는 컴포넌트로, 사용자에게 렌더링에 대한 제어권을 넘김
-   동작 로직을 프레젠테이션 로직에서 분리하며, 비즈니스 로직 누수 및 복잡한 뷰 로직에 대한 해결책이 될 수 있음
-   컴포넌트 유지보수성 향상

#### 13.2.4 데이터 모델링

-   컴포넌트 내의 로직 단순화, 뷰의 복잡한 로직과 비즈니스 로직 누수를 해결하는데 사용될 수 있음

#### 13.2.5 계층화된 아키텍처

-   각 계층이 특정 책임을 지게 하도록 관심사를 분리하고 코드를 구성하는 것

#### 13.2.6 인터페이스로서의 컨텍스트

-   켄텍스트를 인터페이스로 활용하여 props driling 해결

### 기본 설계 원칙 복습

#### 단일 책임 원칙

-   클래스 또는 컴포넌트가 변경되어야 할 이유는 단 하나만 있어야 한다.

#### 의존관계 역전 원칙(DIP)

-   구체화가 아닌 추상화에 의존하는 것을 강조
-   상위 추상 레벨과 하위 구현 레벨을 분리할 수 있음
-   비즈니스 로직 누수를 관리하고 관심사를 분리하는데에 활용할 수 있음

#### 중복 배제 원칙(DRY)

#### ACL(오뷰 방지 계층)

#### 합성

## 공부하고 싶은거

### ACL

```typescript
// acl/dto/ExternalMenuDTO.ts
export interface ExternalMenuDTO {
    menu_nm: string;
    menu_prc: string;
}

export class MenuItem {
    private readonly _name: string;
    private readonly _price: number;
    constructor(name: string, price: number) {
        this._name = name;
        this._price = price;
    }

    get name(): string {
        return this._name;
    }
    get price(): number {
        return this._price;
    }
}

export class MenuACL {
    static toDomain(dto: ExternalMenuDTO): MenuItem {
        return new MenuItem(dto.menu_nm, Number(dto.menu_prc));
    }
}
```
