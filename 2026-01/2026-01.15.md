# TIL | 2026.01.15 (목요일)

## 26년도 목표

-   인스타/유튜브 시간제한 : 불필요하게 접속해 타임 킬링하는 것을 줄인다. → 하루 30분 목표
-   계획한 데일리 루틴을 확립하여 점진적 성장을 이룬다. -> 주말은 평일에 수행하지 못한 것과 부족한 공부를 보충한다.
-   알고리즘 골드 달성
-   취뽀or 취뽀 전까지 싸피 합격해서 용돈 + 취업지원 받기
-   정처기 취득
-   오픽 취득
-   컴포넌트 패턴, 디자인 패턴, 객체 지향 코드 작성 방법 학습 및 터득
-   면접 대비 : 면접 질문에 답변할 수 있는 기본 실력 다지기, 모르는 키워드/질문에 대한 사고 확장을 위한 배경 지식 쌓기, 두괄식 설명 습관 기르기, 간결하고 핵심적인 답변 연습
-   매일매일 서비스에서 받은 면접질문들 상세 개념까지 이해하고 설명 가능하게 정리및 공부

## 월별 목표

-   1월 : 작성한 루틴 생활화, 첫 번째 회사에서 작업한 것 정리 및 포트폴리오화
-   2월 : 오픽 시험 보기
-   3월 : 백준 골드 달성하기 (새 계정으로)
-   4월 : 정처기 취득

## 데일리 루틴

-   [x] 09:00 ~ 10:00 : 알고리즘
-   [x] 10:00 ~ 18:00 : 일
-   [ ] 18:10 ~ 19:30 : 운동
-   [x] 19:30 ~ 21:00 : 저녁 식사 및 휴식
-   [x] 21:00 ~ 21:30 : 리액트 공식문서 학습
-   [x] 21:30 ~ 22:30 : 알고리즘
-   [x] 22:30 ~ 23:30 : 개인 프로젝트 리액트 공부로 대체
-   [ ] 23:30 ~ 00:00 : 오픽
-   [x] 00:00 ~ 00:30 : CS 공부
    -   [x] 매일 매일 서비스 주제 한개 공부
    -   [x] 매일 매일 면접질문 한개씩 우선 노션 정리 구조 잡히면 피그마에([참고 블로그](https://velog.io/@chy8165/2025-%ED%9A%8C%EA%B3%A0-%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4%EB%B6%80%ED%84%B0-%EC%9A%B0%EC%95%84%ED%95%9C%ED%98%95%EC%A0%9C%EB%93%A4-%ED%95%A9%EA%B2%A9%EA%B9%8C%EC%A7%80))
-   [x]이력서 수정

---

# TIL - 오늘 배운 것

> **기록 방법 안내**: 막연한 표현이 아닌 **구체적인 사실**을 나열하고, 각 사실에 **이름(범주)**을 붙여 구조적으로 정리.

### **예시**

-   "오늘 스크롤 버그 고쳤다" ❌
-   → "특정 브라우저(IE11)에서만 position: sticky가 작동하지 않았다" **[문제 정의]**
-   → "개발자 도구로 디버깅해보니 상위 DOM의 transform 속성과 충돌했다" **[기술적 원인]**
-   → "애니메이션 때문에 transform을 제거할 수는 없었다" **[제약 조건]**
-   → "DOM 구조를 변경하여 해결했다" **[최종 해결책]**

## 알고리즘

**풀이 과정(사고)**:

-   **30분간 문제의 접근법**을 고민해본다.
-   30분이 지났을 때 **접근법이 떠오르지 않았다면, 인터넷에 검색하여 풀이**를 찾아본다.
-   접근법이 떠올랐다면 **30분 동안 구현하고 풀어본다**.
-   30분이 지났을 때 **풀지 못했다면 인터넷에 검색하여 풀이**를 찾아본다.
-   다른사람의 코드를 본다
-   **solved.ac 기준 플래티넘을 목표로**
-   **그렇다고 티어에 집착해선 안된다.**
-   **시간복잡도를 계산하라**
-   **예제 입력은 테스트 케이스의 일부이다.**
    -   **저희가 짠 코드의 반례를 직접 찾는겁니다.**

---

### 문제 1: [부등호](https://www.acmicpc.net/problem/2529)

**두괄식 요약** (오늘의 핵심 1-2문장): 세세한 코드를 자세히 신경쓰자

### 문제 1: [다음 순열](https://www.acmicpc.net/problem/10972)

**두괄식 요약** (오늘의 핵심 1-2문장): 좀 더 생각을 해보자 물론 답 안봤으면 몰랐듯 넥스트 펄뮤테이션

## 리엑트 공식문서 학습

### 렌더링 그리고 커밋

-   컴포넌트를 화면에 표시하기 전에 react에서는 렌더링을 해야함
-   렌더링 순서
    -   렌더링 트리거
        -   컴포넌트의 초기 렌더링인 경우
        -   컴포넌트의 state업데이트 된 경우 (리렌더링)
    -   컴포넌트 렌더링
        -   렌더링 트리거 후 리엑트는 컴포넌트를 호출하여 화면에 표시할 내용을 파악
        -   렌더링은 리엑트에서 컴포넌트를 호출하는 것
        -   초기 렌더링에서 리엑트는 루트 컴포넌트를 호출
        -   잏후 렌더링에서 리엑트는 스테이트 업데이트가 일어나 렌더링을 트리거한 컴포넌트를 호출
    -   돔에 커밋
        -   컴포넌트를 렌더링한 후 리엑트는 돔을 수정
        -   초기 렌더링의 경우 리엑트는 어팬드 차일드 톰 api를 사용하여 생성한 모든 돔 노드를 화면에 표시
        -   리렌더링의 경우 리엑트는 필요한 최소한의 작업(렌더링 하는 동안 계싼된 것을)적용하여 돔이 최시 렌더링과 출려과 일치하도록 함
        -   리엑트는 렌더링간에 차이가 있는 경우에만 돔 노드를 변경

### 스냅샷으로서의 state

-   prop, 이벤트 핸들러, 로컬 변수는 모두 렌더링 당시의 state를 사용해 계산됨
-   리엑트가 컴포넌트를 다시 렌더링할때
    -   리엑트가 함수를 다시 호출
    -   함수가 새로운 jsx 스냅샷을 반환
    -   그러면 리액트가 함수가 반환하 스냅샷과 일치하도록 화면을 업데이트
-   스냅샷을 찍기에 당시 state를 기준으로 한다.

```
setNumber(0 + 1);
setNumber(0 + 1);
setNumber(0 + 1);
```

-   이거해도 1임

#### 다음 렌더링 전에 동일한 state 변수를 여러번 업데이트 ㅎ라고싶다면

```
setNumber(n => n + 1);
setNumber(n => n + 1);
setNumber(n => n + 1);
```

-   n => n + 1은 업데이터 함수라고 부름

### 객체 state 업데이트하기

-   리엑트 스테이트가 가진 객체를 직접 변경하면 안됨
-   객체르 ㄹ업데이틓라고 싶을때는 새로운 객체르 ㄹ생성하여 또는 기존 객체의 복사본을 만들어 state가 복사본을 사용하도록 해라
-   immer로 간결간 갱신 로직 작성하기 => ㅇ구조를 안바꾸고 수정간으한 편한 방법

### 배열 state 업데이트하기

|      | 비선호 (배열을 변경)          | 선호 (새 배열을 반환)                                                                                                  |
| ---- | ----------------------------- | ---------------------------------------------------------------------------------------------------------------------- |
| 추가 | `push`, `unshift`             | `concat`, `[...arr]` 전개 연산자 ([예시](https://ko.react.dev/learn/updating-arrays-in-state#adding-to-an-array))      |
| 제거 | `pop`, `shift`, `splice`      | `filter`, `slice` ([예시](https://ko.react.dev/learn/updating-arrays-in-state#removing-from-an-array))                 |
| 교체 | `splice`, `arr[i] = ...` 할당 | `map` ([예시](https://ko.react.dev/learn/updating-arrays-in-state#replacing-items-in-an-array))                        |
| 정렬 | `reverse`, `sort`             | 배열을 복사한 이후 처리 ([예시](https://ko.react.dev/learn/updating-arrays-in-state#making-other-changes-to-an-array)) |

## 오픽

**참고 자료**:

-   [오픽 공부법] 7일 안에 IH 고득점 비법 및 서베이 선택 팁까지: https://community.linkareer.com/employment_data/4136986
-   오픽노잼 유튜브 IM 시리즈: https://youtu.be/Urq4VO63X24
-   오픽노잼 롤 플레이: https://youtu.be/87oKU4KJnXE
-   여우모의고사: https://youtu.be/-kapDJVUUD0

**오늘 공부한 내용**:

**구체적인 사실들**:

-   **[학습한 주제]**:
-   **[어려웠던 부분]**:
-   **[해결 방법]**:
-   **[연습한 표현]**:

**배운 점**:

**다음에 개선할 점**:

---

## CS 공부

### 매일 매일 서비스 주제 한개 공부

**두괄식 요약** (오늘의 핵심 1-2문장): promise의 리솔브는 프로마이스를 완료시키는 함ㅅ후이고 fulfiled는 완료된 상탤이다.

### 매일 매일 면접질문 한개씩

**질문**: http는 클라이언트 서버간 데이터를 주고받기 위한 통신 규칙 https는 http+tls로 http통신에 tls를 적용하여 데이터의 기밀성, 무결성, 그리고 서버 인증을 보장하는 프로토콜이다.

-   tls
    -   clientHello : tls 핸드세이크의 첫 번째 메시지, 브라우저가 서버에 자신의 보완능력을 전다
    -   serverghello : 서버가 어떤 보안 설정을 사용할지 선택하는 단계
    -   certifcate : 서버의 공개키를 전달하는 공식 문서, ca의 공식 서명이 포함됨
    -   cliewntkeyexcahnge : 세션 키 생성에 필요한 정보 전다. rsa 방식
    -   세션 키 생성(양쪽) : 동일한 세션키를 독립적으로 생성
    -   changeCipherSpec 메시지 : 이제부터 협의한 ㅂ세션키로 암호화해서 통신하겠다 선언
    -   종료 메세지 : 지금까지의 핸드셰이크가 정상적으로 완료되었는지 검증, 이 메세지부터는 암호화된 상태
    -   이후 http 데이터 통신 : 모든 요청 응답 세션키로 암호화 데이터 무결성 및 기밀성 보장
