# TIL | 2026.01.23 (금요일)

## 26년도 목표

-   인스타/유튜브 시간제한 : 불필요하게 접속해 타임 킬링하는 것을 줄인다. → 하루 30분 목표
-   계획한 데일리 루틴을 확립하여 점진적 성장을 이룬다. -> 주말은 평일에 수행하지 못한 것과 부족한 공부를 보충한다.
-   알고리즘 골드 달성
-   취뽀or 취뽀 전까지 싸피 합격해서 용돈 + 취업지원 받기
-   정처기 취득
-   오픽 취득
-   컴포넌트 패턴, 디자인 패턴, 객체 지향 코드 작성 방법 학습 및 터득
-   면접 대비 : 면접 질문에 답변할 수 있는 기본 실력 다지기, 모르는 키워드/질문에 대한 사고 확장을 위한 배경 지식 쌓기, 두괄식 설명 습관 기르기, 간결하고 핵심적인 답변 연습
-   매일매일 서비스에서 받은 면접질문들 상세 개념까지 이해하고 설명 가능하게 정리및 공부

## 일정

-   [ ] ~ 01.25일 일요일 : 리얼티쓰 과제 제출
-   [ ] ~ 01.31 : 근무 (실업급여 신청)
-   [ ] 03.23 : 정처기 실기 원서 접수
-   [ ] 04.18일 : 실기 시헝

## 월별 목표

-   1월 : 작성한 루틴 생활화, 첫 번째 회사에서 작업한 것 정리 및 포트폴리오화
-   2월 : 오픽 시험 보기
-   3월 : 백준 골드 달성하기 (새 계정으로)
-   4월 : 정처기 취득

## 학습 계획

> **참고**: 반복 루틴이 아닌, 하고 싶은 공부나 학습 주제를 기록합니다.

-   [ ] 개발 실력 키우기
-   [ ] Toss Frontend Fundamentals 모의고사 후기
-   [ ] Toss Frontend Fundamentals 공부 [url](https://github.com/toss-fe-interview/frontend-fundamentals-mock-exam-1)
-   [ ] SDD 학습하여 나만의 이력서/포트폴리오 디벨롭용 가이드 만들기
-   [ ] 윤성이가 설명한 프로젝트에 도커 도입 이유 및 관련 내용 자세히 정리하기
-   [ ] 리엑트 훅별 사용법 마스터 (상황별?)
-   [ ] 마스터 공유자료 학습

## 데일리 루틴

-   [x] 09:00 ~ 10:00 : 알고리즘
-   [x] 10:00 ~ 18:00 : 일
-   [ ] 18:10 ~ 19:30 : 운동
-   [x] 19:30 ~ 21:00 : 저녁 식사 및 휴식
-   [x] 21:00 ~ 21:30 : 지원
-   [x] 21:30 ~ 22:30 : 알고리즘
-   [x] 21:00 ~ 01:30 : 일
-   [X] 22:30 ~ 23:30 : 리얼티쓰 과제


# TIL - 오늘 배운 것

> **기록 방법 안내**: 막연한 표현이 아닌 **구체적인 사실**을 나열하고, 각 사실에 **이름(범주)**을 붙여 구조적으로 정리.

### **예시**

-   "오늘 스크롤 버그 고쳤다" ❌
-   → "특정 브라우저(IE11)에서만 position: sticky가 작동하지 않았다" **[문제 정의]**
-   → "개발자 도구로 디버깅해보니 상위 DOM의 transform 속성과 충돌했다" **[기술적 원인]**
-   → "애니메이션 때문에 transform을 제거할 수는 없었다" **[제약 조건]**
-   → "DOM 구조를 변경하여 해결했다" **[최종 해결책]**

## 알고리즘

**풀이 과정(사고)**:

-   **30분간 문제의 접근법**을 고민해본다.
-   30분이 지났을 때 **접근법이 떠오르지 않았다면, 인터넷에 검색하여 풀이**를 찾아본다.
-   접근법이 떠올랐다면 **30분 동안 구현하고 풀어본다**.
-   30분이 지났을 때 **풀지 못했다면 인터넷에 검색하여 풀이**를 찾아본다.
-   다른사람의 코드를 본다
-   **solved.ac 기준 플래티넘을 목표로**
-   **그렇다고 티어에 집착해선 안된다.**
-   **시간복잡도를 계산하라**
-   **예제 입력은 테스트 케이스의 일부이다.**
    -   **저희가 짠 코드의 반례를 직접 찾는겁니다.**

---

### 문제 1: [카드 구매하기](https://www.acmicpc.net/problem/11052)

#### Math.max vs 비교 연산자 — 반복문에서의 성능 차이를 직접 확인해보다

평소에는 값 비교가 필요할 때 별다른 고민 없이 `Math.max`를 사용해왔다.
코드가 간결하고 의도가 분명해 보이기 때문에 자연스러운 선택이라고 생각했다.

그러던 중 알고리즘 문제를 풀면서 이런 생각이 들었다.

> “수십만 ~ 수백만 번 반복되는 루프 안에서도
> 이 방식이 정말 최선일까?”

단순히 **최댓값을 갱신하는 연산**인데,
조금이라도 더 비용이 적은 방법이 있을지 궁금해졌다.
그래서 **`Math.max`를 사용하는 방식**과
**비교 연산자(`>`)를 직접 사용해 값을 갱신하는 방식**의 실행 시간을 직접 비교해봤다.

---

###### 실험 환경

* Node.js v25.2.1 (V8 엔진)
* 동일한 입력 데이터
* 동일한 알고리즘 및 반복 횟수
* 차이점은 **최댓값 갱신 방식뿐**

---

##### 비교 대상 코드

###### 1️⃣ `Math.max`를 사용하는 방식

```js
console.time('Math.max');

for (let i = 1; i <= N; i++) {
    for (let j = 1; j <= i; j++) {
        dp[i] = Math.max(dp[i], dp[i - j] + cost_list[j]);
    }
}

console.timeEnd('Math.max');
```

#### 2️⃣ 비교 연산자(`>`)를 직접 사용하는 방식

```js
console.time('comparison');

for (let i = 1; i <= N; i++) {
    for (let j = 1; j <= i; j++) {
        const candidate = dp[i - j] + cost_list[j];
        if (candidate > dp[i]) dp[i] = candidate;
    }
}

console.timeEnd('comparison');
```

> 여기서 `if` 문은 **비교 연산자를 사용하기 위한 문법적 구조일 뿐**이며,
> 성능 차이의 본질은 **`if` 자체가 아니라 `Math.max`라는 함수 호출 여부**에 있다.

---

#### 실행 결과

```bash
Math.max: 25.699ms
Math.max: 8.598ms
```

```bash
comparison: 3.852ms
comparison: 3.609ms
```

같은 로직임에도 불구하고,
비교 연산자를 직접 사용한 방식이 **일관되게 더 빠른 실행 시간**을 보였다.
실행 환경에 따라 편차는 있었지만, 전체적으로 **2배 이상 차이**가 발생했다.

---

#### 왜 이런 차이가 발생할까?

##### 1️⃣ `Math.max`는 함수 호출이다

```js
Math.max(a, b)
```

겉보기에는 단순한 비교처럼 보이지만, 실제로는 다음과 같은 과정을 거친다.

* 함수 호출
* 인자 전달
* 내부 타입 처리
* 반환값 처리

이 과정은 단 한 번이라면 문제가 되지 않지만,
**중첩 반복문 안에서 수십만 번 이상 호출되면 비용이 누적**된다.

---

##### 2️⃣ 비교 연산자(`>`)는 가장 단순한 연산이다

```js
candidate > dp[i]
```

* CPU 레벨에서 바로 처리되는 단순 비교
* 함수 호출 없음
* V8 JIT 컴파일러가 인라인 최적화하기 매우 유리

즉, 불필요한 추상화 없이 **가장 직접적인 방식으로 동작**한다.

---

##### 3️⃣ 반복 횟수가 많을수록 차이는 커진다

단일 비교에서는 체감하기 어렵지만,
알고리즘 문제처럼 **중첩 반복문 + 대량 연산** 환경에서는
이 작은 차이가 전체 실행 시간에 명확한 영향을 준다.

---

#### 그렇다면 `Math.max`는 쓰면 안 될까?

전혀 아니다.

* 가독성이 중요한 일반 로직
* 반복 횟수가 적은 코드
* 비즈니스 로직이나 UI 코드

이런 경우에는 `Math.max`가 오히려 더 명확하고 적절하다.

```js
const maxValue = Math.max(a, b, c);
```

문제는 **성능이 중요한 반복문 내부**에서의 사용이다.

---

#### 결론

알고리즘 문제에서 최댓값을 갱신해야 할 때는
`Math.max` 함수 호출보다 **비교 연산자(`>`)를 직접 사용하는 방식**이 더 효율적이다.

* 성능 차이의 핵심은 **`if` vs `Math.max`가 아니다**
* **함수 호출 vs 단순 비교 연산자**의 비용 차이다
* 반복 횟수가 많을수록 그 차이는 분명해진다

평소 습관처럼 사용하던 코드라도,
상황에 따라 한 번쯤은 “이 연산의 비용은 얼마일까?”를 고민해보는 게
성능 감각을 기르는 데 도움이 된다는 걸 느꼈다.

