# TIL | 2026.01.02 (금요일)

## 26년도 목표

-   인스타/유튜브 시간제한 : 불필요하게 접속해 타임 킬링하는 것을 줄인다. → 하루 30분 목표
-   계획한 데일리 루틴을 확립하여 점진적 성장을 이룬다. -> 주말은 평일에 수행하지 못한 것과 부족한 공부를 보충한다.
-   알고리즘 골드 달성
-   취뽀or 취뽀 전까지 싸피 합격해서 용돈 + 취업지원 받기
-   정처기 취득
-   오픽 취득
-   디자인패턴, 객체 지향코드
-   면접 대비 : 면접 질문에 답변할 수 있는 기본 실력 다지기, 모르는 키워드/질문에 대한 사고 확장을 위한 배경 지식 쌓기, 두괄식 설명 습관 기르기, 간결하고 핵심적인 답변 연습

## 일정

-   [x] 01.02 ~ 01.03 : 해돋이

## 월별 목표

-   1월 : 작성한 루틴 생활화, 첫 번째 회사에서 작업한 것 정리 및 포트폴리오화
-   2월 : 오픽 시험 보기
-   3월 : 백준 골드 달성하기 (새 계정으로)
-   4월 : 정처기 취득

## 데일리 루틴

-   [x] 알고리즘
-   [x] 책 읽고 정리 (하루에 한 챕터씩)
    -   [x] [패턴으로 익히고 설계로 완성하는 리액트 - 챕터1](../books/패턴으로%20익히고%20설계로%20완성하는%20리액트/챕터10.md)
-   [x] CS 공부
    -   [x] 매일 매일 서비스 주제 한개 공부
    -   [x] 매일 매일 면접질문 한개씩 우선 노션 정리

---

# TIL - 오늘 배운 것

> **기록 방법 안내**: 막연한 표현이 아닌 **구체적인 사실**을 나열하고, 각 사실에 **이름(범주)**을 붙여 구조적으로 정리.

### **예시**

-   "오늘 스크롤 버그 고쳤다" ❌
-   → "특정 브라우저(IE11)에서만 position: sticky가 작동하지 않았다" **[문제 정의]**
-   → "개발자 도구로 디버깅해보니 상위 DOM의 transform 속성과 충돌했다" **[기술적 원인]**
-   → "애니메이션 때문에 transform을 제거할 수는 없었다" **[제약 조건]**
-   → "DOM 구조를 변경하여 해결했다" **[최종 해결책]**

---

## 알고리즘

**풀이 과정(사고)**:

-   **30분간 문제의 접근법**을 고민해본다.
-   30분이 지났을 때 **접근법이 떠오르지 않았다면, 인터넷에 검색하여 풀이**를 찾아본다.
-   접근법이 떠올랐다면 **30분 동안 구현하고 풀어본다**.
-   30분이 지났을 때 **풀지 못했다면 인터넷에 검색하여 풀이**를 찾아본다.
-   다른사람의 코드를 본다
-   **solved.ac 기준 플래티넘을 목표로**
-   **그렇다고 티어에 집착해선 안된다.**
-   **시간복잡도를 계산하라**
-   **예제 입력은 테스트 케이스의 일부이다.**
    -   **저희가 짠 코드의 반례를 직접 찾는겁니다.**

---

### 문제 1: [1](https://www.acmicpc.net/problem/4375)

**두괄식 요약** (오늘의 핵심 1-2문장): 몫의 크기는 ‘나눠떨어짐 여부’와 아무 관계가 없다. 모듈러 연산의 성질을 활용하면 큰 수를 다루지 않고도 나머지만으로 계산할 수 있다.

-   **문제명**: 1 (백준 4375번)
-   **알고리즘 분류**: 수학, 브루트포스 알고리즘, 정수론

-   **[문제 정의]**:

    -   2와 5로 나누어 떨어지지 않는 정수 n(1 ≤ n ≤ 10000)가 주어졌을 때, 각 자릿수가 모두 1로만 이루어진 n의 배수를 찾는 프로그램을 작성하시오.
    -   각 자릿수가 모두 1로만 이루어진 n의 배수 중 가장 작은 수의 자리수를 출력

-   **[제약 조건]**:
    -   n의 범위: 1 ≤ n ≤ 10000
    -   시간 제한: 1초
    -   n이 최대 10000이므로 O(n²) 알고리즘은 시간 초과 위험이 있음
-   **[초기 접근 방법]**:
    -   while문 안에서 문자열을 숫자로 변환하고, 다시 문자열로 변환하여 자릿수가 모두 1인지 확인하려고 시도
    -   예: "1" → "11" → "111" → ... 형태로 문자열을 이어붙이며 n의 배수인지 확인
-   **[기술적 원인 / 문제점]**:
    -   문자열 변환(String 변환)은 O(문자열 길이) 시간이 소요됨
    -   자릿수가 증가할수록 문자열 길이도 증가하므로, 전체 시간 복잡도가 O(n²)이 되어 시간 초과 발생
    -   큰 수를 직접 다루면 오버플로우 위험도 있음
-   **[해결책]**:

    -   **1단계**: 문자열 변환을 제거하고 수치 계산으로 변경 → O(1) 연산으로 개선했으나 여전히 시간 초과
    -   **2단계**: 모듈러 연산의 성질 활용
        -   `target = target * 10 + 1`로 값을 업데이트하면 계속 값이 커짐
        -   **핵심 인사이트**: 나눠떨어지는지 확인하는 데는 몫이 필요 없고, 나머지만 있으면 됨
        -   `target = (target * 10 + 1) % n`로 나머지만 업데이트
        -   이렇게 하면 값이 n보다 작게 유지되어 오버플로우 방지 및 계산 속도 향상

-   **[핵심 개념 - 모듈러 연산]**:
    -   `(a * 10 + 1) % n = ((a % n) * 10 + 1) % n`
    -   나머지만으로도 나눠떨어짐 여부를 판단할 수 있음
    -   몫의 크기와 나눠떨어짐 여부는 무관함

**복잡도 분석**:

-   **시간복잡도**: O(n)
    -   `target = (target * 10 + 1) % n`로 나머지만 업데이트
    -   나머지는 0부터 n-1 사이의 값만 가질 수 있음
    -   최악의 경우: 나머지가 0부터 n-1까지 모두 순회 → n번 반복
    -   평균적으로는 더 작지만, Big-O 표기법은 최악의 경우를 나타냄
-   **공간복잡도**: O(1) - 상수 공간만 사용 (target 변수 하나만 필요)

**풀이 시간**: 15분

**다른 사람 코드에서 배운 점**:

-   모듈러 연산의 성질을 활용한 최적화 방법
-   큰 수를 다루지 않고도 나머지만으로 계산하는 패턴

### 문제 2: 약수의 합 1,2

-   시간복잡도를 신경을 많이 써야겠다는 생각을함, 최적화, 점화식 구하기 등 컨디션도 중요함 피곤하니 아무 생각이 안듬

## 책 읽기

> **참고**: 상세한 책 내용 정리는 챕터 파일에서 하고, 여기에는 **적용하거나 느낀 것들**을 중심으로 작성하세요.

**두괄식 요약** (오늘의 핵심 1-2문장): 합성 패턴과 헤드리스 컴포넌트 패턴을 통해 컴포넌트의 재사용성과 유지보수성을 높이는 방법을 배웠다. 모든 곳에 적용하기보다 필요한 부분에 올바른 패턴을 적용하는 것이 중요하다.

-   **책명**: 패턴으로 익히고 설계로 완성하는 리액트

    **챕터**: 챕터 1

    **챕터 파일**: [챕터1.md](../books/패턴으로%20익히고%20설계로%20완성하는%20리액트/챕터1.md)

    **오늘 읽은 내용 요약** (한 문단으로 간단히): 합성 패턴과 헤드리스 컴포넌트 패턴에 대해 배웠다. 합성 패턴은 작은 컴포넌트를 조합하여 재사용성과 가독성을 높이는 방법이고, 헤드리스 컴포넌트는 로직과 UI를 분리하여 같은 로직을 다양한 UI로 활용할 수 있게 해주는 패턴이다.

    **구체적인 사실들**:

-   **[내가 겪었던 유사한 경험]**:
-   **[이전에 몰랐던 점 / 새로 알게 된 점]**:
    -   헤드리스 컴포넌트와 합성 컴포넌트를 이번 기회에 더 잘 알게 되었다
    -   헤드리스 컴포넌트는 로직(상태 관리, 이벤트 처리)만 제공하고 UI 렌더링은 사용자가 결정한다
    -   합성 패턴은 하나의 거대한 컴포넌트에 여러 기능을 만들지 않고, 작고 다루기 편한 조각으로 분리하여 다양한 방법으로 조합할 수 있다
-   **[이해가 안 되었던 부분 / 질문]**:
-   **[실무에서 바로 적용 가능한 부분]**:
    -   대부분의 경우에 적용 가능할 것 같다
    -   드롭다운, 모달, 탭 등 재사용 가능한 UI 컴포넌트에 헤드리스 패턴 적용
    -   복잡한 컴포넌트를 작은 단위로 분리하여 합성 패턴 적용
-   **[트레이드오프 / 고민한 점]**:
    -   모든 곳에 적용하는 것보다 진짜 필요한 부분에 어떻게 적용할지를 고민해야 한다
    -   초기 구현 시간이 더 걸릴 수 있지만, 장기적으로 유지보수와 테스트가 용이하다

**프로젝트에 적용할 점**:

-   적용할 부분: 현재 프로젝트의 재사용 가능한 컴포넌트들 (드롭다운, 모달 등)
-   적용 방법:
    -   헤드리스 컴포넌트 패턴으로 로직과 UI 분리
    -   합성 패턴으로 작은 컴포넌트들을 조합하여 사용
-   예상 효과:
    -   코드 재사용성 향상
    -   유지보수 용이
    -   테스트 작성 용이

**느낀 점 / 회고**:

모든 것에 적용하는 것보다 진짜 필요한 부분에 어떻게 적용할지를 고민하고 적용해보며 필요한 부분에 올바른 패턴을 적용하는 연습이 필요하고 중요하다고 생각했다. 헤드리스 컴포넌트와 합성 패턴의 개념은 이해했지만, 실제 프로젝트에 적용할 때 어떤 상황에서 어떤 패턴을 선택해야 할지 더 연습이 필요하다.

**다음에 더 공부할 내용**:

-   헤드리스 컴포넌트 라이브러리 (Radix UI, Headless UI) 실제 사용 사례
-   합성 패턴의 다양한 활용 방법
-   언제 어떤 패턴을 선택해야 하는지에 대한 판단 기준
