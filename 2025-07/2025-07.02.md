# TIL | 2025.07.02

## 주간 목표

-   계획한 미라클 모닝 자리잡기
-   루틴 확립하기
    -   충분한 수면을 가져가려고 노력하기 (TIL 공유를 조금 늦은 시간에 진행하고 2시에 취침하고 7시에 기상해서 운동까지 해버리니 너무 피곤함)
    -   책은 내용을 암기하는게 아니다 가볍게 흘러가듯이 읽자
-   [벨로그](https://velog.io/@pigpgw/%EB%82%98%EC%9D%98-%EA%B0%9C%EB%B0%9C-%EC%84%B1%EC%9E%A5-%EC%A0%84%EB%9E%B5-%EC%83%9D%EA%B0%80%ED%95%98%EB%8A%94-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A1%9C-%EB%82%98%EC%95%84%EA%B0%80%EA%B8%B0)에 작성한 것들 습관화하기

### 중요 일정

-   2025.07.06 일요일(순천 -> 오송) : 12시 30분 ktx(명준)
-   2025.07.07 월요일 : 워크샵
-   2025.07.08 화요일 : 워크샵
-   2025.07.09 수요일 : 워크샵
-   2025.07.19 토요일 오전 9시 : 정처기 시험
-   2025.07.19 토요일 : 저녁 동현 약속

## 오늘 진행 순서 예정

-   [x] 오픽 준비
    -   [x] 오픽노잼
        -   [x] ch 4 - 2
    -   스픽
        -   [x] 단어
        -   [x] 말하기
-   [x] 매일 매일 면접 질문 (이벤트 버블링과 캡처링에 대해 설명해주세요.)
-   [x] 알고리즘
-   [x] 정처기 스터디 (8시 30분)
-   [x] 일
    -   [x] 파이썬 문법 학습
    -   [x] pyqt 를 위한 파이썬 문법
    -   [x] pyqt 공부 중
-   [x] 흥달쌤 이론 특강
-   [x] 운동

---

# TIL

## 매일 매일 면접 질문 (이벤트 버블링과 캡처링에 대해 설명해주세요.)

-   이벤트 버블링은 이벤트가 발생했을 때 가장 안쪽의 타겟 요소에서 시작하여 부모 요소로 전파되는 방식입니다. 예를 들어, 버튼을 클릭했을 때 버튼 자체에서 이벤트가 발생한 후 이 이벤트가 상위 요소인 div, body, document, window로 전파되는 과정을 거치게 됩니다. 기본적으로 브라우저는 이벤트 전파를 버블링 단계에서 처리하도록 설계되어 있습니다.
-   반면, 이벤트 캡처링은 이와 반대 방향으로 진행됩니다. 즉, 이벤트가 최상위 부모 요소에서부터 시작해 점점 타겟 요소로 내려오면서 전파됩니다. 예를 들어, window에서 이벤트가 시작되어 document, body, div를 거쳐 버튼에 도달하게 되는 방식입니다. 기본적으로 캡처링 단계는 비활성화되어 있지만, addEventListener 함수의 세 번째 옵션으로 캡처링을 활성화할 수 있습니다. 이 옵션에 true를 설정하면 캡처링 단계에서 이벤트를 처리할 수 있습니다.
-   버블링과 캡처링은 각각의 특성 덕분에 서로 다른 상황에서 유용하게 활용됩니다. 버블링은 특히 이벤트 위임 같은 패턴에서 활용도가 높습니다. 예를 들어, 동적으로 추가되는 자식 요소가 있는 상황에서는 부모 요소에 이벤트 리스너를 등록하여 자식 요소들의 이벤트를 효율적으로 관리할 수 있습니다. 이렇게 하면 각각의 자식 요소마다 이벤트 리스너를 따로 등록할 필요가 없으므로 성능적인 이점이 생깁니다. 예를 들어, 리스트 항목(li)의 클릭 이벤트를 처리할 때 부모 요소인 ul에 리스너를 하나만 등록하여 모든 li의 클릭 이벤트를 처리할 수 있습니다.
-   한편, 캡처링은 부모 요소에서 자식 요소보다 먼저 이벤트를 처리해야 할 때 유용합니다. 예를 들어, 페이지의 전체적인 트래킹이나 로깅 기능을 구현할 때 캡처링 단계에서 이벤트를 처리하면 자식 요소에서의 추가 이벤트 처리 여부와 관계없이 부모에서 로직을 먼저 실행할 수 있습니다.

### 이런 이벤트 버블링과 캡처링 과정에서 발생할 수 있는 문제는 없을까요? 🤔

-   이벤트 버블링과 캡처링 과정에서 발생할 수 있는 문제는, 이벤트 중첩으로 인해 동일 이벤트가 중복 처리되는 상황, 캡처링 단계에서 불필요한 이벤트가 처리되는 성능 문제, 이벤트 위임 시 타겟 오작동 등 다양한 사례가 있습니다.
-   하지만 이러한 문제들을 제어하기 위해 두 가지 주요 메서드를 사용할 수 있습니다.
    -   첫째, stopPropagation 메서드를 호출하면 특정 이벤트가 현재 단계에서 멈추고 더 이상 부모나 자식으로 전파되지 않도록 할 수 있습니다. 이는 복잡한 UI 구조에서 불필요한 이벤트 처리를 방지할 때 유용합니다.
    -   둘째, preventDefault 메서드를 사용하면 링크 클릭 시 페이지 이동이나 폼 제출과 같은 브라우저의 기본 동작을 방지할 수 있습니다.

## 알고리즘

### 코테 적용 방법

-   Step1 문제 이해하기
    -   문제를 제대로 읽기
    -   제약조건 읽기
        -   효율성 테스트 10^8 넘으면 안됨
        -   원소 값의 범위
            -   int === 4byte => 1bit는 부호 31bit는 수 표현 -2^31 ~ 2^31 + 1
                -   2의 31승은 10의 9승 그러면 인트형 변수에 저장 불가
-   Step2 접근 방법
    -   직관적으로 생각하기
        -   보통 완전 탐색으로 시작
        -   문제 상황을 단순화 하여 생각하기
        -   문제 상황을 극한화 하여 생각하기
    -   자료구조와 알고리즘 활용
        -   Step1 문제이해 에서 파악한 내용을 토대로 어떤 자료구조를 사용하는게 가장 적합한지 결정
        -   대놓고 특정 자료구조와 알고리즘을 묻는 문제도 많음
        -   자료구조에 따라 선택할 수 있는 알고리즘을 문제에 적용
    -   메모리 사용
        -   시간복잡도를 줄이기 위해 메모리를 사용하는 방법
        -   대표적으로 해시테이블

### 대표 알고리즘

-   O(1): Operation push and pop on Stack
-   O(log n): Binary Tree
-   O(n): for loop
-   O(n×log n): Quick Sort, Merge Sort, Heap Sort
-   O(n2): Double for loop, Insert Sort, Bubble Sort, Selection Sort
-   O(2n): Fibonacci Sequence

## 강의 수강

### 공부할거

-   리엑트 컴포넌트 렌더링 개발도구 통해서 성능 측정방법
-   JS 엔진 구조 (V8, SpiderMonkey)
-   인터프리터 vs 컴파일러
-   JIT 컴파일러 (Just-In-Time-Compiler)
-   이벤트 루프, Call Stack, Task Queue
-   공통 컴포넌트 설계
-   rest
-   기본 타입 확장
-   공통 버튼 컴포넌트 만드는데 어떻게 해야할지 모르겠음,
-   리엑트에서의 단일 책임 원칙
-   리엑트 쿼리 사람답게 쓰기
-   suspense
-   에러 바운더리
