# TIL | 2025.07.02

## 주간 목표

-   계획한 미라클 모닝 자리잡기
-   루틴 확립하기
    -   충분한 수면을 가져가려고 노력하기 (TIL 공유를 조금 늦은 시간에 진행하고 2시에 취침하고 7시에 기상해서 운동까지 해버리니 너무 피곤함)
    -   책은 내용을 암기하는게 아니다 가볍게 흘러가듯이 읽자
-   [벨로그](https://velog.io/@pigpgw/%EB%82%98%EC%9D%98-%EA%B0%9C%EB%B0%9C-%EC%84%B1%EC%9E%A5-%EC%A0%84%EB%9E%B5-%EC%83%9D%EA%B0%80%ED%95%98%EB%8A%94-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A1%9C-%EB%82%98%EC%95%84%EA%B0%80%EA%B8%B0)에 작성한 것들 습관화하기

### 중요 일정

-   [x] 첫 출근 오전 10시 데일리 스크럼 허들
-   2025.07.06 일요일(순천 -> 오송) : 12시 30분 ktx(명준)
-   2025.07.07 월요일 : 워크샵
-   2025.07.08 화요일 : 워크샵
-   2025.07.09 수요일 : 워크샵
-   2025.07.19 토요일 오전 9시 : 정처기 시험
-   2025.07.19 토요일 : 저녁 동현 술 약속

## 오늘 진행 순서 예정

-   [x] 오픽 준비
    -   오픽노잼 : 불가능! 하지만 오픽 habit 질문의 대답들이 입에서 슉슉 나오게 만들어줄게요!
        -   [x] ch 4 - 1
    -   스픽
        -   [x] 단어
        -   [x] 말하기
-   [x] 매일 매일 면접 질문 : webpack, rollup과 같은 번들러는 왜 필요한지 설명해주세요.
-   [x] 일
    -   [x] : 파이썬 환경세팅 관련 공부 및 정리
    -   [x] : 파이썬 환경세팅
    -   [x] : 화이트 페이퍼 및 유의할점 및 근무 방식등등 정리
-   [x] 운동
-   [x] 정처기 (23년 2회,1회 풀고 오답)
-   [x] 알고리즘 [색종이 만들기](https://www.acmicpc.net/problem/2630)
-   [x] 새 프로젝트
    -   [x] 프로젝트 이슈 생성

# TIL

## 매일 매일 면접 질문 : webpack, rollup과 같은 번들러는 왜 필요한지 설명해주세요.

-   번들러는 다양한 파일과 모듈을 하나의 배포 가능한 번들로 묶는 역할을 합니다. 번들러가 필요한 주요 이유는 다음과 같습니다.
-   첫째, 네트워크 요청 성능을 개선하기 위해서입니다. 다수의 개별 파일에 대해 모두 네트워크 요청을 수행할 경우, 성능에 부정적인 영향이 있을 수 있습니다. 번들러는 다수의 파일을 하나 또는 소수의 파일로 묶어 네트워크 요청을 최적화합니다. 예를 들어, 애플리케이션이 수백 개의 JavaScript, CSS, 이미지 파일을 사용한다면, HTTP 요청 수가 증가해 로딩 속도가 느려질 수 있습니다. 이때 번들러는 이들을 효율적으로 묶어 소수의 파일로 만듦으로써 네트워크 요청 수를 줄여줍니다.
-   둘째, 번들러는 트랜스파일링을 통해 더 효율적이고 호환성 있는 애플리케이션을 만드는데 기여합니다. 먼저, 트랜스파일링을 통해 코드를 최적화합니다. 예를 들어, Dead Code Elimination과 Tree Shaking과 같은 방법을 통해 사용되지 않는 코드와 불필요한 모듈을 제거해 번들 크기를 줄이고 로딩 성능을 개선합니다.
    또한, 번들러는 호환성을 높이기 위해 최신 JavaScript 문법과 기능을 구형 브라우저에서도 실행 가능하도록 변환합니다. 예를 들어, ES6 이상의 모듈, 비동기 함수, 옵셔널 체이닝 같은 최신 기능은 지원하지 않는 브라우저에서 문제가 될 수 있는데, 번들러는 이를 ES5로 변환하여 호환성을 보장합니다. 이때 Babel 같은 트랜스파일러와 연계하여 처리하기도 합니다.

## 알고리즘

### 코테 적용 방법

-   Step1 문제 이해하기
    -   문제를 제대로 읽기
    -   제약조건 읽기
        -   효율성 테스트 10^8 넘으면 안됨
        -   원소 값의 범위
            -   int === 4byte => 1bit는 부호 31bit는 수 표현 -2^31 ~ 2^31 + 1
                -   2의 31승은 10의 9승 그러면 인트형 변수에 저장 불가
-   Step2 접근 방법
    -   직관적으로 생각하기
        -   보통 완전 탐색으로 시작
        -   문제 상황을 단순화 하여 생각하기
        -   문제 상황을 극한화 하여 생각하기
    -   자료구조와 알고리즘 활용
        -   Step1 문제이해 에서 파악한 내용을 토대로 어떤 자료구조를 사용하는게 가장 적합한지 결정
        -   대놓고 특정 자료구조와 알고리즘을 묻는 문제도 많음
        -   자료구조에 따라 선택할 수 있는 알고리즘을 문제에 적용
    -   메모리 사용
        -   시간복잡도를 줄이기 위해 메모리를 사용하는 방법
        -   대표적으로 해시테이블

### 대표 알고리즘

-   O(1): Operation push and pop on Stack
-   O(log n): Binary Tree
-   O(n): for loop
-   O(n×log n): Quick Sort, Merge Sort, Heap Sort
-   O(n2): Double for loop, Insert Sort, Bubble Sort, Selection Sort
-   O(2n): Fibonacci Sequence

### [색종이 만들기](https://www.acmicpc.net/problem/2630)

-   정사각형 칸들로 이루어진 정사각형 모양의 종이가 있음
-   일정한 규칙에 따라 잘라서 다양한 크기를 가진 정사각형 모양의 하얀색 또는 파란색 색종이를 만들려고함
-   종이를 자르는 규칙
    -   전체 종이가 모두 같은 색으로 칠해져 있지 않으면 가로와 세로 중간을 자른다.
    -   종이가 모두 하얀색또는 모두 파란색 될때까지 반복
    -   하얀색 파란색 개수 구하기
-   풀기
    -   전체 종이가 같은 색인지 확인한다
    -   맞다면 개수를 센다
    -   아니면 네 개의 N/2 X N/2 색종이로 나눈다.

```python
total_blue_area = 0
total_white_area = 0
def recursion(currY,currX,N):
    if N == 1:
        if board[i][j] == 1:
        else:
        return
    blue_area = 0
    white_area = 0
    for i in range(N):
        for j in range(N):
            if board[i][j] == 1:
                blue_area += 1
            else:
                white_area += 1
            if blue_area != 0 and white_area != 0:
                divide_area = N / 2
                recursion(i,j,divide_area)
                recursion(i + divide_area,j,divide_area)
                recursion(i,j + divide_area,divide_area
                recursion(i + divide_area,j + divide_area,divide_area)
    total_blue_area += blue_area
    total_white_area += white_area
```

## 강의 수강

### 공부할거

-   리엑트 컴포넌트 렌더링 개발도구 통해서 성능 측정방법
-   JS 엔진 구조 (V8, SpiderMonkey)
-   인터프리터 vs 컴파일러
-   JIT 컴파일러 (Just-In-Time-Compiler)
-   이벤트 루프, Call Stack, Task Queue
-   공통 컴포넌트 설계
-   rest
-   기본 타입 확장
-   공통 버튼 컴포넌트 만드는데 어떻게 해야할지 모르겠음,
-   리엑트에서의 단일 책임 원칙
-   리엑트 쿼리 사람답게 쓰기
-   suspense
-   에러 바운더리
