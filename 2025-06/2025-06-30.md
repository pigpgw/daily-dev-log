# TIL | 2025.07.01

## 주간 목표

-   계획한 미라클 모닝 자리잡기
-   루틴 확립하기
    -   충분한 수면을 가져가려고 노력하기 (TIL 공유를 조금 늦은 시간에 진행하고 2시에 취침하고 7시에 기상해서 운동까지 해버리니 너무 피곤함)
    -   책은 내용을 암기하는게 아니다 가볍게 흘러가듯이 읽자
-   [벨로그](https://velog.io/@pigpgw/%EB%82%98%EC%9D%98-%EA%B0%9C%EB%B0%9C-%EC%84%B1%EC%9E%A5-%EC%A0%84%EB%9E%B5-%EC%83%9D%EA%B0%80%ED%95%98%EB%8A%94-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A1%9C-%EB%82%98%EC%95%84%EA%B0%80%EA%B8%B0)에 작성한 것들 습관화하기

### 중요 일정

-   [x] 2025.06.30 월요일 오후 5:00시 : 근로계약서 및 연봉계약서 날인(온라인 구글 밋)
-   2025.07.01 화요일 : 출근
-   2025.07.19 정처기 시험
-   2025.07.19 저녁 동현 약속

## 오늘 진행 순서 예정

-   [ㅌ] 아침 운동 : 가슴
-   [x] 오픽 준비
    -   오픽노잼
        -   [x] ch 3 - 6
    -   스픽
        -   [x] 단어
        -   [x] 말하기
-   [x] 매일 매일 면접 질문 (Tanstack Query를 사용하는 이유를 설명해 주세요.)
-   [x] 새 프로젝트

    -   작업할 것
        -   1차 MVP UI 구현
            -   [x] 현재 내 스택 관련 아이콘 컴포넌트화

-   [x] 수제비 정처기 1회 풀기

---

# TIL

## 매일 매일 면접 질문 (Tanstack Query를 사용하는 이유를 설명해 주세요.)

-   TanStack Query는 서버 상태 관리의 복잡성을 극복하기 위해 사용하는 라이브러리입니다. 여기서 서버 상태란 서버에서 제공하는 데이터로, 클라이언트에서 직접 수정할 수 없고 네트워크 요청과 같은 비동기 작업을 통해 가져오거나 갱신해야 하는 데이터를 의미합니다.

### 사용 주요 이유

-   첫째, 효율적인 캐싱 처리 기능을 제공합니다. 이를 통해 동일한 데이터를 반복적으로 요청하지 않아 네트워크 비용을 절감하고, 캐싱된 데이터를 즉시 제공해 더 나은 사용자 경험을 제공할 수 있습니다.
-   둘째, 비동기 데이터 관리의 복잡성을 줄여줍니다. TanStack Query는 데이터의 가져오기(fetch), 갱신(refetch), 무효화(invalidate) 등의 작업을 선언적으로 처리할 수 있어 코드가 간결해지고 유지보수가 용이해집니다.
-   셋째, 에러 및 로딩 상태 관리를 단순화합니다. useQuery()와 useMutation() 훅을 사용하면 서버 데이터와 관련된 로딩, 성공, 실패 상태를 명확하고 직관적으로 처리할 수 있어 로직이 깔끔해집니다.

### TanStack Query를 사용할 때 발생할 수 있는 단점이나 한계는 무엇인가요? 🤔

-   첫째, 캐싱 전략 관리의 복잡성입니다. TanStack Query는 강력한 캐싱 기능을 제공하지만, staleTime, gcTime 같은 옵션을 잘못 설정하면, 데이터 갱신 타이밍이 적절하지 않아 최신 데이터가 사용자에게 노출되지 않거나 불필요한 요청이 발생할 수 있습니다.
-   둘째, 초기 학습 곡선이 존재합니다. Query Key 설계, 데이터 무효화 등 다양한 개념을 이해하고 적절히 활용해야 하므로 초기에 학습해야 하는 지식의 양이 많습니다.
-   마지막으로, 클라이언트 상태와 서버 상태 간 의존 관계가 복잡한 경우, TanStack Query만으로는 해결하기 어려울 수 있습니다. 이때는 Redux, Zustand 등 별도의 상태 관리 라이브러리가 필요할 수 있습니다.

## 알고리즘

### 코테 적용 방법

-   Step1 문제 이해하기
    -   문제를 제대로 읽기
    -   제약조건 읽기
        -   효율성 테스트 10^8 넘으면 안됨
        -   원소 값의 범위
            -   int === 4byte => 1bit는 부호 31bit는 수 표현 -2^31 ~ 2^31 + 1
                -   2의 31승은 10의 9승 그러면 인트형 변수에 저장 불가
-   Step2 접근 방법
    -   직관적으로 생각하기
        -   보통 완전 탐색으로 시작
        -   문제 상황을 단순화 하여 생각하기
        -   문제 상황을 극한화 하여 생각하기
    -   자료구조와 알고리즘 활용
        -   Step1 문제이해 에서 파악한 내용을 토대로 어떤 자료구조를 사용하는게 가장 적합한지 결정
        -   대놓고 특정 자료구조와 알고리즘을 묻는 문제도 많음
        -   자료구조에 따라 선택할 수 있는 알고리즘을 문제에 적용
    -   메모리 사용
        -   시간복잡도를 줄이기 위해 메모리를 사용하는 방법
        -   대표적으로 해시테이블

### 대표 알고리즘

-   O(1): Operation push and pop on Stack
-   O(log n): Binary Tree
-   O(n): for loop
-   O(n×log n): Quick Sort, Merge Sort, Heap Sort
-   O(n2): Double for loop, Insert Sort, Bubble Sort, Selection Sort
-   O(2n): Fibonacci Sequence

## 강의 수강

### 공부할거

-   리엑트 컴포넌트 렌더링 개발도구 통해서 성능 측정방법
-   JS 엔진 구조 (V8, SpiderMonkey)
-   인터프리터 vs 컴파일러
-   JIT 컴파일러 (Just-In-Time-Compiler)
-   이벤트 루프, Call Stack, Task Queue
-   공통 컴포넌트 설계
-   rest
-   기본 타입 확장
-   공통 버튼 컴포넌트 만드는데 어떻게 해야할지 모르겠음,
-   리엑트에서의 단일 책임 원칙
-   리엑트 쿼리 사람답게 쓰기
-   suspense
-   에러 바운더리
