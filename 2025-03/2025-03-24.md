# TIL | 2025.03.24

## 📌 TIL 요약

### 알고리즘

-   자료구조 (스택 큐 마무리)
    -   4 ~ 7

### 주시

-   UI 작업 후 stomp 공부 (UI 피드백 받은 후)

# TIL 상세

## 알고리즘

-   자료구조 (스택 큐 마무리)
    -   4 ~ 7

### 주시

-   [ ] UI 작업 후 stomp 공부 (UI 피드백 받은 후)

### smiletogether

-   MSA 환경 대응을 위한 axios 인스턴스 분리 및 공통 인터셉터 적용

    -   API Gateway 없이 MSA 환경 대응을 위한 axios 구조 설계
        -   처음에는 서버별 인스턴스를 따로 만들어주려 했음, 하지만 추상화해버리고 추가적으로 필요한 부분은 덮어쓰기
        -   백엔드가 MSA 구조로 서비스가 나뉘어 있음 (user, chat, auth 등)
        -   하지만 API Gateway가 존재하지 않아 프론트에서 각 서비스와 직접 통신해야 하는 상황
        -   이를 해결하기 위해 서비스별로 axios 인스턴스를 분리하고, 중복되는 설정은 createApi() 함수로 추상화하여 공통화함 근데 공통되지 않은 부분에서는 어떻게 해야할지 모르겠음

## 비즈니스 로직 분리를 중심으로 한 프론트엔드 아키텍처 & 디자인 패턴 실전 학습 과정

-   스마일 투게더 리팩토링을 위해 팀원이 작업했던 코드를 보던도중 api 파일에 api 로직과 비즈니스 로직이 같이 혼재되어 있는걸 발견함
-   api 파일에 비즈니스 로직이 혼재되어 있는게 괜찮은지 안괜찮다면 어떻게 해야할지를 고민했었고 공부하기 시작함
-   프론트엔드 개발자가 알아야 할 아키텍처 설계의 기본 개념부터, 디자인 패턴과 비즈니스 로직 분리를 실제 코드에 적용하는 경험이 부족하다는걸 알게됨

> 싱글톤을 공부하기 위한 CLASS 개념 다시 공부

## JS CLASS

### JS 클래스와 프로토타입, 쉽게 정리

---

#### 🧱 1. 객체 만드는 방법

-   **객체 리터럴**: 중괄호 `{}`를 써서 직접 객체를 만드는 방법 → 가장 간단하지만, 객체마다 메서드를 따로 만들기 때문에 **비효율적**

-   **생성자 함수 + new**: 함수를 `new` 키워드로 호출해서 객체를 만드는 방법 → **같은 구조의 객체를 효율적으로 여러 개 만들 수 있음**

-   **클래스(class)**: ES6에서 도입된 방식으로, 생성자 함수와 비슷하지만 문법이 훨씬 간단함 → 내부적으로는 생성자 함수와 같은 원리로 작동하지만 **더 읽기 쉽고 쓰기 편함**

---

#### 🧠 2. 생성자 함수의 prototype이 하는 일

-   함수에는 기본적으로 **`prototype`이라는 속성**이 자동으로 생긴다
-   `new 함수()`로 객체를 만들면, 그 객체는 이 `prototype`을 **물려받는다**
-   그래서 메서드를 `함수.prototype`에 적어두면, **모든 객체가 그걸 공유해서 쓸 수 있음**

---

#### 🧬 3. [[Prototype]] (프로토타입 체인)

-   `[[Prototype]]`은 객체 내부에 숨어 있는 **"부모 객체" 연결고리**
-   객체는 자기 속성에 없으면 이 연결고리를 따라 부모에게서 값을 찾는다
-   `new`로 만든 객체는 이 연결고리를 생성자 함수나 클래스의 `prototype`과 자동으로 연결함

---

#### 🔄 4. constructor 프로퍼티

-   `prototype` 객체에는 기본적으로 **`constructor`라는 속성**이 있음
-   이건 "이 객체는 어떤 함수로 만들어졌는지" 알려줌
-   나중에 그 함수로 다시 객체를 만들 때 쓸 수 있음
-   다만, `prototype`을 통째로 바꾸면 이 `constructor`도 사라지니까 주의해야 함

---

#### ✨ 5. class 문법 정리

-   `class` 문법은 생성자 함수와 똑같이 동작하지만, **문법이 더 간단하고 읽기 쉬움**
-   클래스 안에 메서드를 적으면 자동으로 `prototype`에 들어간다
-   그래서 인스턴스들이 메서드를 **공유해서 사용함**
-   요즘은 거의 다 `class` 문법을 쓰는 추세

## Singleton 패턴

-   Singleton은 1회에 한하여 인스턴스화가 가능하며 전역에서 접근 가능한 클래스를 지칭한다. 만들어진 Singleton 인스턴스는 앱 전역에서 공유되기 때문에 앱의 전역 상태를 관리하기에 적합하다.

    ```ts
    let counter = 0;
    let instance;
    class Counter {
        constructor() {
            if (instance) {
                throw new Error('already exist');
            }
            instance = this;
        }
        getInstance() {
            return this;
        }
    }
    const SingleTonCounter = Object.freeze(new Counter());
    ```

### Singleton 패턴 단점과 장점

-   인스턴스를 하나만 만들도록 강제하면 꽤 많은 메모리 공간을 절약할 수 있다. 매번 새로운 인스턴스를 만들어 메모리 공간을 차지하도록 하는 대신에. 우리는 예제에서 앱 전체에서 사용 가능한 하나의 인스턴스를 저장하기 위한 메모리를 사용했다. 하지만 Singleton은 안티패턴 혹은 자바스크립트에서는 하지 말아야 할 것으로 언급되곤 한다.
    -   왜 하지 말아야할까?
-   Java와 C++ 같은 다양한 언어들은 JavaScript 처럼 객체를 직접적으로 만들어낼 수 없다. 이런 객체지향 프로그래밍 언어에서는 객체를 만들기 위한 클래스를 꼭 작성해야 한다. 이렇게 만든 객체는 위의 instance 변수와 같이 클래스의 인스턴스가 된다.

### Singleton패턴을 사용할 때의 단점

-   Singleton패턴으로 구현된 코드를 테스트하는것은 조금 까다롭다. 인스턴스를 매번 생성할 수 없기 때문에 모든 테스트들은 이전 테스트에서 만들어진 전역 인스턴스를 수정할 수 밖에 없다. 테스트들이 실행에 순서가 생기게 되면 작은 수정사항이 전체 테스트의 실패로 이어질 수 있다. 하나의 테스트가 끝나면 인스턴스의 변경사항들을 초기화 해 주어야 한다.

### 참조

-   https://patterns-dev-kr.github.io/design-patterns/singleton-pattern/

### 테스트

-   내경험

    -   기간이 있는 프로젝트만 해봐서 기능 구현하기 급급했다. 테스트코드 해본적 없고 테스트 케이스 테스트 시나리오 이런거 팀원들하고 해본적 없다
    -   그건 테스트를 안한거다 기능이 수정됬을떄 그리고 올바르게 동작하는지 확인하려 쓴다
    -   테스트코드 적는게 ui로 직접 확인하는것보다 오래걸리지 않냐
    -   기능이 변경됬다고 가정했을때 직접 ui를 확인하는게 아니라 테스트코드로 하면 편하다 코드라인에서 해격ㄹ하니
    -   개발자가 많은 회사를 다닌다 생각하자 수 백명이 건드리는 작성하는 레포인데 어떻게 그걸 알려줄거고 다른 사람이 테스트코드보고 내 코드보는게 더 이해가 쉽다

-   테스트 코드는 주석이다.
-   행위에 집중
-   test를 짜려면 함수가 많이 분리되어야함 tdd
-   test를 하면 코드의 문서화 도구로써 쓸 수가 있다
-   테스트하기 좋은 코드가 좋은코드일 확률이 높다

-   rfce
-   스니펫
