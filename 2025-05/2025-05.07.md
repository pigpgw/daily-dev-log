# TIL | 2025.05.07

## 주간 목표

-   계획한 미라클 모닝 자리잡기
-   스픽 챌린저
-   루틴 확립하기
    -   충분한 수면을 가져가려고 노력하기 (TIL 공유를 조금 늦은 시간에 진행하고 2시에 취침하고 7시에 기상해서 운동까지 해버리니 너무 피곤함)
    -   일어나서 런닝하는건 지양한다. (피곤해지기 때문에)
    -   런닝은 하루 일과를 마무리하고 근력운동 전 또는 후에 진행한다.
    -   스픽을 운동하고 씻고 딱 한개만실시한다.
    -   최대한 이동하는 시간을 활용해서 진행한다.(다 남는 시간이다.)
    -   하루에 최소 알고리즘 하나를 풀도록 노력하기
    -   책은 내용을 암기하는게 아니다 가볍게 흘러가듯이 읽자
-   [벨로그](https://velog.io/@pigpgw/%EB%82%98%EC%9D%98-%EA%B0%9C%EB%B0%9C-%EC%84%B1%EC%9E%A5-%EC%A0%84%EB%9E%B5-%EC%83%9D%EA%B0%81%ED%95%98%EB%8A%94-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A1%9C-%EB%82%98%EC%95%84%EA%B0%80%EA%B8%B0)에 작성한 것들 습관화하기
-   기존 코드에서 타입만을 고민하는게 중요한게 아니다.
-   기존 컴포넌트 트리의 구조를 먼저 생각해 보는게 우선이다.
-   기존 코드의 타입을 올바르게 이해하기 위해선 개인적인 생각으로 필요한것들
    -   해당 컴포넌트의 역할
    -   파라미터로 넘어오는 데이터가 의미하는 것 또는 용도
    -   프로젝트에서 해당 타입의 의미?
    -   어떤 도메인인가?

### 중요 일정

-   5월 10일 토요일 12:40 : 정보처리기사 필기
-   5월 13일 ~ 5월 24일 싸피 에세이 제출
-   5월 24일 토요일 싸피 코테
-   5월 31일 토요일 10:00 : sqld 시험 (광주 조선대학교부속중학교)

### 오늘 진행 순서 예정

-   [x] 스픽
-   [x] 매일 매일 면접 질문 (리액트의 Controlled Component와 Uncontrolled Component의 차이점에 대해서 설명해주세요.)
-   [x] 블로그 하나 읽기[터미널 함수](https://velog.io/@euisuk-chung/%EB%82%B4%EA%B0%80-%EB%B3%B4%EB%A0%A4%EA%B3%A0-%EC%A0%95%EB%A6%AC%ED%95%9C-%ED%84%B0%EB%AF%B8%EB%84%90-%ED%95%A8%EC%88%98-25%EC%84%A0)
-   [x] 알고리즘
-   [x] 정처기 필기 2023 년 1회
-   [x] 스마게 작업
    -   [x] [알림 설계 보완하기](https://github.com/sgdevcamp2025/smiletogether/issues/223)
    -   [x] 알람 구현하기
        -   서비스워커와 푸쉬 API를 통해서 백그라운드 데이터 처리
        -   포그라운드는 파이어베이스 메세징 이벤트를 사용해서 처리
        -   현재 진행중인 로직은 유저가 접속해있는 채팅방에 대한 메세지는 알림이 오지 않는 로직으로 작성중
        -   장혁님께 질문 남겨둠
            -   새 메세지시 notification에 담겨오는 타이틀과 바디는 안쓰는지
            -   구동 정보 등록에 endpoint가 아닌 유저의 fcm 토큰을 보내야하는건 아닌지
-   [x] 운동

---

# TIL

## 매일 매일 면접 질문 리액트의 Controlled Component와 Uncontrolled Component의 차이점에 대해서 설명해주세요.

Controlled Component는 리액트 상태(state)를 통해 입력 값을 제어하는 컴포넌트를 말합니다. 이 방식에서는 입력 요소의 값(value)을 리액트 상태와 동기화하고, 사용자가 입력을 변경할 때마다 onChange 이벤트 핸들러를 통해 상태를 업데이트합니다. Controlled Component는 값이 리액트의 state로 관리되므로, 입력 시마다 값을 검증하거나, 값을 자유롭게 변경할 수 있으며, 복잡한 폼 로직을 처리하는 데 유용합니다.

Uncontrolled Component는 입력 값을 리액트의 상태로 관리하지 않고, DOM을 통해 입력 값을 제어하는 방식입니다. 즉, 입력 요소의 값은 DOM에서 직접 관리되며, 리액트는 이를 제어하지 않습니다. 이 방식에서는 useRef를 사용해 생성된 참조 객체인 ref를 사용하여 DOM 요소에 직접 접근하여 값을 읽거나 조작합니다. Uncontrolled Component는 리액트 상태 관리에 따른 성능 비용이 없으므로 상대적으로 간단한 폼에서 주로 사용됩니다.

### Controlled Component와 Uncontrolled Component는 각각 어떤 상황에서 사용되나요? 🤔

단순한 입력 필드가 포함된 폼에서는 입력 요소의 값을 리액트 상태로 관리할 필요성이 적으므로, Uncontrolled Component를 사용하는 것이 더 간단하고 성능이 좋습니다. 사용자가 제출 버튼을 클릭했을 때만 입력 값을 가져와도 충분한 경우를 예시로 들 수 있습니다.

반면, 값을 입력할 때마다 유효성 검증을 실시간으로 해주어야 하는 경우에는 Controlled Component를 사용해야 합니다.

### 설명 추가

-   Controlled 방식
    -   단순한 입력 필드가 포함된 폼에서는 입력 요소의 값을 리액트 상태로 관리할 필요성이 적으므로, Uncontrolled Component를 사용하는 것이 더 간단하고 성능이 좋음.
    -   입력값을 매 입력 시마다 상태로 업데이트하는 Controlled 방식은 내부적으로 리렌더링이 반복되기 때문에, 불필요한 성능 부담이 발생할 수 있음
-   반면 Uncontrolled 방식
    -   DOM이 직접 값을 관리하기 때문에 리렌더링을 유발하지 않으며, 사용자가 입력을 완료한 뒤 제출 버튼을 클릭했을 때만 값을 가져오면 되는 간단한 입력 처리에는 더 적합
    -   예를 들어, 이름 한 줄을 입력받고 제출만 처리하면 되는 폼의 경우 Uncontrolled 방식이 효율적

## 책 읽기

## 블로그 하나 읽기 [터미널 함수](https://velog.io/@euisuk-chung/%EB%82%B4%EA%B0%80-%EB%B3%B4%EB%A0%A4%EA%B3%A0-%EC%A0%95%EB%A6%AC%ED%95%9C-%ED%84%B0%EB%AF%B8%EB%84%90-%ED%95%A8%EC%88%98-25%EC%84%A0)

## 알고리즘

### 코테 적용 방법

-   Step1 문제 이해하기
    -   문제를 제대로 읽기
    -   제약조건 읽기
        -   효율성 테스트 10^8 넘으면 안됨
        -   원소 값의 범위
            -   int === 4byte => 1bit는 부호 31bit는 수 표현 -2^31 ~ 2^31 + 1
                -   2의 31승은 10의 9승 그러면 인트형 변수에 저장 불가
-   Step2 접근 방법
    -   직관적으로 생각하기
        -   보통 완전 탐색으로 시작
        -   문제 상황을 단순화 하여 생각하기
        -   문제 상황을 극한화 하여 생각하기
    -   자료구조와 알고리즘 활용
        -   Step1 문제이해 에서 파악한 내용을 토대로 어떤 자료구조를 사용하는게 가장 적합한지 결정
        -   대놓고 특정 자료구조와 알고리즘을 묻는 문제도 많음
        -   자료구조에 따라 선택할 수 있는 알고리즘을 문제에 적용
    -   메모리 사용
        -   시간복잡도를 줄이기 위해 메모리를 사용하는 방법
        -   대표적으로 해시테이블

### 대표 알고리즘

-   O(1): Operation push and pop on Stack
-   O(log n): Binary Tree
-   O(n): for loop
-   O(n×log n): Quick Sort, Merge Sort, Heap Sort
-   O(n2): Double for loop, Insert Sort, Bubble Sort, Selection Sort
-   O(2n): Fibonacci Sequence

## 정처기 필기 2022 년 3회

### 1과목

-   워크스루 : 워크스루는 소프트웨어 개발 단계에서 문서나 코드를 그룹의 구성원들과 함께 순회하면서 검토하는 방법입니다. 주로 팀 멤버들 간의 의사 소통을 촉진하고 이해도를 높이기 위해 사용
-   인스펙션 : 인스펙션은 정형적이고 체계적인 방법으로 소프트웨어의 코드나 문서를 검토하는 절차입니다. 주로 오류 및 결함을 찾아내기 위해 엄격한 규칙에 따라 수행
    -   검토자와 작성자 분리: 코드나 문서를 작성한 사람과 검토하는 사람을 분리하여 편견을 줄이고 객관적인 결과를 얻을 수 있습니다
-   XP 5가지 가치
    -   의사소통(Communication)
    -   단순성(Simplicity)
    -   용기(Courage)
    -   피드백(Feedback)
    -   존중(Respect)
-   하향식 설계
    -   시스템의 전반적인 구조를 먼저 정의한 다음 점차 세부적인 부분으로 내려가며 설계하는 방식
-   상향식 설계
    -   개별적인 구성 요소나 모듈을 먼저 설계한 후, 이를 조합하여 전체 시스템을 구축하는 방식
-   UML
    -   객체지향 소프트웨어 개발 과정에서 산출물을 명세화, 시각화, 문서화할 때 사용되는 모델링 기술과 방법론을 통합해서 만든 표준화된 범용 모델링 언어
-   UML 구성요소
    -   사물 : 종류 : 구조 사물, 행동 사물. 그룹 사물, 주해 사물
    -   관계
    -   다이어그램
-   UML 다이어그래 ㅁ유형
    -   종류 : 클객컴 배폭패 유시커 상활
        -   구조적(정적) 다이어그램 : 클객컴 배폭패
            -   클래스 다이어그램 : 정적인 관계를 표현한 다이어그렘
                -   구성 요소
                -   클래스 이름
                -   속성 : 클래스의 상태나 정보
                -   연산 : 클래스 동작
                -   접근 제어자
        -   행위적(동적 다디어그램) : 유시커 상활타
            -   유스케이스 다이어그램
                -   사용자 측면에서의 요구사항
                -   시스템과 상호작용하는 모든 외부요소는 액터이다
                -   액터가 인식할 수 없는 시스템 내부의 기능을 하나의 유스케이스로 파악해서는 안된다.
                -   시스템 액터는 다른 프로젝트에서 이미 개발되어 사용되고 있다.
            -   유스케이스 다이어그램 구성요소
                -   액터 : 시스템과 상호작용을 하는 모든 외부 요소
                -   유스케이스 : 사용자가 보는 관점
                -   관계 : 연관 관계, 포함 관계, 확장 관계(유스케이스가 특정 조건에 부합), 일반화 관계
            -   순차 다이어그램
                -   객체 간 상호작용을 메시지 흐름으로 표현한 다이어그램
                -   주로 동적인 측면에서 모델링을 설계하기 위해 사용
                -   수직 방향이 시간의 흐름을 나타매
            -   순차 다이어그램 구성 요소
                -   객체 : 사격형 밑줄
                -   생명선 : 객체로부터 뻗어나가는 점선
                -   실행
                -   메시지 : 화살표
                -   제어블록
            -   상태 다이어그램
                -   객체들 사이에 발생하는 이벤트에 의한 객체들의 상태 변화를 그림으로 나타낸 다이어그램
                -   럼바우에 사용됨
            -   활동 다이어그램
                -   오퍼레이션이나 처리 과정이 수행되느 ㄴ동안 일어나는 일들을 단계적으로 표현한 다이어그램
            -   UML의 관계 : 사물과 사물 사이의 연관성을 표현하는 것
                -   연관 관계 : 2개 이상의 사물이 서로 관련된 상태를 화살표 실선으로 표현
                -   집합 관계 : 속이 빈 마름모를 여녁ㄹ
                -   일반화 관계 : 하나의 사물이 다른 사물에 비해 더 일반적인지 구체적인지를 표현
                -   의존 관계 : 하나의 사물의 변화가 다른 사물에게 영향을 미치는 관계
                -   실체화 관계 : 실체화 관계는 사물이 할 수 있거나 해야하는 기능, 의미적 관계
            -   스테레오 타입
                -   길러멧 <<>>
-   UML 주요 관계
    -   일반화 관계 : 상속 관계와 유사, 한 개념에 포함되는 개념의 관계
    -   실현(realization) 관계 : 한 객체가 다른 객체에게 오퍼레이션 수행하도록 지시
    -   의존 관계 : 다른 객체 참조
    -   연관 관계 : 다른 객체 참조
-   객체지향/GoF 디자인 패턴

    -   객체지향
        -   소프트웨어 개발하기 위한 비즈니스(업무)를 객체와 속성, 클래스와 멤버, 전체와 부분등으로 나누어서 분석해 내는 기법
    -   객체지향 구성 요소(클객메 메인속)
        -   클래스
            -   하나 이상의 유사한 객체들을 묶어 공통된 특성을 표현한 데이터 추상화
            -   공통괸 속성과 연산(행위)을 갖는 객체의 집합
        -   객체
            -   자신 고유의 데이터를 가지며 클래스에서 정의한 행위를 수행
        -   메서드 : 클래스로부터 생성된 객체를 사용하는 방법, 객체에 명령을 내리는 메시지
        -   메시지 : 객체에게 어떤 행위를 하도록 지시하는 명령
        -   인스턴스 : 클래스에 속한 각각의 객체
        -   속성 : 한 클래스 내에 속한 객체들이 가지고 있는 데이터 값들을 단위별로 정의
    -   객체지향 기법
        -   캡슐화
            -   속성과 관련된 연산을 클래스 안에 묶어서 하나로 취급하는 것을 의미
            -   외부와 경계를 만들고 필요한 인터페이스만을 밖으로 드러내는 과정
            -   정보 은닉과 밀접한 관계
            -   인터페이스가 단순화되고 재사용이 높아지고, 오류파급 효과가 적음
        -   상속성
            -   상위 클래스의 속성과 메소드를 하위 클래스에서 재정의 없이 물려받아 사용하는 기법
        -   다형상
            -   오버로딩 : 상위 클래스에서 정의한 메소드를 하위에서 무시하고 재정의 가능
            -   오버라이딩 : 매소드 명은 같지만 매개변수의 개수나 타임을 다르게 함으로써 구현, 구분 가능
        -   추상화 : 공통 성질을 추출하여 클래스를 설정하는 기법
        -   정보은닉
            -   필요하지 않은 정보는 접근할 수 없도록 하여 한 모듈 또는 하부 시스템이 다른 모듈의 구현에 영향을 받지 않게 설계되는 것을 의미한다.
            -   모듈의 독립성을 갖게 해주므로, 요구사항 등 변화에 따른 수정, 시험, 유지보수가 용이
    -   객체지향 설계 원칙 (SOLID)
        -   개방 폐쇄 원칙 : 확장에는 열려 있고 변경에 대해 닫혀 있어야한다.
        -   리스코프 치환의 원칙 : 서브 타입은 어디서나 자신의 기반 타입으로 교체할 수 있어야한다
        -   인터페이스 분리의 원칙 : 클라이언트가 사용하지 않는 인터페이스 때문에 영향을 받아서는 안된다
    -   객체지향 방법론 종류
        -   OOSE (Object Oriented Software Engineering)
            -   야콥슨
            -   유스케이스
        -   OMT (Object Modeling Technology)
            -   Rumbaugh
            -   럼바우의 객체지향 분석 절차 (객동기) : 객체 모델링 → 동적 모델링 → 기능 모델링
        -   OOA
            -   Coad와 Yourdon 방법론
            -   E-R 다이어그램을 사용하여 객체의 행위를 모델링
            -   객체 식별, 구조 식별, 주체 정의, 속성 및 관계 정의, 서비스 정의 등의 과정으로 구성되는 객체 지향 분석방법
    -   럼바우(Rumbaugh) 분석 기법
        -   객체 모델링(Object Modeling)
            -   정보 모델링이라고 하며, 시스템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 객체 다이어그램으로 표시
        -   동적 모델링(Dynamic Modeling)
            -   상태 다이어그램(상태도)을 이용하여 시간의 흐름에 따른 객체들 간의 제어 흐름, 상호 작용, 동작 순서 등의 동적인 행위를 표현하는 모델링 [2020년 3회]
        -   기능 모델링(Functional Modeling)
            -   자료 흐름도(DFD)를 이용하여 다수의 프로세스들 간의 자료 흐름을 중심으로 처리 과정을 표현한 모델링 [2021년 3회]
    -   디자인 패턴 : 소프트웨어 설계에서 자주 발생하는 문제에 대한 일반적이고 반복적인 해결 방법 [2022년 1회]

        -   디자인 패턴 사용의 장단점
            -   절차형 언어보다는 객체지향 언어와 함께 이용될 때 효율이 극대화된다. [2020년 3회]
        -   디자인 패턴 구성요소 (패문솔 사결샘)
            -   패턴 이름 / 문제 및 배경 / 솔루션 / 사례 / 결과 / 샘플 코드  [2020년 2회]
        -   디자인 패턴 유형 (생구행)
            -   목적: 생성 / 구조 / 행위
        -   GoF(Gangs of Four) 디자인 패턴 종류

            -   생성 패턴 / 구조 패턴 / 행위 패턴으로 분류된다. [2020년 3회] [2023년 2월]
            -   생성 패턴 (생빌 프로 팩앱싱) [2021년 1회, 2회] [2022년 1회]

                -   빌더 / 프로토타입 / 팩토리 메서드 / 앱스트랙 팩토리 / 싱글톤
                    -   Prototype : 복사하여 새 개체를 생성할 수 있도록 하는 패턴  [2021년 3회]
                    -   Factory Method : 객체를 생성하기 위한 인터페이스를 정의하여 어떤 클래스가 인스턴스화 될 것인지는 서브 클래스가 결정하도록 하는 패턴, Virtual-Constructor 패턴이라고도 함[2020년 2회, 3회, 2023년 3회]
                    -   Singleton : 유일한 하나의 인스턴스를 보장하도록 하는 패턴하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만, 여러 프로세스가 동시에 참조할 수는 없는 패턴 [2022년 3회, 2023년 2회]

            -   구조 패턴 (구 브데 퍼플 프록 컴 어) [2022년 2회] [2023년 1회, 3회]
                -   브리지 / 데코레이터 / 퍼지사이드 / 플라이 웨이트 / 프록시 / 컴포지트 / 어댑터
                    -   Adapter : 기존에 구현되어 있는 클래스에 기능 발생 시 기존 클래스를 재사용할 수 있도록 중간에서 맞춰주는 역할을 한다.
            -   행위 패턴 [2020년 1회, 2회]
                -   Command, Observer, State, Visitor, Interpreter, Template Method, Chain of Responsibility, Iterator, Mediator, Memento,Strategy
                    -   Template Method : 알고리즘은 상위 클래스에서 정의하고 나머지는 하위 클래스에서 구체화하는 패턴 [2023년 2회]
                    -   Observer : 상태가 변할 때 의존자들에게 알리고, 자동 업데이트하는 패턴
                    -   Strategy : 다양한 알고리즘을 캡슐화하여 알고리즘 대체가 가능하도록 한 패턴 [2021년 3회]
                    -   Visitor : 오퍼레이션을 별도의 클래스에 새롭게 정의한 패턴 [2020년 1회]

-   테스트 오라클 : 테스트의 결과가 올바른지 판단할 기준을 제공하는것
    -   종류
        -   참 오라클
        -   샘플링 오라클
        -   휴리스틱 오라클
        -   일관성 검사
