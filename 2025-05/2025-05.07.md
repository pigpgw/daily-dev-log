# TIL | 2025.04.29

## 주간 목표

-   계획한 미라클 모닝 자리잡기
-   스픽 챌린저
-   루틴 확립하기
    -   충분한 수면을 가져가려고 노력하기 (TIL 공유를 조금 늦은 시간에 진행하고 2시에 취침하고 7시에 기상해서 운동까지 해버리니 너무 피곤함)
    -   일어나서 런닝하는건 지양한다. (피곤해지기 때문에)
    -   런닝은 하루 일과를 마무리하고 근력운동 전 또는 후에 진행한다.
    -   스픽을 운동하고 씻고 딱 한개만실시한다.
    -   최대한 이동하는 시간을 활용해서 진행한다.(다 남는 시간이다.)
    -   하루에 최소 알고리즘 하나를 풀도록 노력하기
    -   책은 내용을 암기하는게 아니다 가볍게 흘러가듯이 읽자
-   [벨로그](https://velog.io/@pigpgw/%EB%82%98%EC%9D%98-%EA%B0%9C%EB%B0%9C-%EC%84%B1%EC%9E%A5-%EC%A0%84%EB%9E%B5-%EC%83%9D%EA%B0%81%ED%95%98%EB%8A%94-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A1%9C-%EB%82%98%EC%95%84%EA%B0%80%EA%B8%B0)에 작성한 것들 습관화하기
-   기존 코드에서 타입만을 고민하는게 중요한게 아니다.
-   기존 컴포넌트 트리의 구조를 먼저 생각해 보는게 우선이다.
-   기존 코드의 타입을 올바르게 이해하기 위해선 개인적인 생각으로 필요한것들
    -   해당 컴포넌트의 역할
    -   파라미터로 넘어오는 데이터가 의미하는 것 또는 용도
    -   프로젝트에서 해당 타입의 의미?
    -   어떤 도메인인가?

### 중요 일정

-   5월 10일 토요일 12:40 : 정보처리기사 필기
-   5월 13일 ~ 5월 24일 싸피 에세이 제출
-   5월 24일 토요일 싸피 코테
-   5월 31일 토요일 10:00 : sqld 시험 (광주 조선대학교부속중학교)

### 오늘 진행 순서 예정

-   [x] 스픽
-   [x] 매일 매일 면접 질문 (리액트의 Controlled Component와 Uncontrolled Component의 차이점에 대해서 설명해주세요.)
-   [x] 블로그 하나 읽기[터미널 함수](https://velog.io/@euisuk-chung/%EB%82%B4%EA%B0%80-%EB%B3%B4%EB%A0%A4%EA%B3%A0-%EC%A0%95%EB%A6%AC%ED%95%9C-%ED%84%B0%EB%AF%B8%EB%84%90-%ED%95%A8%EC%88%98-25%EC%84%A0)
-   [x] 알고리즘
-   [] 정처기 필기 2021 년 회
-   [] 주시 작업

    -   원래 Home page에서 불러오던 시위 데이터를 카카오맵에서 호출하게 뺏는데 올바른가?
    -   캐싱되는 문제는?
    -   오늘자 시위 정보가 없으면?
    -   스토리북
    -   테스트
    -   컴포넌트
        -   컴포넌트 설계 다시 생각하기
    -   리엑트 쿼리
        -   폴링을 위해 사용중인 리액트 쿼리 사용 올바른가
    -
    -   에러처리
        -   에측 가능한 에러
            -   응원하기 안될때
                -   해당 시위가 오늘 날짜 시위가 아니라서 안될때 또는 서버에서 시위 정보가 없어서
            -   시위 데이터가 갱신이 안됬을때
                -   캐싱 문제로 시위 데이터가 오늘 시위 데이터가 아닐때
            -   시위 데이터를 못불러 왔을때\
            -   오늘 시위데이터가 없을때
        -   예측 불가능한 에러

-   [x] 스마게 작업
    -   [x] [알림 설계 보완하기](https://github.com/sgdevcamp2025/smiletogether/issues/223)
    -   [x] 알람 구현하기
        -   서비스워커와 푸쉬 API를 통해서 백그라운드 데이터 처리
        -   포그라운드는 파이어베이스 메세징 이벤트를 사용해서 처리
        -   현재 진행중인 로직은 유저가 접속해있는 채팅방에 대한 메세지는 알림이 오지 않는 로직으로 작성중
        -   장혁님께 질문 남겨둠
            -   새 메세지시 notification에 담겨오는 타이틀과 바디는 안쓰는지
            -   구동 정보 등록에 endpoint가 아닌 유저의 fcm 토큰을 보내야하는건 아닌지
    -   [] 포그라운드 테스트를 위해서는 백엔드가 필요함
-   [] 운동

---

# TIL

## 매일 매일 면접 질문 리액트의 Controlled Component와 Uncontrolled Component의 차이점에 대해서 설명해주세요.

Controlled Component는 리액트 상태(state)를 통해 입력 값을 제어하는 컴포넌트를 말합니다. 이 방식에서는 입력 요소의 값(value)을 리액트 상태와 동기화하고, 사용자가 입력을 변경할 때마다 onChange 이벤트 핸들러를 통해 상태를 업데이트합니다. Controlled Component는 값이 리액트의 state로 관리되므로, 입력 시마다 값을 검증하거나, 값을 자유롭게 변경할 수 있으며, 복잡한 폼 로직을 처리하는 데 유용합니다.

Uncontrolled Component는 입력 값을 리액트의 상태로 관리하지 않고, DOM을 통해 입력 값을 제어하는 방식입니다. 즉, 입력 요소의 값은 DOM에서 직접 관리되며, 리액트는 이를 제어하지 않습니다. 이 방식에서는 useRef를 사용해 생성된 참조 객체인 ref를 사용하여 DOM 요소에 직접 접근하여 값을 읽거나 조작합니다. Uncontrolled Component는 리액트 상태 관리에 따른 성능 비용이 없으므로 상대적으로 간단한 폼에서 주로 사용됩니다.

### Controlled Component와 Uncontrolled Component는 각각 어떤 상황에서 사용되나요? 🤔

단순한 입력 필드가 포함된 폼에서는 입력 요소의 값을 리액트 상태로 관리할 필요성이 적으므로, Uncontrolled Component를 사용하는 것이 더 간단하고 성능이 좋습니다. 사용자가 제출 버튼을 클릭했을 때만 입력 값을 가져와도 충분한 경우를 예시로 들 수 있습니다.

반면, 값을 입력할 때마다 유효성 검증을 실시간으로 해주어야 하는 경우에는 Controlled Component를 사용해야 합니다.

### 설명 추가

-   Controlled 방식
    -   단순한 입력 필드가 포함된 폼에서는 입력 요소의 값을 리액트 상태로 관리할 필요성이 적으므로, Uncontrolled Component를 사용하는 것이 더 간단하고 성능이 좋음.
    -   입력값을 매 입력 시마다 상태로 업데이트하는 Controlled 방식은 내부적으로 리렌더링이 반복되기 때문에, 불필요한 성능 부담이 발생할 수 있음
-   반면 Uncontrolled 방식
    -   DOM이 직접 값을 관리하기 때문에 리렌더링을 유발하지 않으며, 사용자가 입력을 완료한 뒤 제출 버튼을 클릭했을 때만 값을 가져오면 되는 간단한 입력 처리에는 더 적합
    -   예를 들어, 이름 한 줄을 입력받고 제출만 처리하면 되는 폼의 경우 Uncontrolled 방식이 효율적

## 책 읽기

## 블로그 하나 읽기 [터미널 함수](https://velog.io/@euisuk-chung/%EB%82%B4%EA%B0%80-%EB%B3%B4%EB%A0%A4%EA%B3%A0-%EC%A0%95%EB%A6%AC%ED%95%9C-%ED%84%B0%EB%AF%B8%EB%84%90-%ED%95%A8%EC%88%98-25%EC%84%A0)

## 알고리즘

### 코테 적용 방법

-   Step1 문제 이해하기
    -   문제를 제대로 읽기
    -   제약조건 읽기
        -   효율성 테스트 10^8 넘으면 안됨
        -   원소 값의 범위
            -   int === 4byte => 1bit는 부호 31bit는 수 표현 -2^31 ~ 2^31 + 1
                -   2의 31승은 10의 9승 그러면 인트형 변수에 저장 불가
-   Step2 접근 방법
    -   직관적으로 생각하기
        -   보통 완전 탐색으로 시작
        -   문제 상황을 단순화 하여 생각하기
        -   문제 상황을 극한화 하여 생각하기
    -   자료구조와 알고리즘 활용
        -   Step1 문제이해 에서 파악한 내용을 토대로 어떤 자료구조를 사용하는게 가장 적합한지 결정
        -   대놓고 특정 자료구조와 알고리즘을 묻는 문제도 많음
        -   자료구조에 따라 선택할 수 있는 알고리즘을 문제에 적용
    -   메모리 사용
        -   시간복잡도를 줄이기 위해 메모리를 사용하는 방법
        -   대표적으로 해시테이블

### 대표 알고리즘

-   O(1): Operation push and pop on Stack
-   O(log n): Binary Tree
-   O(n): for loop
-   O(n×log n): Quick Sort, Merge Sort, Heap Sort
-   O(n2): Double for loop, Insert Sort, Bubble Sort, Selection Sort
-   O(2n): Fibonacci Sequence

---

## 유익한 유튜브 시청하기

## 강의 수강

### 공부할거

-   리엑트 컴포넌트 렌더링 개발도구 통해서 성능 측정방법

### 할거

-   JS 엔진 구조 (V8, SpiderMonkey)
-   인터프리터 vs 컴파일러
-   JIT 컴파일러 (Just-In-Time Compiler)
-   이벤트 루프, Call Stack, Task Queue
-   공통 컴포넌트 설계
-   rest
-   기본 타입 확장
-   공통 버튼 컴포넌트 만드는데 어떻게 해야할지 모르겠음,
-   리엑트에서의 단일 책임 원칙
-   리엑트 쿼리 사람답게 쓰기
-   suspense

-   작업

    -   next에서 fetch params next invalidate

-   패키지 매니저
    -   package.json
        -   ^ 메이저 버전 이상 아무거나
    -   packagelock.json
        -   정확한 현재 프로젝트에 설치된 라이브러리 버전 명시

---

# 프론트엔드 아키텍처

## 뷰 로직과 비즈니스 로직의 분리

### 목적

-   **컴포넌트 재사용성 증가**
-   **유지보수성 향상**
-   **테스트 용이성 확보**

### 예시

#### 뷰 로직 (UI 컴포넌트)

```tsx
const ProductCard = ({ product, onBuy }: Props) => {
    return (
        <div>
            <p>{product.name}</p>
            <button onClick={() => onBuy(product.id)}>구매</button>
        </div>
    );
};
```

#### 비즈니스 로직 (커스텀 훅)

```ts
const useBuyProduct = () => {
    const mutation = useMutation((productId) => buyAPI(productId));
    return mutation;
};
```

### 좋은 구조

-   UI: 입력 → 출력에 집중 (props 기반)
-   로직: 상태 관리, 요청 처리 등은 **hooks나 service 파일로 분리**

## 공부하고 싶은 키워드

## 1. **소프트웨어 설계 원칙 관련**

| 주요 개념                                  | 설명                                           | 함께 공부하면 좋은 개념                                                                   |
| ------------------------------------------ | ---------------------------------------------- | ----------------------------------------------------------------------------------------- |
| **관심사의 분리 (Separation of Concerns)** | 기능/책임/영역을 나눠서 복잡도를 낮추는 원칙   | - SRP (단일 책임 원칙)<br>- 모듈화(Modularity)<br>- MVC/MVVM 패턴<br>- 레이어드 아키텍처  |
| **추상화 계층 (Abstraction Layer)**        | 하위 로직을 숨기고 필요한 기능만 노출하는 구조 | - 캡슐화<br>- 인터페이스 / 추상 클래스<br>- 레이어드 아키텍처<br>- 의존성 역전 원칙 (DIP) |
| **비즈니스 로직 (Business Logic)**         | 애플리케이션의 핵심 규칙/기능을 수행하는 부분  | - 도메인 모델<br>- 서비스 계층<br>- 유스케이스<br>- 엔티티(Entity), DTO                   |

---

## 2. **프론트엔드 구조/설계**

| 주요 개념                                | 설명                                        | 함께 공부하면 좋은 개념                                                     |
| ---------------------------------------- | ------------------------------------------- | --------------------------------------------------------------------------- |
| **Container vs Presentational 컴포넌트** | 비즈니스 로직과 UI 로직을 나누는 React 설계 | - 관심사 분리<br>- 컴포넌트 책임 분리<br>- Hooks 구조화                     |
| **상태 관리 구조 (Zustand, Redux, etc)** | 상태를 어디서/어떻게 다룰지 정의            | - 비즈니스 로직 위치<br>- Store 분리 전략<br>- Selector, middleware         |
| **API Layer 분리**                       | API 요청을 별도 레이어로 나눔               | - Axios 커스텀 인스턴스<br>- Query Hook abstraction<br>- Service Layer 구조 |

---

## 4. **실무 적용 관점 (실제로 설계할 때 유용한 개념)**

| 실무에서 접하는 개념    | 연관 개념                                     |
| ----------------------- | --------------------------------------------- |
| 서비스 레이어 설계      | 비즈니스 로직 분리, 추상화 계층, 관심사 분리  |
| 공통 API 오류 처리      | Axios 인터셉터, API 추상화 계층               |
| 유저 인증 흐름          | 상태 관리 분리, 관심사 분리, 로직 단위 모듈화 |
| 파일 구조 설계          | 기능/도메인 기반 구조 → 관심사 분리           |
| 테스트 설계 (단위/통합) | 비즈니스 로직과 UI 로직 분리 필요             |
