# TIL | 2025.04.29

## 주간 목표

-   계획한 미라클 모닝 자리잡기
-   스픽 챌린저
-   루틴 확립하기
    -   충분한 수면을 가져가려고 노력하기 (TIL 공유를 조금 늦은 시간에 진행하고 2시에 취침하고 7시에 기상해서 운동까지 해버리니 너무 피곤함)
    -   일어나서 런닝하는건 지양한다. (피곤해지기 때문에)
    -   런닝은 하루 일과를 마무리하고 근력운동 전 또는 후에 진행한다.
    -   스픽을 운동하고 씻고 딱 한개만실시한다.
    -   최대한 이동하는 시간을 활용해서 진행한다.(다 남는 시간이다.)
    -   하루에 최소 알고리즘 하나를 풀도록 노력하기
    -   책은 내용을 암기하는게 아니다 가볍게 흘러가듯이 읽자
-   [벨로그](https://velog.io/@pigpgw/%EB%82%98%EC%9D%98-%EA%B0%9C%EB%B0%9C-%EC%84%B1%EC%9E%A5-%EC%A0%84%EB%9E%B5-%EC%83%9D%EA%B0%81%ED%95%98%EB%8A%94-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A1%9C-%EB%82%98%EC%95%84%EA%B0%80%EA%B8%B0)에 작성한 것들 습관화하기
-   기존 코드에서 타입만을 고민하는게 중요한게 아니다.
-   기존 컴포넌트 트리의 구조를 먼저 생각해 보는게 우선이다.
-   기존 코드의 타입을 올바르게 이해하기 위해선 개인적인 생각으로 필요한것들
    -   해당 컴포넌트의 역할
    -   파라미터로 넘어오는 데이터가 의미하는 것 또는 용도
    -   프로젝트에서 해당 타입의 의미?
    -   어떤 도메인인가?

### 중요 일정

-   5월 10일 토요일 12:40 : 정보처리기사 필기
-   5월 13일 ~ 5월 24일 싸피 에세이 제출
-   5월 24일 토요일 싸피 코테
-   5월 31일 토요일 10:00 : sqld 시험 (광주 조선대학교부속중학교)

### 오늘 진행 순서 예정

-   [x] 아침 운동 : 팔굽 100개 + 코어 5분
-   [x] 스픽
-   [x] 매일 매일 면접 질문 (이벤트 루프)
-   [x] 책 읽기 (아이템 42 any 대싡 unkown)
-   [x] 블로그 하나 읽기 (신입개발자 포트폴리오 작성법)[https://velog.io/@yoosion030/%EC%8B%A0%EC%9E%85%EA%B0%9C%EB%B0%9C%EC%9E%90%ED%8F%AC%ED%8A%B8%ED%8F%B4%EB%A6%AC%EC%98%A4%EC%9E%91%EC%84%B1%EB%B2%95]
-   [x] 정처기 필기 2021 년 2회
-   [] 알고리즘
-   [] 유익한 유튜브 시청하기
-   [] 주시 작업

    -   원래 Home page에서 불러오던 시위 데이터를 카카오맵에서 호출하게 뺏는데 올바른가?
    -   캐싱되는 문제는?
    -   오늘자 시위 정보가 없으면?
    -   스토리북
    -   테스트
    -   컴포넌트
        -   컴포넌트 설계 다시 생각하기
    -   리엑트 쿼리
        -   폴링을 위해 사용중인 리액트 쿼리 사용 올바른가
    -
    -   에러처리
        -   에측 가능한 에러
            -   응원하기 안될때
                -   해당 시위가 오늘 날짜 시위가 아니라서 안될때 또는 서버에서 시위 정보가 없어서
            -   시위 데이터가 갱신이 안됬을때
                -   캐싱 문제로 시위 데이터가 오늘 시위 데이터가 아닐때
            -   시위 데이터를 못불러 왔을때\
            -   오늘 시위데이터가 없을때
        -   예측 불가능한 에러

-   [] 스마게 작업
    -   [] 알람 구현하기
-   [] 운동
-   [] 강의 수강
    -   알고리즘 :
    -   TS :
    -   Next :

---

# TIL

## 오늘 진행 순서 예정

## 매일 매일 면접 질문 (이벤트 루프)

-   자바스크립트의 이벤트 루프는 자바스크립트가 싱글 스레드 기반 언어임에도 불구하고 비동기 작업을 처리할 수 있게 해주는 중요한 메커니즘입니다.
-   자바스크립트는 기본적으로 한 번에 하나의 작업만 처리할 수 있습니다. 하지만 이벤트 루프가 콜 스택과 태스크 큐를 매개하면서 비동기 작업이 완료되면 그 결과를 처리할 수 있게 도와줍니다. 여기서, 콜 스택은 현재 실행 중인 함수들이 쌓이는 곳이고, 태스크 큐는 비동기 작업이 완료될 때 그 결과를 대기시키는 곳입니다.
-   이벤트 루프의 동작을 설명하기 위해 간단한 예로 setTimeout(callback, 0)을 들어 보겠습니다. setTimeout(callback, 0)을 호출하면, 이 콜백 함수는 바로 실행되는 것이 아니라 웹 API에 의해 타이머가 설정되고, 그 타이머가 0밀리초 후에 만료되면 콜백 함수가 태스크 큐에 추가됩니다. 그 후 콜 스택이 비어 있는 시점에 이벤트 루프가 태스크 큐에서 대기 중인 callback을 꺼내서 실행합니다.
-   따라서 setTimeout(callback, 0)을 호출해도 현재 실행 중인 모든 동기 작업들이 완료된 후에야 그 콜백이 실행됩니다. 이 때문에 setTimeout(callback, 0)을 사용하면 코드의 실행을 다음 이벤트 루프 사이클로 미뤄집니다.

## 책 읽기

## 블로그 하나 읽기 (신입개발자 포트폴리오 작성법)[https://velog.io/@yoosion030/%EC%8B%A0%EC%9E%85%EA%B0%9C%EB%B0%9C%EC%9E%90%ED%8F%AC%ED%8A%B8%ED%8F%B4%EB%A6%AC%EC%98%A4%EC%9E%91%EC%84%B1%EB%B2%95]

### 자기소개

-   가치관은 짧게 요약하고 성과와 함게 엮기

### 프로젝트

-   제가 알아보는 키워드가 아닌 처음 보는 사람들도 알아볼수 있게 수정하고, 프로젝트에 대한 사진 첨부를 추가
-   또한 면접 때 프로젝트에 대한 심화적인 이야기를 하기 위해 트러블 슈팅 섹션도 추가하니 훨씬 높은 합격률을 보였습니다!
-   트러블 슈팅은 크게 문제 → 해결 방법 → 이전 코드와 비교 → 알게 된 점

### 요약

-   채용 담당자는 당신의 프로젝트를 처음 본다. 본인이 주로 사용했던 키워드보다는 처음 본 사람도 이해할 수 있게 사진 첨부를 하자.
-   신입 기준으로 프로젝트에 트러블슈팅 기재는 필수라고 생각한다. 왜냐하면 채용담당자 입장에서는 어떤 사고방식을 가지고 있으며, 어떻게 문제를 해결하는지 알고 싶어하기 때문이다. 그렇기 때문에 문제 → 과정 → 해결 → 결과 순으로 트러블 슈팅을 작성하자.
-   포트폴리오를 많은 사람들에게 공유하여 프로젝트에 대한 피드백을 받자

## 알고리즘

### 코테 적용 방법

-   Step1 문제 이해하기
    -   문제를 제대로 읽기
    -   제약조건 읽기
        -   효율성 테스트 10^8 넘으면 안됨
        -   원소 값의 범위
            -   int === 4byte => 1bit는 부호 31bit는 수 표현 -2^31 ~ 2^31 + 1
                -   2의 31승은 10의 9승 그러면 인트형 변수에 저장 불가
-   Step2 접근 방법
    -   직관적으로 생각하기
        -   보통 완전 탐색으로 시작
        -   문제 상황을 단순화 하여 생각하기
        -   문제 상황을 극한화 하여 생각하기
    -   자료구조와 알고리즘 활용
        -   Step1 문제이해 에서 파악한 내용을 토대로 어떤 자료구조를 사용하는게 가장 적합한지 결정
        -   대놓고 특정 자료구조와 알고리즘을 묻는 문제도 많음
        -   자료구조에 따라 선택할 수 있는 알고리즘을 문제에 적용
    -   메모리 사용
        -   시간복잡도를 줄이기 위해 메모리를 사용하는 방법
        -   대표적으로 해시테이블

### 대표 알고리즘

-   O(1): Operation push and pop on Stack
-   O(log n): Binary Tree
-   O(n): for loop
-   O(n×log n): Quick Sort, Merge Sort, Heap Sort
-   O(n2): Double for loop, Insert Sort, Bubble Sort, Selection Sort
-   O(2n): Fibonacci Sequence

---

## 유익한 유튜브 시청하기

## 강의 수강

## 정처기 21년 2회

-   GoF

    -   bridge pattern : 구현부에서 추상층을 분리형 각자 독립적으로 확장이 가능하게 하는 패턴
    -   Adapter patter : 기존에 구현되어 있는 클래스에 기능 발생 시 기존 클래스를 재사용할 수 있도록 중간에서 맞춰주는 역할을 한다.

-   소프트웨어 아키텍처 설계이 시스템 품질 속성
    -   가용성
    -   변경 용이성
    -   성능
    -   봉나성
    -   사용편의성
    -   시험용이성
-   CASE 원천기술 : 소프트웨어 개발에 컴퓨터 기술을 활용하여 효율성과 품질을 향상시키는 방법론
    -   구조적 기법, 프로토타이핑 기숭, 자동프로그래밍 기술, 정보 저장소 기술, 분산 처리 기술
-   CASE: 시스템 개발과정의 일부 또는 전체를 자동화시킨 것

    -   소프트웨어 생명주기의 전체 단계를 연결해 주고 자동화해주는 통합된 도구를 제공
    -   소프트웨어, 하드웨어, 데이터베이스, 테스트 등을 통합하여 소프트웨어를 개발하는 환경을 제공

-   상위 CASE: 요구 분석과 설계 단계를 지원

    -   모델들 사이의 모순검사 기능
    -   모델의 오류 검증 기능

-   자료흐름도 작성 기능

-   하위 CASE: 코드를 작성하고 테스트하며 문서화하는 과정 지원

    -   원시코드 생성 기능

-   통합 CASE: 소프트웨어 개발 주기 전체과정을 지원

-   UML 다이어그램

    -   구조적 다이어그램 : 클객컴배복패
    -   행위 다이어그램 : 유시커상활타상

-   힙 정렬

    -   힙정렬 최적, 평균, 최악 수행 시간 : 0(nlon2n)

-   형상 감사: 기준선의 무결성을 평가하기 위해 확인, 검증, 검열 과정을 통해 공식적으로 승인하는 작업

    -   체크인: 체크아웃한 파일의 수정을 완료한 후 저장소의 파일을 새로운 버전으로 갱신

-   저작권 관리구성요소(DRM)

    -   콘텐츠 분배자: 암호화된 콘텐츠를 유통하는곳/사람
    -   패키저: 콘텐츠를 메타데이터와 함께 배포가능한 형태로 묶어 암호화
    -   클리어링 하우스: 키 관리 및 라이센스 발급 관리
    -   DRM 컨트롤러: 배포된 콘텐츠의 이용권한을 통제

-   EAI 구축 유형

    -   Point-to-Point - 가장 기본적인 애플리케이션 통합 방식으로, 애플리케이션을 1:1 로 연결
        변경 및 재사용이 어려움

    -   Hub & Spoke

        -   단일 접점인 허브를 통해 데이터를 전송하는 중앙 집중형 방식
        -   확장 및 유지 보수가 용이하지만 허브 장애 발생 시 시스템 전체에 영향

    -   Message Bus (ESB 방식)

        -   애플리케이션 사이에 미들웨어를 두어 처리하는 방식
        -   확장성이 뛰어나며 대용량 처리가 가능

    -   Hybrid

        -   그룹 내에서는 Hub & Spoke 방식, 그룹 간에는 Message 방식 사용

    -   SQL 문에서 SELECT에 대한 설명으로 옳지않은 것은?
        -   FROM 절에는 질의에 의해 검색될 데이터들을 포함하는 테이블명을 기술한다.
        -   검색결과에 중복되는 레코드를 없애기 위해서는 SELECT 명령 뒤에 'DISTINCT'키워드를 사용한다.
        -   HAVING 절은 GROUP BY 절과 함께 사용되며, 그룹에 대한 조건을 지정한다.
        -   ORDER BY 절은 특정 속성을 기준으로 정렬하여 검색할 때 사용한다.

-   개체 무결성 : 릴레이션에서 기본키를 구성하는 속성은 널(Null)값이나 중복값을 가질 수 없다
-   참조 무결성 : 외래키 값은 NULL이거나 참조 릴레이션의 기본키 값과 동일해야함
-   도메인 무결성 : 특정 속성의 값이 그 속성이 정의된 도메인에 속한 값이어야 한다는 규정

-   보안의 3요소 : 기밀성(Confidentiality) ,무결성(Integrity), 가용성(Availability)
    -   데이터 기밀성은 공격자가 데이터를 볼 수 없게 보호
    -   데이터의 무결성은 앞서 말한 변경, 삽입, 삭제, 재연 등으로부터 정보를 보호
-   병행제어 기법의 종류

    -   로킹 기법
    -   타임 스탬프 기법
    -   최적 병행 수행 기법 (검증 기법, 확인 기법, 낙관적 기법)
    -   다중 버전 기법

-   속성(attribute, 어트리뷰트)의 수 = 차수(degree, 디그리)
-   튜플(tuple)의 수 = 카니널리티(cardinality)

-   ER

    1.  개체타입 – 사각형
    2.  속성 - 원형
    3.  관계타입 - 마름모

-   CSMA/CA(Carrier-sense multiple access with collision avoidance) "충돌 방지" : 무선 랜에서 데이터 전공 시, 매체가 비어있음을 확인한 후 충돌을 회피하기 위해 임의 시간을 기다린 후 데이터를 전송하는 방식. 네트워크에 데이터의 전송이 없는 경우라도 동시 전송에 의한 충돌에 대비해 확인 신호를 전송한다.

-   소프트웨어 프레임워크의 특징

    -   모듈화
    -   재사용성
    -   확장성
    -   제어의 역 흐름

-   리눅스 Bash 쉘(Shell)

    -   리눅스에서 변수 출력은 echo $변수명이다.
    -   export가 매개변수 없이 쓰일 경우 현재 설정된 환경변수들이 출력된다.
    -   변수를 export 시키면 전역(Global)변수처럼 되어 끝까지 기억된다.

-   TCP 프로토콜
    -   패킷의 전송 및 오류를 제거
    -   세그먼트의 오쥬 전송 및 오류를 제고
    -   흐름 제어(Flow Control)의 기능을 수행한다.
    -   전이중(Full Duplex) 방식의 양방향 가상회선을 제공한다.
    -   전송 데이터와 응답 데이터를 함께 전송할 수 있다.
-   stdlib.h : C 언어의 표준 라이브러리로, 문자열 변환, 사 난수 생성, 동적 메모리 관리 등의 함수들을 포함하고 있다.

-   네트워크 계층

    -   패킷을 발신지로부터 최종 목적지까지 전달하는 책임을 진다.
    -   패킷에 발신지와 목적지의 논리 주소를 추가한다.
    -   라우터 또는 교환기는 패킷 전달을 위해 경로를 지정하거나 교환 기능을 제공한다.

-   CBD 방법론의 개발 공정

    1. 분석 → 사용자 요구사항 정의서, 유스케이스 명세서, 요구사항 추적표
    2. 설계 → 클래스 설계서, UI(사용자 인터페이스) 설계서, 아키텍처 설계서, 인터페이스 설계서, 컴포넌트 설계서, 데이터베이스 설계서
    3. 구현 → 프로그램 코드, 단위시험 결과서, 데이터베이스 테이블
    4. 테스트(시험) → 통합시험 결과서, 시스템시험 결과서, 사용자 지침서, 운영자 지침서, 시스템 설치 결과서, 인수시험 시나리오, 인수시험 결과서

-   소프트웨어의 생명 주기 동안 필요한 소프트웨어 제품의 획득, 공급, 개발, 운영, 유지보수 등으로 구성된다.

-   해시

    -   단방향
    -   SHA, MD5,N-NASH,SNEFRU

-   IPSec : IP계층(3계층)에서 무결성과 인증 보장하는 인증헤더와 기밀성 보장하는 암호화 이용해 양 종단 구간에 보안 서비스 제공하는 터널링 프로토콜
-   서버에 열린 포트 정보를 스캐닝해서 보안취약점을 찾는데 사용하는 도구는? : nmap
-   서로 다른 네트워크 대역에 있는 호스트들 상호간에 통신할 수 있도록 해주는 네트워크 장비는? : 라우터

-   암호화 키와 복호화 키가 동일한 암호화 알고리즘은?

    -   암호화 기법은 단방향인 HASH기법과 양뱡향인 공개키 기법과 개인키 기법이 있다.

    1. RSA는 공개키 암호화 기법으로 암호화 키는 공개키를 복호화 키는 비밀키를 사용한다.
    2. AES는 개인키 암호화 기법으로 암호화 키와 복호화 키가 동일하다.
    3. DSA는 미국의 전자서명 표준이다.
    4. ECC는 공개키 암호화 기법이다.

### 공부할거

-   리엑트 컴포넌트 렌더링 개발도구 통해서 성능 측정방법
-   JS 엔진 구조 (V8, SpiderMonkey)
-   인터프리터 vs 컴파일러
-   JIT 컴파일러 (Just-In-Time Compiler)
-   이벤트 루프, Call Stack, Task Queue
-   공통 컴포넌트 설계
-   rest
-   기본 타입 확장
-   공통 버튼 컴포넌트 만드는데 어떻게 해야할지 모르겠음,
-   리엑트에서의 단일 책임 원칙
-   리엑트 쿼리 사람답게 쓰기
-   suspense

-   작업

    -   next에서 fetch params next invalidate

-   패키지 매니저
    -   package.json
        -   ^ 메이저 버전 이상 아무거나
    -   packagelock.json
        -   정확한 현재 프로젝트에 설치된 라이브러리 버전 명시
-   테스트와 디버그
    -   테스트는 오류를 찾는 작업
    -   디버깅은 오류를 수정하는 작업
-   시스템 카탈로그
    -   DBMS가 스스로 생성하고 유지하기 때문에 INSERT,DELETE, UPDATE문으로 시스템 카탈로그를 갱신하는 것은 허용되지 않음

---

# 프론트엔드 아키텍처

## 뷰 로직과 비즈니스 로직의 분리

### 목적

-   **컴포넌트 재사용성 증가**
-   **유지보수성 향상**
-   **테스트 용이성 확보**

### 예시

#### 뷰 로직 (UI 컴포넌트)

```tsx
const ProductCard = ({ product, onBuy }: Props) => {
    return (
        <div>
            <p>{product.name}</p>
            <button onClick={() => onBuy(product.id)}>구매</button>
        </div>
    );
};
```

#### 비즈니스 로직 (커스텀 훅)

```ts
const useBuyProduct = () => {
    const mutation = useMutation((productId) => buyAPI(productId));
    return mutation;
};
```

### 좋은 구조

-   UI: 입력 → 출력에 집중 (props 기반)
-   로직: 상태 관리, 요청 처리 등은 **hooks나 service 파일로 분리**

## 공부하고 싶은 키워드

## 1. **소프트웨어 설계 원칙 관련**

| 주요 개념                                  | 설명                                           | 함께 공부하면 좋은 개념                                                                   |
| ------------------------------------------ | ---------------------------------------------- | ----------------------------------------------------------------------------------------- |
| **관심사의 분리 (Separation of Concerns)** | 기능/책임/영역을 나눠서 복잡도를 낮추는 원칙   | - SRP (단일 책임 원칙)<br>- 모듈화(Modularity)<br>- MVC/MVVM 패턴<br>- 레이어드 아키텍처  |
| **추상화 계층 (Abstraction Layer)**        | 하위 로직을 숨기고 필요한 기능만 노출하는 구조 | - 캡슐화<br>- 인터페이스 / 추상 클래스<br>- 레이어드 아키텍처<br>- 의존성 역전 원칙 (DIP) |
| **비즈니스 로직 (Business Logic)**         | 애플리케이션의 핵심 규칙/기능을 수행하는 부분  | - 도메인 모델<br>- 서비스 계층<br>- 유스케이스<br>- 엔티티(Entity), DTO                   |

---

## 2. **프론트엔드 구조/설계**

| 주요 개념                                | 설명                                        | 함께 공부하면 좋은 개념                                                     |
| ---------------------------------------- | ------------------------------------------- | --------------------------------------------------------------------------- |
| **Container vs Presentational 컴포넌트** | 비즈니스 로직과 UI 로직을 나누는 React 설계 | - 관심사 분리<br>- 컴포넌트 책임 분리<br>- Hooks 구조화                     |
| **상태 관리 구조 (Zustand, Redux, etc)** | 상태를 어디서/어떻게 다룰지 정의            | - 비즈니스 로직 위치<br>- Store 분리 전략<br>- Selector, middleware         |
| **API Layer 분리**                       | API 요청을 별도 레이어로 나눔               | - Axios 커스텀 인스턴스<br>- Query Hook abstraction<br>- Service Layer 구조 |

---

## 4. **실무 적용 관점 (실제로 설계할 때 유용한 개념)**

| 실무에서 접하는 개념    | 연관 개념                                     |
| ----------------------- | --------------------------------------------- |
| 서비스 레이어 설계      | 비즈니스 로직 분리, 추상화 계층, 관심사 분리  |
| 공통 API 오류 처리      | Axios 인터셉터, API 추상화 계층               |
| 유저 인증 흐름          | 상태 관리 분리, 관심사 분리, 로직 단위 모듈화 |
| 파일 구조 설계          | 기능/도메인 기반 구조 → 관심사 분리           |
| 테스트 설계 (단위/통합) | 비즈니스 로직과 UI 로직 분리 필요             |
