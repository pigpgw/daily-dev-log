# TIL | 2025.05.06

## 주간 목표

-   계획한 미라클 모닝 자리잡기
-   스픽 챌린저
-   루틴 확립하기
    -   충분한 수면을 가져가려고 노력하기 (TIL 공유를 조금 늦은 시간에 진행하고 2시에 취침하고 7시에 기상해서 운동까지 해버리니 너무 피곤함)
    -   일어나서 런닝하는건 지양한다. (피곤해지기 때문에)
    -   런닝은 하루 일과를 마무리하고 근력운동 전 또는 후에 진행한다.
    -   스픽을 운동하고 씻고 딱 한개만실시한다.
    -   최대한 이동하는 시간을 활용해서 진행한다.(다 남는 시간이다.)
    -   하루에 최소 알고리즘 하나를 풀도록 노력하기
    -   책은 내용을 암기하는게 아니다 가볍게 흘러가듯이 읽자
-   [벨로그](https://velog.io/@pigpgw/%EB%82%98%EC%9D%98-%EA%B0%9C%EB%B0%9C-%EC%84%B1%EC%9E%A5-%EC%A0%84%EB%9E%B5-%EC%83%9D%EA%B0%81%ED%95%98%EB%8A%94-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A1%9C-%EB%82%98%EC%95%84%EA%B0%80%EA%B8%B0)에 작성한 것들 습관화하기
-   기존 코드에서 타입만을 고민하는게 중요한게 아니다.
-   기존 컴포넌트 트리의 구조를 먼저 생각해 보는게 우선이다.
-   기존 코드의 타입을 올바르게 이해하기 위해선 개인적인 생각으로 필요한것들
    -   해당 컴포넌트의 역할
    -   파라미터로 넘어오는 데이터가 의미하는 것 또는 용도
    -   프로젝트에서 해당 타입의 의미?
    -   어떤 도메인인가?

### 중요 일정

-   5월 10일 토요일 12:40 : 정보처리기사 필기
-   5월 13일 ~ 5월 24일 싸피 에세이 제출
-   5월 24일 토요일 싸피 코테
-   5월 31일 토요일 10:00 : sqld 시험 (광주 조선대학교부속중학교)

### 오늘 진행 순서 예정

-   [x] 스픽
-   [x] 매일 매일 면접 질문(props와 state)
-   [x] 블로그 작성(https://velog.io/@pigpgw/%ED%83%80%EC%9E%85%EC%9D%84-%ED%98%BC%EB%82%B4%EC%A3%BC%EB%A0%A4%EB%8B%A4-%EB%82%B4%EA%B0%80-%ED%98%BC%EB%82%9C-%EC%9D%B4%EC%95%BC%EA%B8%B0)
-   [x] 알고리즘
    -   [x] https://leetcode.com/problems/shortest-path-in-binary-matrix/description/
    -   [x] https://leetcode.com/problems/number-of-islands/
-   [x2] 정처기 필기 2021 년 3회
-   [] 주시 작업

    -   캐싱되는 문제는?
    -   오늘자 시위 정보가 없으면?
    -   스토리북
    -   테스트
    -   컴포넌트
        -   컴포넌트 설계 다시 생각하기
    -   에러처리
        -   에측 가능한 에러
            -   응원하기 안될때
                -   해당 시위가 오늘 날짜 시위가 아니라서 안될때 또는 서버에서 시위 정보가 없어서
            -   시위 데이터가 갱신이 안됬을때
                -   캐싱 문제로 시위 데이터가 오늘 시위 데이터가 아닐때
            -   시위 데이터를 못불러 왔을때\
            -   오늘 시위데이터가 없을때
        -   예측 불가능한 에러

-   [] 스마게 작업
    -   [] 알람 구현하기
-   [] 운동

---

# TIL

## 오늘 진행 순서 예정

## 매일 매일 면접 질문(props와 state)

> props는 부모 컴포넌트가 자식 컴포넌트에 전달하는 데이터, props는 읽기 전용으로 자식 컴포넌트는 props를 수정할 수없다.

### state

-   컴포넌트 내부에서 관리되는 데이터
-   동적으로 변경 가능
-   렌더링에 영향을 미침
-   state 변경시 컴포넌트는 다시 렌더링되며, UI가 업데이트됨
-   state는 주로 사용자 입력이나 네틍워크 요청의 응답에 따라 변하는 데이터를 관리할 때 사용

### props가 자식 컴포넌트에서 변하지 않는 이유

-   리액트의 단방향 데이터 흐름 원칙
-   props는 읽기 전용, 부모 컴포넌트에서 전달된 값이 자식 컴포넌트에서 임의로 변경되지 않음(이로 인해, 특정 상태가 어디서 어떻게 변했는지를 예측할 수 있어 버그 발생 가능성을 줄이고 디버깅을 쉽게 할 수 있음)

### 만약 자식 컴포넌트에서 부모 컴포넌트로부터 받은 props를 변경해야 한다면 어떻게 해야할까

-   자식 컴포넌트에게 상태 변경 함수를 전달해야함

## 정처기 필기 2021 년 3회 90,70,75,40,55 => 66점

### 1과목

-   럼바우 객체지향 분석 기법중 자료 흐름도(DFD)를 주로 이용하는 것
    -   객체 모델링 = 객체 다이어그램
    -   동적 모델링 = 상태 다이어그램
    -   기능 모델링 = 자료 흐름도
-   소프트웨어 아키텍처와 관련한 설명
    -   파이프 필터 아키텍처에서는 데이터는 파이프를 통해 단방향으로 흐르고 필터 이동시 오버헤드가 발생될 수 있음
-   스택
    -   오버플로우 : 스택 공간이 가득 찼을 때 하나의 데이터를 더 넣으려고 하는 경우, 스택 오버플로우가 일어나고 프로그램에 오류 야기
    -   언더플로우 : 스택 공간에 데이터가 없는데 프로그램에서 데이터를 꺼내려고 하는 경우, 스택 언더 플로우가 일어나며 프로그램에 오류를 야기
-   테스트
    -   단위 테스트 : 개별 모듈을 테스트
    -   통합테스트 : "모듈 간의" 호환성
    -   시스템 테스트 : 완전한 시스템에 대해 수행하는 테스트
    -   인수 테스트 : 실제 환경에서 사용자가 참여하는 테스트
-   소프트웨어 품질 목표

    -   이식성 : 다양한 하드웨어 환경에서도 운용 가능하도록 쉽게 수정될 수 있는 능력
    -   효율성 : 최소의 작업으로 요구되는 기능을 수행하는 정도
    -   사용 용이성 : 소프트웨어를 쉽게 사용할 수 있는 정도
    -   정확성 : 사용자의 요구사항을 충족시키는 정도

-   테스트 수행 도구 : 자료 흐름도, 기능 테스트, 입력 도메인 분석, 랜덤 테스트
-   스터브와 드라이버는 통합 테스트 시 사용되는 것

-   데이터베이스의 무결성 규정

    -   개체무결성 : 모든 테이블이 기본키로 선택된 컬럼을 가져야함
    -   참조 무결성 : 참조 관계의 두 테이블의 데이터가 항상 일관된 값을 갖도록 유지하는 것
    -   도메인 무결성 : 테이블에 존재하는 필드의 무결성을 보장하는 것

-   물리적 데이터베이스 설계 : 논리적 설계에 기반하여 설계

    -   효율적인 방법으로 데이터를 저장하는 것
    -   트랜잭션 처리량과 응답시간, 디스크 용량 등을 고려 => 물리적 요소 고려
    -   저장 레코드의 형식, 순서, 접근 경로와 같은 정보를 사용 => 물리적 요소
    -   트랜잭션의 인터페이스를 설계 ==> 이것은 논리적 성계에서 인터페이스를 사용자의 입장에서 편리하도록 성계 하는 것

-   관계형 데이터베이스에서 다음 설명에 해당하는 키
    -   슈퍼키 : 유일성을 만족하는 속성 또는 속성들의 집합
    -   후보키 : 유일성과 최소성을 만족하는 속성 또는 속성들의 집합
    -   대체키 : 기본키로 선택되지 못한 후보키
    -   외래키 : 다른 릴레이션의 기본키를 차조하는 속성 또는 속성들의
-   SQL
    -   DDL(정의)
        -   CREATE
        -   ALTER
        -   DROP
    -   DML(조작)
        -   SELECT
        -   INSERT
        -   DELETE
        -   UPDATE
    -   DCL(제어)
        -   COMMIT
        -   ROLLBACK
        -   GRANT
        -   REVOKE
-   IP Adress

    -   A class에 속하는 ip 주소 범위: 0.0.0.0 ~ 127.255.255.255
    -   B class에 속하는 ip 주소 범위: 128.0.0.0 ~ 191.255.255.255
    -   C class에 속하는 ip 주소 범위: 192.0.0.0 ~ 223.255.255.255

-   TCP 헤더에 있는 Window size는 16비트로 2^16 = 65535byte = 64KB

-   모듈화
    -   모듈 수가 증가하면, 각 모듈은 작아지고 단순해집니다.
    -   모듈 간 인터페이스는 많아질 수 있지만, 각 모듈의 책임이 작아져 복잡도가 줄고 유지보수성이 좋아집니다.
-   페이지 교체 알고리즘

    -   OPT
    -   FIFO
    -   LRU
    -   LFU
    -   MFU
    -   NUR

-   C언어 변수 선언
    -   사용 가능 : 영문(대문자, 소문자),숫자, \_
    -   불가능 : 첫자리 숫자 사용X, 영어x
-   파일 디스크립터
    -   파일마다 따로 있으며 시스템에 따라 다른 구조를 가질 수 있다.
    -   파일 시스템에서 따로 관리하므로 사용자는 직접 참조할 수 없다.
    -   파일 이름, 위치, 파일 구조, 보조기억장치의 유형, (텍스트/이진/기계어/실행 파일 등)파일 유형, 시간, 액세스 등의 정보를 담고 있다.
-   침입탐지 시스템(IDS)
    -   이상탐지 : 시정상적인 행위나 자원의 사용이 감지되면 알려줌
    -   오용탐지 : 미리 입력해둔 공격 패턴이 감지되면 이를 알려줌
-   PaaS-TA : 국내 IT 서비스 경쟁력 강화를 목표로 개발되었으며 인프라 제어 및 관리 환경, 실행 환경, 개발 환경, 서비스 환경, 운영환경으로 구성되어 있는 개방형 클라우드 컴퓨팅 플랫폼은?
-   정보 보안을 위한 접근 제어(Access Control)
    -   적절한 권한을 가진 인가자만 특정 시스템이나 정보에 접근할 수 있도록 통제하는 것이다.
    -   시스템 및 네트워크에 대한 접근 제어의 가장 기본적인 수단은 IP와 서비스 포트로 볼 수 있다.
    -   네트워크 장비에서 수행하는 IP에 대한 접근 제어로는 관리 인터페이스의 접근제어와 ACL(Access Control List) 등 있다.
-   Cocomo model
    -   Organic: 5만 라인 이하의 프로젝트에 적합, 소규모 팀이 개발에 사용
    -   Semidetached: 30만 라인 이하의 프로젝트에 적합, 트랜잭션 처리시스템 등
    -   Embeded: 30만 라인 이상의 프로젝트에 적합, 하드웨어가 포함된 실스간 시스템 등
-   spiral model = 나선형 모형, 점진적 모형

    1. 대규모
    2. 개발순서= 계획및 정의 - 위험 분석 - 공학적 개발 - 고객 평가
    3. sw개발하면서 발생할 수 있는 위험 관리 및 최소화 목적
       1&2&3의 경우 spiral model의 올바른 특징
    4. 여러번의 개발 과정을 거쳐 점진적으로 개발과정이 반복되므로 누락되거나 추가된 요구사항 첨가가능. 한번만 수행 x

-   시스템 인증
    -   토큰 기반 인증 : 하드웨어와 소프트웨어의 토큰 장치를 사용하는 인증 기법, 하드웨어 장치는 스마트카드를 사용, 소프트웨어 장치는 개인 식별번호를 사용하는 강력한 인증 방법
    -   SSO 인증 : 여러 시스템 중 하나의 시스템에 인증을 성공하면 다른 시스템의 접근 권한도 모두 얻는 방식

### 할거

-   리엑트 컴포넌트 렌더링 개발도구 통해서 성능 측정방법
-   JS 엔진 구조 (V8, SpiderMonkey)
-   인터프리터 vs 컴파일러
-   JIT 컴파일러 (Just-In-Time Compiler)
-   이벤트 루프, Call Stack, Task Queue
-   공통 컴포넌트 설계
-   rest
-   기본 타입 확장
-   공통 버튼 컴포넌트 만드는데 어떻게 해야할지 모르겠음,
-   리엑트에서의 단일 책임 원칙
-   리엑트 쿼리 사람답게 쓰기
-   suspense

-   작업

    -   next에서 fetch params next invalidate

-   패키지 매니저
    -   package.json
        -   ^ 메이저 버전 이상 아무거나
    -   packagelock.json
        -   정확한 현재 프로젝트에 설치된 라이브러리 버전 명시

---

# 프론트엔드 아키텍처

## 뷰 로직과 비즈니스 로직의 분리

### 목적

-   **컴포넌트 재사용성 증가**
-   **유지보수성 향상**
-   **테스트 용이성 확보**

### 예시

#### 뷰 로직 (UI 컴포넌트)

```tsx
const ProductCard = ({ product, onBuy }: Props) => {
    return (
        <div>
            <p>{product.name}</p>
            <button onClick={() => onBuy(product.id)}>구매</button>
        </div>
    );
};
```

#### 비즈니스 로직 (커스텀 훅)

```ts
const useBuyProduct = () => {
    const mutation = useMutation((productId) => buyAPI(productId));
    return mutation;
};
```

### 좋은 구조

-   UI: 입력 → 출력에 집중 (props 기반)
-   로직: 상태 관리, 요청 처리 등은 **hooks나 service 파일로 분리**

## 공부하고 싶은 키워드

## 1. **소프트웨어 설계 원칙 관련**

| 주요 개념                                  | 설명                                           | 함께 공부하면 좋은 개념                                                                   |
| ------------------------------------------ | ---------------------------------------------- | ----------------------------------------------------------------------------------------- |
| **관심사의 분리 (Separation of Concerns)** | 기능/책임/영역을 나눠서 복잡도를 낮추는 원칙   | - SRP (단일 책임 원칙)<br>- 모듈화(Modularity)<br>- MVC/MVVM 패턴<br>- 레이어드 아키텍처  |
| **추상화 계층 (Abstraction Layer)**        | 하위 로직을 숨기고 필요한 기능만 노출하는 구조 | - 캡슐화<br>- 인터페이스 / 추상 클래스<br>- 레이어드 아키텍처<br>- 의존성 역전 원칙 (DIP) |
| **비즈니스 로직 (Business Logic)**         | 애플리케이션의 핵심 규칙/기능을 수행하는 부분  | - 도메인 모델<br>- 서비스 계층<br>- 유스케이스<br>- 엔티티(Entity), DTO                   |

---

## 2. **프론트엔드 구조/설계**

| 주요 개념                                | 설명                                        | 함께 공부하면 좋은 개념                                                     |
| ---------------------------------------- | ------------------------------------------- | --------------------------------------------------------------------------- |
| **Container vs Presentational 컴포넌트** | 비즈니스 로직과 UI 로직을 나누는 React 설계 | - 관심사 분리<br>- 컴포넌트 책임 분리<br>- Hooks 구조화                     |
| **상태 관리 구조 (Zustand, Redux, etc)** | 상태를 어디서/어떻게 다룰지 정의            | - 비즈니스 로직 위치<br>- Store 분리 전략<br>- Selector, middleware         |
| **API Layer 분리**                       | API 요청을 별도 레이어로 나눔               | - Axios 커스텀 인스턴스<br>- Query Hook abstraction<br>- Service Layer 구조 |

---

## 4. **실무 적용 관점 (실제로 설계할 때 유용한 개념)**

| 실무에서 접하는 개념    | 연관 개념                                     |
| ----------------------- | --------------------------------------------- |
| 서비스 레이어 설계      | 비즈니스 로직 분리, 추상화 계층, 관심사 분리  |
| 공통 API 오류 처리      | Axios 인터셉터, API 추상화 계층               |
| 유저 인증 흐름          | 상태 관리 분리, 관심사 분리, 로직 단위 모듈화 |
| 파일 구조 설계          | 기능/도메인 기반 구조 → 관심사 분리           |
| 테스트 설계 (단위/통합) | 비즈니스 로직과 UI 로직 분리 필요             |
