# TIL | 2025.05월 1일

## 주간 목표

-   계획한 미라클 모닝 자리잡기
-   스픽 챌린저
-   루틴 확립하기
    -   충분한 수면을 가져가려고 노력하기 (TIL 공유를 조금 늦은 시간에 진행하고 2시에 취침하고 7시에 기상해서 운동까지 해버리니 너무 피곤함)
    -   일어나서 런닝하는건 지양한다. (피곤해지기 때문에)
    -   런닝은 하루 일과를 마무리하고 근력운동 전 또는 후에 진행한다.
    -   스픽을 운동하고 씻고 딱 한개만실시한다.
    -   최대한 이동하는 시간을 활용해서 진행한다.(다 남는 시간이다.)
    -   하루에 최소 알고리즘 하나를 풀도록 노력하기
    -   책은 내용을 암기하는게 아니다 가볍게 흘러가듯이 읽자
-   [벨로그](https://velog.io/@pigpgw/%EB%82%98%EC%9D%98-%EA%B0%9C%EB%B0%9C-%EC%84%B1%EC%9E%A5-%EC%A0%84%EB%9E%B5-%EC%83%9D%EA%B0%81%ED%95%98%EB%8A%94-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A1%9C-%EB%82%98%EC%95%84%EA%B0%80%EA%B8%B0)에 작성한 것들 습관화하기

### 중요 일정

-   5월 10일 (토) 12:40 : 정보처리기사 필기
-   5월 13일 ~ 5월 24일 싸피 에세이 제출
-   5월 24일 토요일 싸피 코테
-   5월 31일(토) 10:00 : sqld 시험 (광주 조선대학교부속중학교)

### 오늘 진행 순서 예정

-   [x] 아침 운동 : 팔굽 100개
-   [x] 스픽
-   [x] 주시 다시 빌드해서 키기
-   [x] 알고리즘
    -   [] https://leetcode.com/problems/two-sum/
-   [x] 정처기 가볍게 복습
-   [x] 정처기 21년 1회
-   [x] 책 읽기 (이팩티브 타입스크립트 아이템22)
-   [x] 주시 작업

    -   [x] [카카오맵 중복 호출 문제 및 시위 데이터 변경에따른 타입 변경](https://github.com/dev-4-team/eye-on-frontend/pull/127)
    -   시위 데이터가 오늘꺼인지 비교해서 재요청
    -   에러처리
        -   에측 가능한 에러
            -   응원하기 안될때
                -   해당 시위가 오늘 날짜 시위가 아니라서 안될때 또는 서버에서 시위 정보가 없어서
            -   시위 데이터가 갱신이 안됬을때
                -   캐싱 문제로 시위 데이터가 오늘 시위 데이터가 아닐때
            -   시위 데이터를 못불러 왔을때
        -   예측 불가능한 에러

-   [x] 스마게 작업
    -   [x] 알림 설계 피드백 반영
-   [x] 운동

---

# TIL

### 오늘 진행 순서 예정

## 책 읽기 (이팩티브 타입스크립트 아이템22 타입 좁히기)

-   null 체크
-   instance of
-   Array.isArray
-   명시적으로 태그를 붙여 타입을 좁힘 (사용자 정의 타입 가드)
-   타입 가드
-   주의할 것
    -   typeof numm 도 object 이기에 조심해야함
    -   빈 문자열 ''과 0 모두 fasle가 되기때문에 타입이 전혀 좁혀지지 않음/

## 블로그 하나 읽기

## 유익한 유튜브 시청하기

## 강의 수강(Next, 타입스크립트, 알고리즘)

## 알고리즘

### 코테 적용 방법

-   Step1 문제 이해하기
    -   문제를 제대로 읽기
    -   제약조건 읽기
        -   효율성 테스트 10^8 넘으면 안됨
        -   원소 값의 범위
            -   int === 4byte => 1bit는 부호 31bit는 수 표현 -2^31 ~ 2^31 + 1
                -   2의 31승은 10의 9승 그러면 인트형 변수에 저장 불가
-   Step2 접근 방법
    -   직관적으로 생각하기
        -   보통 완전 탐색으로 시작
        -   문제 상황을 단순화 하여 생각하기
        -   문제 상황을 극한화 하여 생각하기
    -   자료구조와 알고리즘 활용
        -   Step1 문제이해 에서 파악한 내용을 토대로 어떤 자료구조를 사용하는게 가장 적합한지 결정
        -   대놓고 특정 자료구조와 알고리즘을 묻는 문제도 많음
        -   자료구조에 따라 선택할 수 있는 알고리즘을 문제에 적용
    -   메모리 사용
        -   시간복잡도를 줄이기 위해 메모리를 사용하는 방법
        -   대표적으로 해시테이블

### 대표 알고리즘

-   O(1): Operation push and pop on Stack
-   O(log n): Binary Tree
-   O(n): for loop
-   O(n×log n): Quick Sort, Merge Sort, Heap Sort
-   O(n2): Double for loop, Insert Sort, Bubble Sort, Selection Sort
-   O(2n): Fibonacci Sequence

---

# 스마게 (푸시 알림 구현 시 고려사항 (Firebase Cloud Messaging 기준))

## 1. 권한 상태 관리 (`Notification.permission`)

-   [ ] `default` 상태 시, 언제 요청할지 명확한 UX 설계 필요
-   [ ] `denied` 상태는 브라우저 설정 안내 필요 (재요청 불가)
-   [ ] `granted` 상태에서도 푸시 구독이 만료됐을 수 있으므로 항상 구독 여부 확인

## 2. FCM 토큰 발급 및 갱신

-   [ ] 최초 발급 시 서버에 저장
-   [ ] 기존에 저장된 토큰과 비교하여 변경된 경우 업데이트
-   [ ] 브라우저 재시작 또는 서비스워커 변경 시 토큰 갱신 가능성 고려
-   [ ] 사용자 세션이 유지될 때도 토큰이 변경될 수 있음

📚 참고: https://firebase.google.com/docs/cloud-messaging/manage-tokens?hl=ko

## 3. 알림 권한 초기화 대응

다음 상황에서 권한/구독이 초기화됨:

-   [ ] 브라우저 쿠키/사이트 데이터 삭제
-   [ ] 사용자가 사이트 권한 수동 초기화
-   [ ] 브라우저 자동 만료 정책 (90일 미사용 등)
-   [ ] 브라우저 초기화 또는 프로필 삭제
-   [ ] 시크릿 모드 사용 종료
-   [ ] 브라우저 업데이트로 권한 리셋

이때 `Notification.permission === 'default'`로 되돌아감 → 재요청 필요

## 4. 푸시 구독 및 토큰 유효성 체크

-   [ ] 페이지 로드시 기존 구독 상태 확인
-   [ ] `PushManager.getSubscription()`을 사용해 존재 여부 확인
-   [ ] 구독이 없는 경우 → 새 구독 생성
-   [ ] 구독 실패 시 fallback 또는 UX 처리 필요

## 5. 로그아웃/탈퇴 시 토큰 제거

-   [ ] 사용자 로그아웃 시 토큰 서버에서 제거
-   [ ] `subscription.unsubscribe()` 호출하여 푸시 구독 해제

## 6. FCM 응답 처리

푸시 전송 실패 응답 예시:

-   `NotRegistered` → 유효하지 않은 토큰 → 서버에서 삭제
-   `InvalidRegistration` → 잘못된 형식
-   `MessageTooBig` → payload 4KB 초과

📚 참고: https://firebase.google.com/docs/cloud-messaging/send-message#response

## 7. 사용자 경험(UX)

-   [ ] 알림 요청 타이밍은 사용자 맥락에 맞게 (예: "이 기능에 대한 알림 받기")
-   [ ] 권한 거부 상태일 때 알림 설정 위치 안내
-   [ ] 너무 이른 권한 요청은 피하고, 사용 의도가 명확한 시점에서 요청

## 8. 브라우저 및 플랫폼 호환성

-   [ ] iOS Safari는 FCM 미지원 (APNs 필요, iOS 16 이상만 지원)
-   [ ] 브라우저별 푸시 정책 상이 (예: Chrome vs Firefox vs Edge)
-   [ ] 사용자 브라우저 감지 후 조건 분기 필요 시 처리

📚 참고: https://firebase.google.com/docs/cloud-messaging/js/client?hl=ko

## 유익한 유튜브 시청하기

## 정처기

### 자주 틀리거나 헷갈리는 개념 요약 정리

### 📌 소프트웨어 공학

| 개념                  | 요약                                                                 |
| --------------------- | -------------------------------------------------------------------- |
| **XP의 가치**         | 용기, 단순성, 의사소통, 피드백, 존중                                 |
| **럼바우 분석 기법**  | 객체 모델링(정적), 동적 모델링(행위), 기능 모델링(자료 흐름)         |
| **DFD 특징**          | 시간 흐름 표현 불가, 자료의 흐름만 표현, 요소: 원, 화살표, 직선      |
| **요구사항 명세기법** | 정형(수학 기반, 정확하지만 어려움), 비정형(자연어 기반, 쉬우나 모호) |
| **테스트 오라클**     | 참/거짓 판별 기준 제공                                               |
| **CASE 도구**         | 소프트웨어 공학 자동화 도구, 분석/설계/문서화/검증 지원              |

---

### 📌 데이터베이스

| 개념                     | 요약                                                                                                                                   |
| ------------------------ | -------------------------------------------------------------------------------------------------------------------------------------- |
| **정규화 단계**          | 1NF(원자값), 2NF(부분함수 종속 제거), 3NF(이행함수 종속 제거), BCNF(후보키 아닌 결정자 제거), 4NF(다치 종속 제거), 5NF(조인 종속 제거) |
| **뷰의 특징**            | 삽입/삭제 제약 있음, 기본 테이블 삭제되면 뷰도 제거됨                                                                                  |
| **트랜잭션 특성 (ACID)** | 원자성, 일관성, 고립성, 지속성                                                                                                         |
| **DCL 명령어**           | GRANT, REVOKE                                                                                                                          |
| **릴레이션 구성요소**    | 튜플 순서 X, 속성 순서 X, 속성명 고유, 속성값은 원자값                                                                                 |
| **관계대수 특징**        | 절차적 언어, 연산자 기반, 결과도 릴레이션                                                                                              |

---

### 📌 네트워크 및 보안

| 개념                            | 요약                                                        |
| ------------------------------- | ----------------------------------------------------------- |
| **TCP/IP 계층**                 | 응용 → 표현 → 세션 → 전송 → 네트워크 → 데이터링크 → 물리    |
| **전송계층**                    | 종단 간 신뢰성 보장, 흐름제어, 오류제어                     |
| **IP 버전별 브로드캐스트 차이** | IPv4는 브로드캐스트 있음, IPv6는 Anycast 도입               |
| **스택가드**                    | 스택 오버플로우 방지 기술                                   |
| **스머핑 공격**                 | ICMP를 이용한 반사 DDoS                                     |
| **XSS**                         | 웹 페이지에 악성 스크립트 삽입하여 사용자 브라우저에서 실행 |

---

### 📌 운영체제/자료구조

| 개념                        | 요약                                                         |
| --------------------------- | ------------------------------------------------------------ |
| **트리 순회**               | 전위: 루트-좌-우, 중위: 좌-루트-우, 후위: 좌-우-루트         |
| **응집도 (강→약)**          | 기능적 > 순차적 > 교환적 > 절차적 > 시간적 > 논리적 > 우연적 |
| **우선순위 스케줄링 (HRN)** | (대기시간 + 서비스시간) / 서비스시간                         |
| **은행가 알고리즘**         | 교착 상태 회피 기법                                          |
| **Stub vs Driver**          | 하향식 통합에서 Stub, 상향식 통합에서 Driver 사용            |

---

### 📌 소프트웨어 개발 및 프로세스

| 개념                  | 요약                                                   |
| --------------------- | ------------------------------------------------------ |
| **CMM 모델**          | 초기 → 반복 → 정의 → 관리 → 최적화                     |
| **SPICE**             | 소프트웨어 프로세스 평가 국제표준                      |
| **Seven Touchpoints** | SDLC에 보안을 통합한 실무적 개발보안 방법론            |
| **CBD**               | 컴포넌트 조립 기반 개발, 객체지향의 재사용성 문제 보완 |

---

## 강의 수강(Next, 타입스크립트, 알고리즘)

### 공부할거

-   그 새창열기로 열면 어디 탭 어디위치에 새 창이 생기나
-   리액트 코어
-   리액트 랜더링과정 자세히
-   리엑트는 어떻게 상태를 업데이트 하는가
-   프론트엔드 성능 측정 방법
-   리엑트 컴포넌트 렌더링 개발도구 통해서 성능 측정방법

### 할거

-   JS 엔진 구조 (V8, SpiderMonkey)
-   인터프리터 vs 컴파일러
-   JIT 컴파일러 (Just-In-Time Compiler)
-   이벤트 루프, Call Stack, Task Queue
-   공통 컴포넌트 설계
    -   rest
    -   기본 타입 확장
        -   공통 버튼 컴포넌트 만드는데 어떻게 해야할지 모르겠음,
-   React

    -   리엑트에서의 단일 책임 원칙
    -   리엑트 쿼리 사람답게 쓰기
    -   suspense

-   작업

    -   next에서 fetch params next invalidate

-   패키지 매니저
    -   package.json
        -   ^ 메이저 버전 이상 아무거나
    -   packagelock.json
        -   정확한 현재 프로젝트에 설치된 라이브러리 버전 명시

---

# 프론트엔드 아키텍처

## 뷰 로직과 비즈니스 로직의 분리

### 목적

-   **컴포넌트 재사용성 증가**
-   **유지보수성 향상**
-   **테스트 용이성 확보**

### 예시

#### 뷰 로직 (UI 컴포넌트)

```tsx
const ProductCard = ({ product, onBuy }: Props) => {
    return (
        <div>
            <p>{product.name}</p>
            <button onClick={() => onBuy(product.id)}>구매</button>
        </div>
    );
};
```

#### 비즈니스 로직 (커스텀 훅)

```ts
const useBuyProduct = () => {
    const mutation = useMutation((productId) => buyAPI(productId));
    return mutation;
};
```

### 좋은 구조

-   UI: 입력 → 출력에 집중 (props 기반)
-   로직: 상태 관리, 요청 처리 등은 **hooks나 service 파일로 분리**

## 공부하고 싶은 키워드

## 1. **소프트웨어 설계 원칙 관련**

| 주요 개념                                  | 설명                                           | 함께 공부하면 좋은 개념                                                                   |
| ------------------------------------------ | ---------------------------------------------- | ----------------------------------------------------------------------------------------- |
| **관심사의 분리 (Separation of Concerns)** | 기능/책임/영역을 나눠서 복잡도를 낮추는 원칙   | - SRP (단일 책임 원칙)<br>- 모듈화(Modularity)<br>- MVC/MVVM 패턴<br>- 레이어드 아키텍처  |
| **추상화 계층 (Abstraction Layer)**        | 하위 로직을 숨기고 필요한 기능만 노출하는 구조 | - 캡슐화<br>- 인터페이스 / 추상 클래스<br>- 레이어드 아키텍처<br>- 의존성 역전 원칙 (DIP) |
| **비즈니스 로직 (Business Logic)**         | 애플리케이션의 핵심 규칙/기능을 수행하는 부분  | - 도메인 모델<br>- 서비스 계층<br>- 유스케이스<br>- 엔티티(Entity), DTO                   |

---

## 2. **프론트엔드 구조/설계**

| 주요 개념                                | 설명                                        | 함께 공부하면 좋은 개념                                                     |
| ---------------------------------------- | ------------------------------------------- | --------------------------------------------------------------------------- |
| **Container vs Presentational 컴포넌트** | 비즈니스 로직과 UI 로직을 나누는 React 설계 | - 관심사 분리<br>- 컴포넌트 책임 분리<br>- Hooks 구조화                     |
| **상태 관리 구조 (Zustand, Redux, etc)** | 상태를 어디서/어떻게 다룰지 정의            | - 비즈니스 로직 위치<br>- Store 분리 전략<br>- Selector, middleware         |
| **API Layer 분리**                       | API 요청을 별도 레이어로 나눔               | - Axios 커스텀 인스턴스<br>- Query Hook abstraction<br>- Service Layer 구조 |

---

## 4. **실무 적용 관점 (실제로 설계할 때 유용한 개념)**

| 실무에서 접하는 개념    | 연관 개념                                     |
| ----------------------- | --------------------------------------------- |
| 서비스 레이어 설계      | 비즈니스 로직 분리, 추상화 계층, 관심사 분리  |
| 공통 API 오류 처리      | Axios 인터셉터, API 추상화 계층               |
| 유저 인증 흐름          | 상태 관리 분리, 관심사 분리, 로직 단위 모듈화 |
| 파일 구조 설계          | 기능/도메인 기반 구조 → 관심사 분리           |
| 테스트 설계 (단위/통합) | 비즈니스 로직과 UI 로직 분리 필요             |
