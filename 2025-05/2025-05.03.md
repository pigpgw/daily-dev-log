# TIL | 2025.04.29

## 주간 목표

-   계획한 미라클 모닝 자리잡기
-   스픽 챌린저
-   루틴 확립하기
    -   충분한 수면을 가져가려고 노력하기 (TIL 공유를 조금 늦은 시간에 진행하고 2시에 취침하고 7시에 기상해서 운동까지 해버리니 너무 피곤함)
    -   일어나서 런닝하는건 지양한다. (피곤해지기 때문에)
    -   런닝은 하루 일과를 마무리하고 근력운동 전 또는 후에 진행한다.
    -   스픽을 운동하고 씻고 딱 한개만실시한다.
    -   최대한 이동하는 시간을 활용해서 진행한다.(다 남는 시간이다.)
    -   하루에 최소 알고리즘 하나를 풀도록 노력하기
    -   책은 내용을 암기하는게 아니다 가볍게 흘러가듯이 읽자
-   [벨로그](https://velog.io/@pigpgw/%EB%82%98%EC%9D%98-%EA%B0%9C%EB%B0%9C-%EC%84%B1%EC%9E%A5-%EC%A0%84%EB%9E%B5-%EC%83%9D%EA%B0%81%ED%95%98%EB%8A%94-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A1%9C-%EB%82%98%EC%95%84%EA%B0%80%EA%B8%B0)에 작성한 것들 습관화하기
-   기존 코드에서 타입만을 고민하는게 중요한게 아니다.
-   기존 컴포넌트 트리의 구조를 먼저 생각해 보는게 우선이다.
-   기존 코드의 타입을 올바르게 이해하기 위해선 개인적인 생각으로 필요한것들
    -   해당 컴포넌트의 역할
    -   파라미터로 넘어오는 데이터가 의미하는 것 또는 용도
    -   프로젝트에서 해당 타입의 의미?
    -   어떤 도메인인가?

### 중요 일정

-   5월 10일 토요일 12:40 : 정보처리기사 필기
-   5월 13일 ~ 5월 24일 싸피 에세이 제출
-   5월 24일 토요일 싸피 코테
-   5월 31일 토요일 10:00 : sqld 시험 (광주 조선대학교부속중학교)

### 오늘 진행 순서 예정

-   [x] 주시 다시 빌드해서 키기
-   [x] 스픽
-   [x] 매일 매일 면접 질문 (tanstack-query에서 stale time과 gc time의 차이점에 대해서 설명해주세요)
-   [x] 책 읽기 (아이템 38 any 다루기)
-   [x] 알고리즘
-   [x] 블로그 하나 읽기 [나만의 컴포넌트 분리 기준](https://velog.io/@yeongipark/%EB%82%98%EB%A7%8C%EC%9D%98-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EB%B6%84%EB%A6%AC-%EA%B8%B0%EC%A4%80)
-   [x] 유익한 유튜브 시청하기 [에러 핸들링](https://www.youtube.com/watch?v=G-YUvXpqB1U)
-   [x] 정처기 강의

---

# TIL

## 오늘 진행 순서 예정

## 매일 매일 면접 질문 [tanstack-query에서 stale time과 gc time의 차이점에 대해서 설명해주세요](https://www.maeil-mail.kr/question/5)

tanstack-query에서 staleTime과 gcTime은 데이터를 캐싱하고 관리하는 데 중요한 두 가지 설정 값입니다. 먼저 요약해서 말씀 드려보자면, staleTime은 데이터가 얼마나 오래 '신선한 상태'로 유지되는지를 정하는 시간이고, gcTime은 해당 쿼리를 사용하는 곳이 없게 된 이후에도 캐시 데이터를 얼마 동안 유지할지를 정하는 시간입니다.

먼저, staleTime은 데이터를 처음 가져온 후에 그 데이터를 '신선한' 상태로 간주하는 시간을 말합니다. staleTime 내에는 같은 쿼리에 대한 새로운 네트워크 요청이 일어나지 않고, 캐시 데이터를 그대로 사용하게 됩니다. 예를 들어, staleTime을 5분으로 설정하면, 데이터를 가져오고 나서 5분 동안은 이 데이터가 '신선하다'고 판단해서 refetch가 트리거되더라도 추가 네트워크 요청 없이 캐시 데이터를 계속 사용합니다. 그리고 staleTime이 지난 후 refetch가 트리거된다면 새로운 요청을 보내 데이터를 갱신하게 됩니다. staleTime의 기본값은 0입니다.

반면에 gcTime은 해당 쿼리가 더 이상 사용되지 않을 때, 캐시 데이터가 메모리에 얼마나 더 남아 있을지를 정하는 시간입니다.
staleTime이 지나면 데이터는 '오래된' 상태가 되지만, 여전히 캐시된 데이터는 사용이 가능합니다. 이 캐시 데이터는 새로운 요청을 보내 신선한 데이터를 받아오기 이전에 임시로 기존 데이터를 표시하는 데 활용됩니다.

다만, 해당 쿼리가 사용되지 않게 된 시점으로부터 gcTime으로 설정된 시간이 지나면 캐시에서 데이터가 삭제됩니다. 예를 들어, gcTime을 10분으로 설정하면, 해당 쿼리를 사용하는 컴포넌트가 모두 언마운트된 시점으로부터 10분 후에 캐시에서 데이터가 삭제됩니다. tanstack-query에서 설정한 기본 gcTime은 5분입니다.

> staleTime은 데이터를 처음 가져온 후 얼마 동안 네트워크 요청 없이 캐시된 데이터를 사용할지를 정하는 시간이고, gcTime은 해당 쿼리가 사용되지 않게 된 후에도 캐시에 유지될 시간을 정하는 겁니다. 이렇게 각각의 설정을 통해 데이터를 더 효율적으로 관리하고, 불필요한 네트워크 요청을 줄이면서도 최신 데이터를 가져올 수 있도록 합니다.

## 블로그 하나 읽기 [나만의 컴포넌트 분리 기준](https://velog.io/@yeongipark/%EB%82%98%EB%A7%8C%EC%9D%98-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EB%B6%84%EB%A6%AC-%EA%B8%B0%EC%A4%80)

### 왜 관심사 별로 컴포넌트를 나누어야 할까?

이와 관련해서 흔히 이야기되는 개념 중 하나가 기능 조직과 목적 조직이다.

-   기능 조직이란?
    -   같은 역할(기능)을 하는 사람끼리 묶은 조직
    -   예: 모든 디자이너끼리, 모든 개발자끼리 모여 있는 구조
    -   예: 검증/유효성 검사만 담당하는 팀
-   목적 조직이란?
    -   같은 목표(관심사)를 가진 사람들이 모여 있는 조직
    -   예: 자동차라는 제품을 만드는 팀에 디자이너, 개발자, 기획자가 함께 있는 구조

### UI가 같다고 꼭 공통 컴포넌트로 나눠야 할까?

-   UI는 같지만, 역할은 다르기 때문 , 각 Section은 현재는 동일한 구조를 하고 있지만, 앞으로 요구사항이 다르게 변경될 가능성이 충분
-   분리된 컴포넌트로 유지하는 것이 더 유연하다고 판단

## 책 읽기 (아이템 38)

-   안좋은 예시

```ts
function f1() {
    const x: any = expressionReturningFoo();
    processBar(x);
}
```

-   그나마 나은 방법

```ts
function f1() {
    const x: any = expressionReturningFoo();
    processBar(x);
}
```

```ts
function f1() {
    const x = expressionReturningFoo();
    // @ts-ignore 를 사용하여 무시 가능
    // 하지만 해당 방법은 근본적인 원인을 해결한것이 아니기에 다른곳에서 더 큰 문제가 발생할 수도 있음
    processBar(x);
}
```

> 근본적인 원인을 찾아 해결해야한다

> 최대한 해결해라 잘못된 타입 추론보단 any가 낫고 any도 최대한 작게 사용해라

-   이유
    -   만약 f1함수가 x를 반환한다면 ? f1에서 반환한 x는 어디서든지 any이기에 문제가 생긴다. 만약 필요하다면 사용할때 any처리를 해주자
    -   그렇지 않으면 프로젝트 전역에 any가 퍼져버린다.

## 알고리즘

### 코테 적용 방법

-   Step1 문제 이해하기
    -   문제를 제대로 읽기
    -   제약조건 읽기
        -   효율성 테스트 10^8 넘으면 안됨
        -   원소 값의 범위
            -   int === 4byte => 1bit는 부호 31bit는 수 표현 -2^31 ~ 2^31 + 1
                -   2의 31승은 10의 9승 그러면 인트형 변수에 저장 불가
-   Step2 접근 방법
    -   직관적으로 생각하기
        -   보통 완전 탐색으로 시작
        -   문제 상황을 단순화 하여 생각하기
        -   문제 상황을 극한화 하여 생각하기
    -   자료구조와 알고리즘 활용
        -   Step1 문제이해 에서 파악한 내용을 토대로 어떤 자료구조를 사용하는게 가장 적합한지 결정
        -   대놓고 특정 자료구조와 알고리즘을 묻는 문제도 많음
        -   자료구조에 따라 선택할 수 있는 알고리즘을 문제에 적용
    -   메모리 사용
        -   시간복잡도를 줄이기 위해 메모리를 사용하는 방법
        -   대표적으로 해시테이블

### 대표 알고리즘

-   O(1): Operation push and pop on Stack
-   O(log n): Binary Tree
-   O(n): for loop
-   O(n×log n): Quick Sort, Merge Sort, Heap Sort
-   O(n2): Double for loop, Insert Sort, Bubble Sort, Selection Sort
-   O(2n): Fibonacci Sequence

---

## 유익한 유튜브 시청하기

-   [에러 핸들링](https://www.youtube.com/watch?v=G-YUvXpqB1U)
-   [에러 핸들링 테코톡](https://www.youtube.com/watch?v=hQekqGONSlY)

-   어플리케이션이 중단되는걸 막고 진행되도록
-   에러는 예외적인 상황(내가 통제할 수 없는 상황 (서버가 어떻게 될지 프론트는 모름 그런거))
