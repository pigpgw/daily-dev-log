# 챕터 1: [챕터 제목]

## 읽은 날짜

-   2026-01-02

## 두괄식 요약

이 챕터의 핵심을 1-2문장으로 요약

---

## 핵심 내용

### 문제 상황

어떤 문제를 해결하려는가?

### 해결 방법 / 패턴

#### 합성패턴

-   코드베이스가 커져도 모듈화된 구조를 유지하여 재사용성과 가독성을 확보하는 것. 컴포넌트가 서로 얽히고 결합된 구조일수록. 유지보수와 테스트가 까다로울 뿐만 아니라 새로운 팀원이 프로젝트에 적응하는 데에도 많은 시간이 걸린다.
-   합성은 이러한 문제를 해결하기 위해 체계적이고 확장 가능하며 깔끔한 코드베이스를 만들 수 있게 해주는 강력한 기술
-   하나의 거대한 컴포넌트에 여러가지 기능을 만들지 않고, 작고 다루기 편한 조각으로 분리하여 다양한 방법으로 이를 조합가능함

#### 헤드리스 텀포넌트 패턴

-   JSX를 기본 로직으로부터 깔끔하게 분리하는 강력한 방법
-   JSX로 선언적 UI를 구성하는 것은 자연스럽지만. 상태관리하는 것은 쉽지 않음 : 이 문제를 해결하고자 등장한 헤드리스 컴포넌트는 상태 관리의 모든 복잡한 문제들을 떠맡으며 새로운 차원의 추상화 방법을 제안
-   헤드리스 컴포넌트는 로직을 캡슐화해서 담고 있지만 렌더링과 관련된 것은 없는 함수를 뜻함

### 핵심 개념

-   합성, 합성 패턴, 고차함수
-   헤드리스 컴포넌트 패턴

---

## 코드 예시

```javascript
const checkAuthorization = () => {};

const withAuthorization = (Component: React.FC): React.FC => {
    return (props: any) => {
        const isAuthorized = checkAuthorization();
        return isAuthorized ? <Component {...props} /> : <Login />;
    };
};
```

```javascript

// ============================================
// 헤드리스 컴포넌트 (Headless Component) 패턴
// ============================================
//
// 헤드리스 컴포넌트란?
// - "머리(head)"가 없는 컴포넌트 = UI가 없는 컴포넌트
// - 로직(상태 관리, 이벤트 처리)만 제공하고, UI 렌더링은 사용자가 결정
// - 스타일링과 구조를 완전히 분리하여 재사용성과 유연성 극대화
//
// 왜 헤드리스 컴포넌트인가?
// 1. 관심사의 분리: 로직과 UI를 완전히 분리
// 2. 재사용성: 같은 로직을 다양한 UI로 활용 가능
// 3. 유연성: 디자인 시스템에 맞게 자유롭게 스타일링 가능
// 4. 테스트 용이성: 로직만 테스트하면 되므로 간단함
// 5. 접근성: 사용자가 접근성 요구사항에 맞게 구현 가능
//
// 예시: Radix UI, Headless UI, React Aria 등이 헤드리스 컴포넌트 라이브러리

interface Item {
    icon: string;
    text: string;
    id: string;
    description: string;
}

// 헤드리스 드롭다운 훅 - 모든 로직을 담당
const useDropdown = (items: Item[]) => {
    const [isOpen, setIsOpen] = useState(false);
    const [selectedItem, setSelectedItem] = useState<Item | null>(null);
    const [selectedItemIndex, setSelectedItemIndex] = useState<number>(-1);
    const [highlightedIndex, setHighlightedIndex] = useState<number>(-1);

    // 드롭다운 열기/닫기
    const openDropdown = () => setIsOpen(true);
    const closeDropdown = () => {
        setIsOpen(false);
        setHighlightedIndex(-1);
    };
    const toggleDropdown = () => {
        if (isOpen) {
            closeDropdown();
        } else {
            openDropdown();
        }
    };

    // 아이템 선택 처리
    const selectItem = (item: Item) => {
        setSelectedItem(item);
        const index = items.findIndex((i) => i.id === item.id);
        setSelectedItemIndex(index);
        closeDropdown(); // 선택 후 자동으로 닫기
    };

    // 키보드 네비게이션
    const handleKeyDown = (event: React.KeyboardEvent) => {
        switch (event.key) {
            case 'Enter':
            case ' ':
                event.preventDefault();
                if (!isOpen) {
                    openDropdown();
                } else if (highlightedIndex >= 0) {
                    selectItem(items[highlightedIndex]);
                }
                break;
            case 'Escape':
                event.preventDefault();
                closeDropdown();
                break;
            case 'ArrowDown':
                event.preventDefault();
                if (!isOpen) {
                    openDropdown();
                } else {
                    setHighlightedIndex((prev) => (prev < items.length - 1 ? prev + 1 : 0));
                }
                break;
            case 'ArrowUp':
                event.preventDefault();
                if (isOpen) {
                    setHighlightedIndex((prev) => (prev > 0 ? prev - 1 : items.length - 1));
                }
                break;
            case 'Home':
                event.preventDefault();
                if (isOpen) {
                    setHighlightedIndex(0);
                }
                break;
            case 'End':
                event.preventDefault();
                if (isOpen) {
                    setHighlightedIndex(items.length - 1);
                }
                break;
        }
    };

    // 외부 클릭 감지를 위한 ref (선택사항)
    const getMenuProps = () => ({
        role: 'menu' as const,
        'aria-label': 'Dropdown menu',
    });

    const getTriggerProps = () => ({
        role: 'button' as const,
        'aria-haspopup': 'true' as const,
        'aria-expanded': isOpen,
        tabIndex: 0,
    });

    const getItemProps = (index: number) => ({
        role: 'menuitem' as const,
        'aria-selected': selectedItemIndex === index,
    });

    return {
        // 상태
        isOpen,
        selectedItem,
        selectedItemIndex,
        highlightedIndex,

        // 액션
        openDropdown,
        closeDropdown,
        toggleDropdown,
        selectItem,
        handleKeyDown,

        // 접근성을 위한 props
        getMenuProps,
        getTriggerProps,
        getItemProps,
    };
};

// 헤드리스 드롭다운 컴포넌트 - UI는 render prop으로 받음
type DropdownProps = {
    items: Item[];
    children: (props: ReturnType<typeof useDropdown>) => React.ReactNode;
};

const Dropdown = ({ items, children }: DropdownProps) => {
    const dropdownProps = useDropdown(items);
    return <>{children(dropdownProps)}</>;
};

// 사용 예시 1: 기본 스타일의 드롭다운
export const BasicDropdown = ({ items }: { items: Item[] }) => {
    return (
        <Dropdown items={items}>
            {({
                isOpen,
                selectedItem,
                selectedItemIndex,
                highlightedIndex,
                toggleDropdown,
                selectItem,
                handleKeyDown,
                getMenuProps,
                getTriggerProps,
                getItemProps,
            }) => (
                <div className='dropdown' onKeyDown={handleKeyDown} tabIndex={0}>
                    <div className='trigger' onClick={toggleDropdown} {...getTriggerProps()}>
                        {selectedItem?.text || 'Select an item'}
                    </div>
                    {isOpen && (
                        <div className='dropdown-menu' {...getMenuProps()}>
                            {items.map((item, index) => (
                                <div
                                    key={item.id}
                                    onClick={() => selectItem(item)}
                                    className={`
                                        ${selectedItemIndex === index ? 'selected' : ''}
                                        ${highlightedIndex === index ? 'highlighted' : ''}
                                    `}
                                    {...getItemProps(index)}
                                >
                                    <img src={item.icon} alt={item.text} />
                                    <span>{item.text}</span>
                                </div>
                            ))}
                        </div>
                    )}
                </div>
            )}
        </Dropdown>
    );
};

// 사용 예시 2: 완전히 다른 스타일의 드롭다운
export const CustomStyledDropdown = ({ items }: { items: Item[] }) => {
    return (
        <Dropdown items={items}>
            {({ isOpen, selectedItem, toggleDropdown, selectItem, handleKeyDown }) => (
                <div className='custom-dropdown-wrapper' onKeyDown={handleKeyDown}>
                    <button className='custom-trigger' onClick={toggleDropdown}>
                        {selectedItem ? (
                            <>
                                <img src={selectedItem.icon} alt='' />
                                <span>{selectedItem.text}</span>
                            </>
                        ) : (
                            'Choose...'
                        )}
                        <span>{isOpen ? '▲' : '▼'}</span>
                    </button>
                    {isOpen && (
                        <ul className='custom-menu'>
                            {items.map((item) => (
                                <li key={item.id} onClick={() => selectItem(item)}>
                                    <div>
                                        <img src={item.icon} alt={item.text} />
                                        <div>
                                            <strong>{item.text}</strong>
                                            <p>{item.description}</p>
                                        </div>
                                    </div>
                                </li>
                            ))}
                        </ul>
                    )}
                </div>
            )}
        </Dropdown>
    );
};

```

**핵심 포인트**:

---

## 내 경험과의 연결

### 새로 알게 된 점

궁금해서 공부해 보렸던 헤더리스 컴포넌트와, 합성 컴포넌트를 이번 기회에 더 잘 알게되서 좋았다.

## 실무 적용

### 적용 가능한 부분

대부분의 경우에 적용 가능할 것 같다.

## 회고

**가장 중요한 것** (한 문장): 모든것에 적용하는것보다 진짜 필요한 부분에 어떻게 적용할지를 고민하고 적용해보며 필요한 부분에 올바른 패턴을 적용하는 연습이 필요하고 중요하다고 생각했다.

**다시 읽을 부분**: 해당 챕터는 다시 회독
