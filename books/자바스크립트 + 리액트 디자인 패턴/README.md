# 자바스크립트 + 리액트 디자인 패턴

## 챕터별 학습 목표

### CHAPTER 01: 디자인 패턴 소개

- [ ] 디자인 패턴의 역사를 설명할 수 있다.
- [ ] 패턴이란 무엇인지 정의하고 설명할 수 있다.
- [ ] 디자인 패턴의 일상 활용 사례를 설명할 수 있다.
- [ ] 자바스크립트와 리액트에서 디자인 패턴이 왜 중요한지 설명할 수 있다.

### CHAPTER 02: 패턴성 검증, 프로토 패턴 그리고 세 가지 법칙

- [ ] 프로토 패턴이란 무엇인지 설명할 수 있다.
- [ ] 패턴성 검증 방법을 설명할 수 있다.
- [ ] 세 가지 법칙을 나열하고 설명할 수 있다.
- [ ] 패턴을 식별하고 검증하는 기준을 설명할 수 있다.

### CHAPTER 03: 패턴 구조화 및 작성

- [ ] 디자인 패턴의 구조를 설명할 수 있다.
- [ ] 모범 패턴의 특징을 설명할 수 있다.
- [ ] 패턴을 작성하는 방법을 설명할 수 있다.
- [ ] 패턴 문서화 방법을 설명할 수 있다.

### CHAPTER 04: 안티 패턴

- [ ] 안티 패턴이란 무엇인지 설명할 수 있다.
- [ ] 자바스크립트 안티 패턴을 나열하고 설명할 수 있다.
- [ ] 안티 패턴의 문제점을 설명할 수 있다.
- [ ] 안티 패턴을 피하고 해결하는 방법을 설명할 수 있다.

### CHAPTER 05: 최신 자바스크립트 문법과 기능

- [ ] 애플리케이션 분리의 중요성을 설명할 수 있다.
- [ ] 모듈 가져오기와 내보내기(import/export)를 설명할 수 있다.
- [ ] 모듈 객체의 개념을 설명할 수 있다.
- [ ] 외부 소스로부터 가져오는 모듈을 설명할 수 있다.
- [ ] 정적으로 모듈 가져오는 방법을 설명할 수 있다.
- [ ] 동적으로 모듈 가져오는 방법을 설명할 수 있다.
- [ ] 사용자 상호작용에 따라 모듈을 가져오는 방법을 설명할 수 있다.
- [ ] 화면에 보이면 모듈을 가져오는 방법(Intersection Observer 활용)을 설명할 수 있다.
- [ ] 서버에서 모듈 사용 방법을 설명할 수 있다.
- [ ] 모듈을 사용하면 생기는 이점을 설명할 수 있다.
- [ ] 생성자, 게터, 세터를 가진 클래스를 설명할 수 있다.
- [ ] 자바스크립트 프레임워크와 클래스의 관계를 설명할 수 있다.

### CHAPTER 06: 디자인 패턴의 유형

- [ ] 디자인 패턴의 배경을 설명할 수 있다.
- [ ] 생성 패턴의 종류와 특징을 설명할 수 있다.
- [ ] 구조 패턴의 종류와 특징을 설명할 수 있다.
- [ ] 행위 패턴의 종류와 특징을 설명할 수 있다.
- [ ] 디자인 패턴의 분류 체계를 설명할 수 있다.

### CHAPTER 07: 자바스크립트 디자인 패턴

#### 생성 패턴

- [ ] 생성자 패턴을 설명하고 구현할 수 있다.
- [ ] 객체 생성 방법을 설명할 수 있다.
- [ ] 생성자의 기본 특징을 설명할 수 있다.
- [ ] 프로토타입을 가진 생성자를 설명할 수 있다.
- [ ] 모듈 패턴을 설명하고 구현할 수 있다.
- [ ] 객체 리터럴 패턴을 설명할 수 있다.
- [ ] 모듈 패턴의 변형을 설명할 수 있다.
- [ ] WeakMap을 사용하는 최신 모듈 패턴을 설명할 수 있다.
- [ ] 최신 라이브러리와 모듈의 관계를 설명할 수 있다.
- [ ] 노출 모듈 패턴의 장단점을 설명할 수 있다.
- [ ] 싱글톤 패턴을 설명하고 구현할 수 있다.
- [ ] 리액트의 상태 관리와 싱글톤 패턴의 관계를 설명할 수 있다.
- [ ] 프로토타입 패턴을 설명하고 구현할 수 있다.
- [ ] 팩토리 패턴을 설명하고 구현할 수 있다.
- [ ] 팩토리 패턴을 사용하면 좋은 상황과 안 되는 상황을 판단할 수 있다.
- [ ] 추상 팩토리 패턴을 설명하고 구현할 수 있다.

#### 구조 패턴

- [ ] 퍼사드 패턴을 설명하고 구현할 수 있다.
- [ ] 믹스인 패턴을 설명하고 구현할 수 있다.
- [ ] 서브클래싱을 설명할 수 있다.
- [ ] 믹스인의 장단점을 설명할 수 있다.
- [ ] 데코레이터 패턴을 설명하고 구현할 수 있다.
- [ ] 의사 클래스 데코레이터를 설명할 수 있다.
- [ ] 인터페이스와 추상 데코레이터를 설명할 수 있다.
- [ ] 데코레이터 패턴의 장단점을 설명할 수 있다.
- [ ] 플라이웨이트 패턴을 설명하고 구현할 수 있다.
- [ ] 플라이웨이트 패턴의 사용법을 설명할 수 있다.
- [ ] 데이터 공유 방법을 설명할 수 있다.
- [ ] 전통적인 플라이웨이트 구현 방법을 설명할 수 있다.
- [ ] 플라이웨이트로 변환하는 방법을 설명할 수 있다.
- [ ] 기본 팩토리를 설명할 수 있다.
- [ ] 외부 상태 관리 방법을 설명할 수 있다.
- [ ] 플라이웨이트 패턴과 DOM 객체의 관계를 설명할 수 있다.
- [ ] 중앙 집중식 이벤트 핸들링을 구현할 수 있다.

#### 행위 패턴

- [ ] 관찰자 패턴을 설명하고 구현할 수 있다.
- [ ] 관찰자 패턴과 발행/구독 패턴의 차이점을 설명할 수 있다.
- [ ] 관찰자 패턴의 장단점을 설명할 수 있다.
- [ ] 발행/구독 패턴을 구현할 수 있다.
- [ ] 중재자 패턴을 설명하고 구현할 수 있다.
- [ ] 간단한 중재자 구현 방법을 설명할 수 있다.
- [ ] 중재자 패턴과 관찰자 패턴의 유사점과 차이점을 설명할 수 있다.
- [ ] 이벤트 집합 패턴의 활용 방법을 설명할 수 있다.
- [ ] 중재자 패턴의 활용 방법을 설명할 수 있다.
- [ ] 이벤트 집합 패턴과 중재자 패턴을 결합하는 방법을 설명할 수 있다.
- [ ] 최신 자바스크립트에서의 중재자 패턴과 미들웨어를 설명할 수 있다.
- [ ] 중재자 패턴 vs 퍼사드 패턴의 차이를 설명할 수 있다.
- [ ] 커맨드 패턴을 설명하고 구현할 수 있다.

### CHAPTER 08: 자바스크립트 MV* 패턴

- [ ] MVC 패턴을 설명할 수 있다.
- [ ] Smalltalk-80의 MVC 패턴을 설명할 수 있다.
- [ ] 자바스크립트의 MVC 구현 방법을 설명할 수 있다.
- [ ] 모델, 뷰, 컨트롤러의 역할을 설명할 수 있다.
- [ ] 템플릿의 개념을 설명할 수 있다.
- [ ] MVC를 사용하는 이유를 설명할 수 있다.
- [ ] 자바스크립트와 Smalltalk-80의 MVC 차이를 설명할 수 있다.
- [ ] MVP 패턴을 설명할 수 있다.
- [ ] 모델, 뷰, 프리젠터의 역할을 설명할 수 있다.
- [ ] MVP vs MVC의 차이를 설명할 수 있다.
- [ ] MVVM 패턴을 설명할 수 있다.
- [ ] MVVM의 역사를 설명할 수 있다.
- [ ] MVVM에서 모델, 뷰, 뷰모델의 역할을 설명할 수 있다.
- [ ] 뷰모델 vs 모델의 차이를 설명할 수 있다.
- [ ] MV* 패턴의 장단점을 설명할 수 있다.
- [ ] MVC vs MVP vs MVVM을 비교 설명할 수 있다.
- [ ] 최신 MV* 패턴을 설명할 수 있다.
- [ ] MV* 패턴과 리액트의 관계를 설명할 수 있다.

### CHAPTER 09: 비동기 프로그래밍 패턴

- [ ] 비동기 프로그래밍의 배경을 설명할 수 있다.
- [ ] 프로미스 패턴을 설명하고 구현할 수 있다.
- [ ] 프로미스 체이닝을 설명할 수 있다.
- [ ] 프로미스 에러 처리 방법을 설명할 수 있다.
- [ ] 프로미스 병렬 처리 방법을 설명할 수 있다.
- [ ] 프로미스 순차 실행 방법을 설명할 수 있다.
- [ ] 프로미스 메모이제이션을 설명할 수 있다.
- [ ] 프로미스 파이프라인을 설명할 수 있다.
- [ ] 프로미스 재시도 패턴을 설명할 수 있다.
- [ ] 프로미스 데코레이터를 설명할 수 있다.
- [ ] 프로미스 경쟁 패턴을 설명할 수 있다.
- [ ] async/await 패턴을 설명하고 구현할 수 있다.
- [ ] 비동기 함수 조합 방법을 설명할 수 있다.
- [ ] 비동기 반복 방법을 설명할 수 있다.
- [ ] 비동기 에러 처리 방법을 설명할 수 있다.
- [ ] 비동기 병렬 처리 방법을 설명할 수 있다.
- [ ] 비동기 순차 실행 방법을 설명할 수 있다.
- [ ] 비동기 메모이제이션을 설명할 수 있다.
- [ ] 비동기 이벤트 처리 방법을 설명할 수 있다.
- [ ] async/await 파이프라인을 설명할 수 있다.
- [ ] 비동기 재시도 패턴을 설명할 수 있다.
- [ ] async/await 데코레이터를 설명할 수 있다.
- [ ] HTTP 요청 보내기 패턴을 구현할 수 있다.
- [ ] 파일 시스템에서 파일 읽어오기 패턴을 구현할 수 있다.
- [ ] 파일 시스템에 파일 쓰기 패턴을 구현할 수 있다.
- [ ] 여러 비동기 함수를 한 번에 실행하는 방법을 설명할 수 있다.
- [ ] 여러 비동기 함수를 순서대로 실행하는 방법을 설명할 수 있다.
- [ ] 함수의 결과를 캐싱하는 방법을 설명할 수 있다.
- [ ] async/await로 이벤트 처리하는 방법을 설명할 수 있다.
- [ ] 비동기 함수 실패 시 자동으로 재시도하는 방법을 구현할 수 있다.
- [ ] async/await 데코레이터를 작성할 수 있다.

### CHAPTER 10: 모듈형 자바스크립트 디자인 패턴

- [ ] 스크립트 로더에 대한 개념을 설명할 수 있다.
- [ ] AMD(Asynchronous Module Definition)를 설명할 수 있다.
- [ ] AMD 모듈을 식별하는 방법을 설명할 수 있다.
- [ ] AMD 모듈과 jQuery의 관계를 설명할 수 있다.
- [ ] AMD의 장단점을 설명할 수 있다.
- [ ] CommonJS를 설명할 수 있다.
- [ ] CommonJS 시작 방법을 설명할 수 있다.
- [ ] 여러 의존성을 동시에 사용하는 방법을 설명할 수 있다.
- [ ] Node.js 환경에서의 CommonJS를 설명할 수 있다.
- [ ] CommonJS가 브라우저 환경에 적합한지 판단할 수 있다.
- [ ] AMD vs CommonJS의 차이를 설명할 수 있다.
- [ ] UMD(Universal Module Definition)를 설명할 수 있다.
- [ ] UMD를 사용한 플러그인 개발 방법을 설명할 수 있다.

### CHAPTER 11: 네임스페이스 패턴

- [ ] 네임스페이스의 기초를 설명할 수 있다.
- [ ] 단일 전역 변수 패턴을 설명할 수 있다.
- [ ] 접두사 네임스페이스 패턴을 설명할 수 있다.
- [ ] 객체 리터럴 표기법 패턴을 설명할 수 있다.
- [ ] 중첩 네임스페이스 패턴을 설명할 수 있다.
- [ ] 즉시 실행 함수 표현식(IIFE) 패턴을 설명할 수 있다.
- [ ] 네임스페이스 주입 패턴을 설명할 수 있다.
- [ ] 중첩 네임스페이스 자동화 패턴을 설명할 수 있다.
- [ ] 의존성 선언 패턴을 설명할 수 있다.
- [ ] 심층 객체 확장 패턴을 설명할 수 있다.
- [ ] 권장하는 네임스페이스 패턴을 설명할 수 있다.

### CHAPTER 12: 리액트 디자인 패턴

- [ ] 리액트 소개와 기본 개념을 설명할 수 있다.
- [ ] 리액트 용어를 설명할 수 있다.
- [ ] 고차 컴포넌트(HOC)를 설명하고 구현할 수 있다.
- [ ] 고차 컴포넌트를 조합하는 방법을 설명할 수 있다.
- [ ] 고차 컴포넌트의 장단점을 설명할 수 있다.
- [ ] 렌더링 Props 패턴을 설명하고 구현할 수 있다.
- [ ] 상태 끌어올리기를 설명할 수 있다.
- [ ] 컴포넌트의 자식으로 함수를 전달하는 방법을 설명할 수 있다.
- [ ] 렌더링 Props 패턴의 장단점을 설명할 수 있다.
- [ ] 리액트 Hooks 패턴을 설명할 수 있다.
- [ ] 클래스 컴포넌트의 한계를 설명할 수 있다.
- [ ] 구조 변경의 필요성을 설명할 수 있다.
- [ ] 복잡성 증가 문제를 설명할 수 있다.
- [ ] Hooks의 개념과 사용법을 설명할 수 있다.
- [ ] 상태 Hook을 설명할 수 있다.
- [ ] 이펙트 Hook을 설명할 수 있다.
- [ ] 커스텀 Hook을 설명하고 구현할 수 있다.
- [ ] Hook의 장단점을 설명할 수 있다.
- [ ] Hook vs Class의 차이를 설명할 수 있다.
- [ ] 정적 가져오기를 설명할 수 있다.
- [ ] 동적 가져오기를 설명할 수 있다.
- [ ] 로더블 컴포넌트를 구현할 수 있다.
- [ ] 상호작용 시 모듈을 가져오는 방법을 설명할 수 있다.
- [ ] 화면에 보이는 순간 모듈을 가져오는 방법을 설명할 수 있다.
- [ ] 코드 스플리팅을 설명할 수 있다.
- [ ] 경로 기반 분할을 설명할 수 있다.
- [ ] 번들 분할을 설명할 수 있다.
- [ ] PRPL 패턴을 설명할 수 있다.
- [ ] 로딩 우선순위를 설명할 수 있다.
- [ ] SPA의 Preload를 설명할 수 있다.
- [ ] Preload + async 기법을 설명할 수 있다.
- [ ] 크롬 95+ 버전에서의 Preload를 설명할 수 있다.
- [ ] 리스트 가상화를 설명할 수 있다.
- [ ] 윈도잉/가상화의 작동 방식을 설명할 수 있다.
- [ ] List 컴포넌트를 구현할 수 있다.
- [ ] Grid 컴포넌트를 구현할 수 있다.
- [ ] 웹 플랫폼의 발전과 가상화의 관계를 설명할 수 있다.

### CHAPTER 13: 렌더링 패턴

- [ ] 렌더링 패턴의 중요성을 설명할 수 있다.
- [ ] 클라이언트 사이드 렌더링(CSR)을 설명할 수 있다.
- [ ] 서버 사이드 렌더링(SSR)을 설명할 수 있다.
- [ ] 정적 렌더링을 설명할 수 있다.
- [ ] 점진적 정적 생성(ISR)을 설명할 수 있다.
- [ ] On-demand ISR을 설명할 수 있다.
- [ ] 정적 렌더링의 장단점을 설명할 수 있다.
- [ ] 스트리밍 SSR을 설명할 수 있다.
- [ ] 엣지 SSR을 설명할 수 있다.
- [ ] 하이브리드 렌더링을 설명할 수 있다.
- [ ] 점진적 하이드레이션을 설명할 수 있다.
- [ ] 아일랜드 아키텍처를 설명할 수 있다.
- [ ] 아일랜드 아키텍처를 구현할 수 있다.
- [ ] 아일랜드 아키텍처의 장단점을 설명할 수 있다.
- [ ] 리액트 서버 컴포넌트(RSC)를 설명할 수 있다.
- [ ] RSC와 Next.js App Router를 활용한 하이브리드 렌더링을 설명할 수 있다.

### CHAPTER 14: 리액트 애플리케이션 구조

- [ ] 모듈, 기능 또는 경로별 그룹화 방법을 설명할 수 있다.
- [ ] 파일 유형별 그룹화 방법을 설명할 수 있다.
- [ ] 도메인 및 공통 컴포넌트 기반의 혼합 그룹화를 설명할 수 있다.
- [ ] 최신 리액트 기능을 위한 애플리케이션 구조를 설계할 수 있다.
- [ ] 리덕스를 사용한 애플리케이션 구조를 설명할 수 있다.
- [ ] 컨테이너 패턴을 설명할 수 있다.
- [ ] Hooks를 활용한 구조를 설명할 수 있다.
- [ ] Styled Components를 사용한 구조를 설명할 수 있다.
- [ ] 기타 모범 사례를 설명할 수 있다.
- [ ] Next.js 애플리케이션을 위한 애플리케이션 구조를 설계할 수 있다.

### CHAPTER 15: 결론

- [ ] 책에서 배운 디자인 패턴들을 정리하고 설명할 수 있다.
- [ ] 실무에 적용할 수 있는 패턴들을 선별할 수 있다.
- [ ] 프로젝트에 맞는 패턴 선택 기준을 설명할 수 있다.

---
