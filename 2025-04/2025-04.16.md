# TIL | 2025.04.16

## 주간 목표

-   계획한 미라클 모닝 자리잡기
-   스픽 에매랄드에서 승급하기
-   루틴 확립하기
-   오늘 다하려고 진행 순서에 적어둔게 아니다 내일 까먹을까봐 순서에 넣어둔거다
-   [벨로그](https://velog.io/@pigpgw/%EB%82%98%EC%9D%98-%EA%B0%9C%EB%B0%9C-%EC%84%B1%EC%9E%A5-%EC%A0%84%EB%9E%B5-%EC%83%9D%EA%B0%81%ED%95%98%EB%8A%94-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A1%9C-%EB%82%98%EC%95%84%EA%B0%80%EA%B8%B0)에 작성한 것들 습관화하기

### 오늘 진행 순서 예정

-   [x] 아침 운동 : 팔굽 100개
-   [x] 스픽
-   [x] 책 읽기 (소프트웨어 장인 ~ chapter 1)
-   [x] 유익한 유튜브 시청하기 [대부분이 코딩테스트 공부 잘못하고 있습니다.](https://www.youtube.com/watch?v=Wx91sqfouCs)
-   [x] 블로그 하나 읽기 [컴퓨팅 사고와 개발 실력 늘리는 공부법](https://yozm.wishket.com/magazine/detail/1950/)
-   [x] 알고리즘
-   [x] 스마게 회의
-   [x] 주시 회의
-   [x] 주시 작업
-   [x] 운동(가슴)
-   [x] 강의 수강
    -   알고리즘 : 섹션 6 Tree level order ~
    -   TS : 섹션8
    -   Next : 섹션4 App Router ~
    -   JS Test : 섹션 7: Mocking & Spies: Dealing with Side Effects

---

### 내 코드가 유지보수하기 좋은지 고민하기

-   요구사항이 변경되었을 때 잘 대응할 수 있을까?
-   예를 들어, 상품 목록 리스트를 구현한다고 하면:
    -   나중에 상품에 다른 값들이 추가될 때 수정이 쉬울까?
    -   상품과 관련된 동작이 더 추가될 가능성은 없을까?
    -   뷰가 변경된다면, 지금 구조로 쉽게 다른 뷰로 바꿀 수 있을까?

조금 상상의 나래를 펼쳐서, 내 코드가 이런 상황에 놓였을 때 쉽게 변경이 가능한지 고민해 본다.  
사실 정말 더 좋은 방법은, 프로젝트를 진행하면서 실제로 요구사항이 바뀌는 상황을 겪어보는 것.

그렇게 경험한 후에, 이론적인 개념과 매칭시키면서 회고해 보는 게 더 효과적이다.

> 문제 상황을 발견 → 근거를 가지고 리팩터링 → 회고  
> (이런 과정을 반복하면서, "이런 이유 때문에 바꿨다", 혹은 "좋은 코드니까 유지한다"는 식으로 계속 시도해 본다.)

-   코드의 본질적인 부분에 대해 많이 고민하는 것이 중요하다.
-   화려한 기술을 써야 하는 상황일 때도 있지만, 사이드 프로젝트나 개인 프로젝트에서는 본질에 더 집중하는 게 좋다.

---

# TIL

## 유익한 유튜브

코딩테스트 잘못된 공부 유형

-   무지성 양치기
-   무지성으로 제출->확인->제출->확인...
-   문제 풀고나서 바로 내팽겨치기
-   안풀리는 문제 며칠 몇주씩 잡고 있기
-   한번 푼 문제는 다신 안풀기
-   문제 읽자마자 분석&설계 없이 바로 코드 치기

풀이전

-   문제 분석 어떻게 풀어야할지 적으면서
-   시간복잡도 공간복잡도 분석

풀이 제출 전

-   테스트 케이스 만들어서 시뮬레이션 돌려보기(예외상황 꼭 생각해서 해보기 입력값 배열이 아무 원소도 없다면? 하나라면? 이런거)
-   풀이의 시간, 공간 복잡도 분석하기

풀이 제출 후

-   다른 사람들의 코드를 보며 다양한 풀이 방식 흡수
-   한달 내로 다시 와서 풀기 (15분 내로 풀 수 있을 때까지 반복)

---

## 블로그 하나 읽기 [컴퓨팅 사고와 개발 실력 늘리는 공부법](https://yozm.wishket.com/magazine/detail/1950/)

> 운동이라 생각하고 꾸준히 훈련하기 요구사항을 데이터 관점으로 사고하기

-   컴퓨터적인 사고란 사람의 언어로 작성된 요구사항을 컴퓨터가 이해할 수 있는 형태로 바꾸어 문제를 재정의하고 답을 찾는 과정이다.
-   컴퓨터는 숫자로 이루어져 있기 때문에 데이터의 관점에서만 이해할 수 있으며 데이터는 구조를 가지고 있어 추상화된 알고리즘을 활용할 수 있습니다.
-   이를 위해 변수, 타입, 조건, 반복, 함수 등을 통해 데이터의 구조와 알고리즘을 기술할 수 있습니다.
-   종합하면 컴퓨터적 사고는 요구사항을 데이터의 관점으로 이해하고 적절한 구조와 알고리즘을 선택하고 연결하여, 변수, 타입, 조건, 반복, 함수로 생각하여 표현하는 것을 의미한다.

### 의식적으로 훈련하기

> 첫째, **요구사항을 받았을 때 그 요구사항을 데이터의 관점에서 나눠서 적어보는 훈련을 해보세요.**

-   이를 통해 요구사항이 어떤 데이터를 다루는지 파악하고, 데이터를 어떻게 다룰지에 대한 방향성을 정할 수 있습니다.

> 둘째, **데이터의 구조를 먼저 기술하고 생각해 보는 연습을 해보세요.**

-   변수, 타입, 조건, 반복, 함수 등을 활용하여 데이터의 구조와 알고리즘을 기술하는 방법을 익혀보세요. 이를 통해 추상적인 개념을 구체적인 코드로 표현하는 능력을 기를 수 있습니다.

> 셋째, **적절한 알고리즘을 선택하는 연습을 해보세요.**

-   주어진 문제에 따라서 어떤 알고리즘이 적합한지를 판단하는 능력을 기를 수 있습니다. 이를 위해서는 많은 문제를 풀어보고 다양한 알고리즘을 경험해 보는 것이 중요합니다.

> 넷째, **기존 데이터의 구조와 알고리즘을 연결하여 새로운 데이터를 도출하는 연습을 해보세요.**

-   이를 통해 데이터를 어떻게 다룰지에 대한 방법과 알고리즘을 어떻게 적용할지를 연결하는 능력을 기를 수 있습니다.

## 알고리즘

-   시간 복잡도 강의 듣기
    -   for - while 중첩되었다고 무조건 n제곱이 아니다.
        -   어떻게 코드를 작성하냐에 따라 다름
    -   상수 시간도 완전 무시할 순 없다.
    -   코테 시간제한 기준점 : 10 ^ 8
    -   시간복잡도는 만능이 아니다.
    -   풀이에 대한 확신
    -   알고리즘 떠올리기

### 코테 적용 방법

-   Step1 문제 이해하기
    -   문제를 제대로 읽기
    -   제약조건 읽기
        -   효율성 테스트 10^8 넘으면 안됨
        -   원소 값의 범위
            -   int === 4byte => 1bit는 부호 31bit는 수 표현 -2^31 ~ 2^31 + 1
                -   2의 31승은 10의 9승 그러면 인트형 변수에 저장 불가
-   Step2 접근 방법
    -   직관적으로 생각하기
        -   보통 완전 탐색으로 시작
        -   문제 상황을 단순화 하여 생각하기
        -   문제 상황을 극한화 하여 생각하기
    -   자료구조와 알고리즘 활용
        -   Step1 문제이해 에서 파악한 내용을 토대로 어떤 자료구조를 사용하는게 가장 적합한지 결정
        -   대놓고 특정 자료구조와 알고리즘을 묻는 문제도 많음
        -   자료구조에 따라 선택할 수 있는 알고리즘을 문제에 적용
    -   메모리 사용
        -   시간복잡도를 줄이기 위해 메모리를 사용하는 방법
        -   대표적으로 해시테이블

### 대표 알고리즘

-   O(1): Operation push and pop on Stack
-   O(log n): Binary Tree
-   O(n): for loop
-   O(n×log n): Quick Sort, Merge Sort, Heap Sort
-   O(n2): Double for loop, Insert Sort, Bubble Sort, Selection Sort
-   O(2n): Fibonacci Sequence

### 문제 풀이 과정

-   step1 문제 이해하기
    -   input, output 확인
        -   input 값의 특징 (정수인가? 값 크기의 범위는? 마이너스도 되는건가? 소수인가? 자료형은 문자열인가? 등등)
        -   Output 값의 특징 (내가 어떤 값을 반환해줘야 하는지, 정해진 형식대로 반환하려면 어떻게 구현할지)
    -   input size N 확인
        -   시간복잡도를 계산하기 위한 input size N 또는 M 이 무엇인지 확인
    -   제약조건 확인
        -   시간복잡도 제한이 있는지 확인
        -   내가 선택할 수 있는 알고리즘이 무엇이 있는지
    -   예상할 수 있는 오류 파악
        -   상황을 가정하면서 예상할 수 있는 오류를 파악
        -   입력값의 범위 ,stack overflow 등

---

## [104 Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/description/)

### 문제 풀기전 분석

입력 : 노드 배열
출력 : 최대 노드 깊이
제약조건 :노드 숫자 [0,10^4] => n^2 까지 된다는 말인가?
종료조건 : val === undefined일때로 하자

풀이

-   재귀로 깊이를 넘겨주어 품

#### 어떻게 풀까

트리는 보통 재귀로 품 그냥 depth 설정하고 한번 더 실행될때마다 추가하기

---

# JS Test : vitest

## 1. mock 함수란?

> mock 함수는 테스트할 때 실제 동작을 흉내 내는 "가짜 함수"

### 왜 필요한가요?

-   **실제로 실행되면 안 되는 기능**이 있을 수 있음 (예: 결제, 이메일 발송, 콘솔 출력).
-   또는 함수가 **외부 시스템에 의존**해서 테스트하기 힘들 때 mock 함수로 대체하면 깔끔해잠

### 무엇을 알 수 있나요?

-   호출되었는지 여부
-   몇 번 호출됐는지
-   어떤 인자로 호출됐는지
-   어떤 값을 반환하는지 설정 가능

### 진짜 실행되나요?

-   아니요. `vi.fn()`으로 만든 함수는 **진짜 기능이 실행되지 않습니다**.
-   예를 들어 `console.log()`를 mock으로 바꾸면, 실제 로그는 출력되지 않고 '호출되었다'는 기록만 남음

---

## 2. `vi.fn()` – mock 함수 만들기

```js
const sayHello = vi.fn();
sayHello('건우');

expect(sayHello).toHaveBeenCalled();
expect(sayHello).toHaveBeenCalledWith('건우');
```

### 설명

-   `vi.fn()`은 "아무 동작도 하지 않는" mock 함수를 만듭니다.
-   `toHaveBeenCalled()` → 호출 여부 확인
-   `toHaveBeenCalledWith(arg)` → 어떤 인자로 호출되었는지 확인

🧠 실제로 이 함수가 무슨 일을 하든지 **우리는 '호출 여부'만 확인**할 수 있어요.

---

## 3. `mockReturnValue()` – 리턴값을 고정하기

```js
const getUserName = vi.fn().mockReturnValue('건우');
expect(getUserName()).toBe('건우');
```

### 언제 쓰나요?

-   이 함수가 **항상 같은 결과를 반환**해야 할 때
-   예: 서버에서 사용자 이름을 가져오는 API를 대신할 때

### 진짜 실행되나요?

-   내부 로직 없이, 그냥 정해진 값만 리턴됩니다.
-   `getUserName()`은 호출되면 항상 `'건우'`를 반환함

---

## 4. `mockImplementation()` – 동작을 직접 정의하기

```js
const greetUser = vi.fn().mockImplementation((name) => '안녕, ' + name);
expect(greetUser('건우')).toBe('안녕, 건우');
```

### 언제 쓰나요?

-   단순히 값만 반환하는 게 아니라, **특정 로직을 흉내 내고 싶을 때**
-   동적인 상황에 맞게 함수의 리턴을 바꾸고 싶을 때

### 진짜 실행되나요?

-   네! 여기서 말하는 '진짜'는 실제 함수가 아니라, **내가 정의한 가짜 함수 로직이 실행**된다는 의미입니다.
-   실제 서비스 로직은 실행되지 않고, 테스트용으로 지정한 로직만 실행됩니다.

---

## 5. `vi.spyOn()` – 실제 객체의 함수를 감시하기

```js
const calculator = {
    multiply(a, b) {
        return a * b;
    },
};

const spy = vi.spyOn(calculator, 'multiply');
calculator.multiply(2, 3);

expect(spy).toHaveBeenCalled();
expect(spy).toHaveBeenCalledWith(2, 3);
```

### 언제 쓰나요?

-   원래 있던 함수의 **호출 여부나 인자**만 확인하고 싶을 때
-   함수의 동작은 그대로 두되, **감시만** 하고 싶을 때

📌 `spyOn()`은 실제 동작을 유지하므로, 원하면 `.mockImplementation()`으로 막을 수도 있습니다.

### 진짜 실행되나요?

-   기본적으로는 **진짜 함수가 실행됩니다.**
-   하지만 `.mockImplementation()`을 쓰면 그 실행을 막고 대체할 수 있습니다.

---

## 6. `mockRestore()` – 원상복구

```js
const spy = vi.spyOn(obj, 'method').mockImplementation(() => {});
// 테스트 실행...
spy.mockRestore();
```

-   `spy`나 `mockImplementation`으로 바꾼 함수는 복구하지 않으면 **다음 테스트에 영향을 줄 수 있어요.**
-   `mockRestore()`는 원래 함수로 되돌리는 기능입니다.

📌 항상 테스트가 끝날 때마다 `mockRestore()` 해주는 습관을 들여야함

---

## 7. 실전 예제: spy + mockImplementation

```js
const calculatorSpy = vi.spyOn(calculator, 'multiply').mockImplementation(() => 999);
expect(calculator.multiply(100, 200)).toBe(999);
expect(calculatorSpy).toHaveBeenCalledWith(100, 200);
calculatorSpy.mockRestore();
```

### 어떤 상황?

-   원래 `multiply(100, 200)`는 `20000`을 반환해야 하지만
-   테스트 중에는 **항상 999만 나오도록** 바꿔놓은 거예요.

### 진짜 실행되나요?

-   원래 함수는 실행되지 않고, `mockImplementation`으로 정의한 값(`999`)만 반환됩니다.
-   즉, **가짜 동작을 대신 실행**하게 됩니다.

---

## 8. 자주 헷갈리는 질문 (FAQ)

### Q1. `spyOn(import한 함수)` 왜 안 되나요?

> `spyOn`은 객체 안의 함수만 감시할 수 있습니다.
> `import { log } from './logger'`는 그냥 함수라 감시 불가. 대신:

```js
import * as logger from './logger';
vi.spyOn(logger, 'log');
```

### Q2. `expect(fn()).toHaveBeenCalled()` 하면 왜 안 되나요?

> `fn()`은 함수 실행 결과를 나타내므로, mock 정보가 없습니다.
> 반드시 `expect(fn)` 으로 함수 자체를 넣어야 합니다.

### Q3. default export, named export 왜 중요해요?

> mock 대상이 어디에 속해있는지를 파악하는 데 필수입니다.

```js
// named export
export const calculator = { add() {} };
import { calculator } from './file';

// default export
export default calculator;
import calculator from './file';
```
