# TIL | 2025.04.07

### 오늘 진행 순서 예정

-   [x] 가벼운 런닝
-   [x] 스픽
-   [x] TIL 작성 방식 고민하기
-   [x] 하루 루틴 선정 기준 고민하기
-   [x] 블로그 하나 읽기 ([당근 썸머테크 인턴십 후기](https://velog.io/@gyutato/2023-%EC%8D%B8%EB%A8%B8%ED%85%8C%ED%81%AC-%ED%9B%84%EA%B8%B0))
    -   https://velog.io/@eddy_song/rejection
-   [x] 주시 작업

    -   [x] 개선 필요한 부분 검토 및 문서화 [ISSUE 주소](https://github.com/dev-4-team/eye-on-frontend/issues/53)
    -   [x] 역할 분배 [ISSUE 주소](https://github.com/dev-4-team/eye-on-frontend/issues/53)
    -   [x] 소켓 -> 폴링 마이그레이션 [PR 주소](https://github.com/dev-4-team/eye-on-frontend/pull/55)

-   [x] 주시 회의
-   [x] 주시 작업
-   [x] 공부할 키워드 공부
-   [] 스마게 작업
-   [] 알고리즘 강의 수강

---

# TIL

## TIL 작성 방식 및

> TIL : 본인이 오늘 하루 배운 것 혹은 경험하고 느낀 것들을 기록하고 회고하는 것

### TIL 작성 틀

-   난 이 TIL을 TODO 용으로도 사용하고있다. 우선 하루를 시작할떄 오늘 진행할 작업의 대략적인 틀을 작성한다.
    -   구체적으로 작성하려고 노력은 하겠지만 거기에 너무 많은 시간을 뺏기지 않게 진행하려한다.
        -   정해진 작업을 수행하면서 일정이 어떻게 달라질지 모르고 시간이 얼마나 소요될지 애매한 부분도 있기에 진행하면서 일정을 조율하려한다.
            -   일정 산출하는것도 실력이라 생각하기에 그런 연습까지도 진행하려고 하고있다.

### 기본적인 회고 관련

-   TIL을 쓰면서 경험하고 기록하고 회고하는 것은 하고있었지만 회고하는 과정에서 무언가 적기를 망설이게 되었다 예를들어 오늘 진행한 어떤 작업에대해서 기록하고 회고하면서 ~~ 내가 진행한 방식이 과연 좋은 방식인가 또는 맞는 방식인가를 잘 모르겠어서 적기를 꺼려한적도 있다.
-   하지만 오늘부터는 우선 적으면서 고민하고 점진적으로 올바른 방식을 찾아가기 위한 발판으로 삼으려고 결정했다.

### TIL 공유회

-   TIL 공유회를 위해서 오늘 내가 한 작업이나 새롭게 알게된 내용이라도 상대방이 알것 같으면 새로운 키워드나 모를것 같은 내용을 준비하려고 한적도 있는데 오히려 나도 잘 모르고 갑자기 찾아본거라 내가 기다한것 이상으로는 좋은 효과를 가져오지는 못하는 것 같다.
-   그래서 말 그대로 나의 TIL 즉 내가 오늘 하루 배운 것 혹은 경험하고 느낀 것을 공유하기로 마음먹었다.
-   말하는것도 연습이 필요하다. 내가 경험한 것이기에 어느정도 두루뭉실하게 말하면 난 알지만 상대방은 모른다. 상대방의 입장에서 상대방의 집중이 끊기지 않게 의식하며 전달하려는 노력을 할 예정이다.

---

## 미라클 모닝

-   최근 미라클 모닝을 위해서 계획을 세우고 진행하는데 뜻대로 되지않는 날이 생각보다 많았고 그 이유와 개선하기 위해 좋은 방법들을 찾아보고 적어보려한다.

### 미라클 모닝이 무너지는 이유(분석)

-   모든 습관을 30분,1시간이 아니라 5분단위 혹은 1분 단위로 형성한다.

    -   하기 싫고 힘들어보이는 일일수록 '작게 시작'하는 방법을 시도하면 효과적이다.
        -   전두엽이 계획과 집중력, 실행을 담당하고, 기저핵은 '습관'을 통제하는데 새로운 습관을 만들기 위해서는 전두엽을 사용해야한다.
            -   이 때 평소에 하지 않던 일을 하게 되면 전두엽에서 에너지를 과하게 사용하게 되는데, 에너지가 모두 떨어지면 습관을 담당하는 기저핵이 활동하게 된다
                -   그러면 기존에 하던 대로 방탕한 생활로 돌아가는데 요점은 이를 피하기 위해서는 아주 작게 시작해야 한다는 것이다.
                    -   > 매일 5분 또는 1분단위로 작게 전두엽을 훈련시켜서 뇌를 길들이자.

-   적절한 수면이 필요하다
    -   성인은 평균 7시간 (개인마다 피로함을 느끼지 않는 수면 시간이 있다. 본인의 에너지 패턴분석 필요)
-   바이오 리듬을 무너뜨리는 3가지 습관

    1.  자기 3시간 전까지 식사를 끝낸다.
        -   자기 전에 식사를하면 뇌와 몸을 회복해야 하는 에너지가 소화에 쓰인다.
    2.  자기 2시간 전에 샤워를 마무리한다.(보통은 자기 1~2시간 전에 따뜻한 샤워가 가장 효과적)
        -   자기 전에 따뜻한 물로 샤워하는것은 수면에 도움이 된다. 문제는 체온이 높아져 수면을 방해한다.
            -   샤워하면서 몸을 따뜻하게 하면, 피부 표면의 혈관이 확장돼서 열을 많이 방출할 준비를 함
            -   샤워가 끝나고 나면 체온이 빠르게 떨어지는데, 이 체온이 떨어지는 과정이 수면 유도를 도움
    3.  자기 직전까지 청색광(스마트폰,TV,PC)를 보진 않는가
        -   청색광은 수면 호르몬인 멜라토닌의 분비를 방해하여 깊은 수면에 드는것을 방해함 (우리가 지쳐 잠들때 뇌는 거의 1시간 동안 스마트폰의 자극으로 인해 꺠어 있는 상태가 됨)

### 미라클 모닝이 무너졌을때 돌파 방법(오늘 실패했을떄 다음으로 미루지말고 방법을 조정해서 내일 다시 시도한다.)

-   조금 무리라고 생각된다면 크기를 줄여서, 또는 다른 방식을 시도하기

-   미라클 모닝을 하려고 노력할거다. 원래는 쪽잠을 활용하여 중간에 잠오는 문제를 해결하였다. 이 방식에 대해서도 고민하고 찾아보려 한다.
    -   쪽잠을 자는 이유 20분정도 잠깐자면 이후 몇시간의 집중도가 올라가는데 잠자는시간 20분에 잠 꺠는 시간 10분이 아까워서 몇시간을 날리는게 손해라고 생각했다.
        -   하지만 실제로는 20분자고 10분 잠 깨고 핸드폰 보면 40분정도 지난다. 그리고 중요한건 잠을 늦게잔다. 최소 1시 30분
            -   > 이로인해 미라클 모닝이 힘들다.
-   오늘부터는 1시 이전에 잠이오면 그때는 낮잠을 자고 그 이후에 잠이오면 자지 않으려고 할것이다. 목표는 기상시간 6시가 목표이다.

### 나만의 아침 루틴에대한 고민

-   위와같은 내용을 이번 기회에 알았고 조금씩 노력해보려한다. 아래는 내가 추구하는 목표이다.

    > 아래는 내가 목표로하는 아침 루틴이다. 이 모든 작업은 9시까지 완료한다.

-   런닝(기상과 동시에): 예상 소요시간 20분
-   팔굽혀펴기 100개 : 10분
-   어떠한 운동(코어, 권혁 루틴 등등) : 20분
-   샤워 및 커피 세팅 : 20분
-   영어공부(스픽,cake도 고민중) : 20분
-   알고리즘 : 1시간?

> 도합 2시간 30분으로 6:30분에 기상하면 가능한 루틴이다.

## 블로그 하나 읽기 ([당근 썸머테크 인턴십 후기](https://velog.io/@gyutato/2023-%EC%8D%B8%EB%A8%B8%ED%85%8C%ED%81%AC-%ED%9B%84%EA%B8%B0))

### 준비 과정

-   당근 인턴으로서 내가 어필할 수 있는 부분은 무엇일지 고민하며 작성
-   프로젝트 진행 과정에서 내가 느꼈던 문제의식과 그에 따라 재 정의한 문제들, 해결 과정 전달하려고 노력함
    -   읽는 사람에게 내용들이 막힘없이 스토리텔링 될 수 있도록 함
-   공부했더 ㄴ내용들을 미리 블로그에 정리해두었던 것도 많은 도움이됨
-   이력서는 노션으로 만들지 않음 부족한 솜씨에 오히려 디메리트라 생각해 원티드로 작성

### 면접

-   구두로 간단히 주어진 케이스에 대해 어떻게 해결(구현)할 것인지 대답하기
-   평소 개발 스타일, 삶의 방식
-   인턴십을 통해 무엇을 얻어가고 싶은지
-   이력서에 적은 내용은 이미 포트폴리오와 블로그에 내용이 다 적혀있어서 면접 때 굳이 질문하지 않음

### 손가락 멈춰!

먼저, 냅다 손가락부터 움직이는 습관을 고치고 데이터의 흐름과 구조를 먼저 들여다보게 되었다. 코드 파악이 덜 된 상태에서 빠르게 기능을 만들어내는 데 집중하다 보니 여기저기 side-effect를 유발했고, 불필요한 수정이 잦아지는 걸 느꼈다.

-   대체 컴포넌트 만들면서 인터페이스 바꿔버리기
-   상위 컴포넌트에서 하위 컴포넌트 스타일링 제어하기
-   버그 발생 지점(원인 지점 X)에서 바로 수정하기 등등

잠깐만 생각해 봐도 내 발목을 붙잡았던 여러 실수들이 스쳐지나간다. 구조를 조금 더 넓은 시야로 봤어야 했는데, 당장 문제가 보이는 그 지점에 꽂혀서 바로 구현에 들어간 것이 원인인 경우가 많았다. 더군다나 데이터 흐름이나 구조가 머릿속에서 충분히 정리되지 않은 상태로 구현을 시작하면, 처음에는 무언가 되는 것 같다가도 마무리 단계에서 깔끔하게 태스크를 끝내지 못하고 자잘한 수정들로 늘어지거나 코드 속에서 길을 잃는 것이 느껴졌다. 그래서 태스크를 시작하면 가장 먼저 관련 로직들과 데이터 흐름을 파악해서 정리해 놓고, 머릿속에서 어느정도 구조가 잡힐 때 구현에 들어가려 노력했다.

> 문제 해결 방식 4단계 [문제 재현 → 데이터 흐름 → 원인 파악 → 가설 수립 및 검증]
>
> -   문제 재현
> -   데이터 흐름
> -   원인 파악
> -   가설 수립 및 검증

### 자신감 넘치는 디버깅을 위해

-   문제를 진단하는 프로세스 만들기 - 모든 디버깅은 소거법 (가능한 케이스들을 찾고, 빠르게 지워 나가야함, 이 관점에서 디버깅이 늘어나는 이유 원인 진단 필요) - 가설을 정확히 정의하지 못한 경우 - 가설을 정확히 정의했으나, 검증의 답을 명확히 얻지 못한 경우
    > 이 두가지 이유의 근본적인 문제는 '기반 지식의 부족'
-   ex : 렌더링 이슈
    -   리엑트 컴포넌트 생명 주기와 렌더링 순서, 이에 영향을 미치는 effect등에 대한 개념이 정확하게 들어 있어야 가설을 빠르게 세우고 검증 가능한데 그게 안됨
-   가설을 최대한 작게, 구체적으로 세우기

### 이유를 댈 수 있는 코드 작성하기

-   코든 코드는 결정사항이다.
    -   어떤 구조로 만들어야 유지보수성이 지속될 수 있을지, 어떤 방식으로 구현해야 기존의 성능을 해치지 않을지, 관심사는 어떤 형태로 분리하는게 좋을지

### 목적 조직에서 기여하기

-   얼마 만큼의 리소스를 들여 어느정도로 문제를 해결할 지 스스로 정할 수 있는 기준
    -   어떤 문제를 해결할려 하는지
    -   해결하고 난 상태는 어떻게 되어 있어야 하는지
    -   어떤 과정을 거쳐야 이 문제가 해결되는지
-   각 태스크에 적용할 미니 OKR 만들고 최대한 따라 보려고 노력하기

## 공부하고 싶은 것들

-   [x] css
    -   css 잘 설계하는법
    -   css 잘하는법
        -   [링크](https://velog.io/@teo/CSS-%EA%B3%B5%EB%B6%80-%EC%96%B4%EB%96%BB%EA%B2%8C-%ED%95%B4%EC%95%BC-%ED%95%98%EB%82%98%EC%9A%94-%EC%9D%B4%EB%A1%A0%ED%8E%B8-feat.-figma)
            -   마진을 가급적 쓰지마라
                -   css가 애매해지고 복잡해지는 첫 번째 이유이다.
                    -   마진을 쓰면 고려해야하는게 많다. (마진 콜랩스, 등등)
                    -   꼭 마진을 써야하나 고민해보기
            -   대부분의 레이아웃은 거의 Flexbox로 가능하다.
    -   css variant
-   js

    -   abortcontroller
        -   자바스크립트에서 fetch 요청을 중단할 수 있는 것, 비동기 테스트 중단시키는 기술
    -   v8 엔진 [url](https://velog.io/@qlgks1/javascript-node-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC)
    -   js 컴파일 과정

        ### 📌 1. 자바스크립트 개요

        -   웹페이지에 동적 기능을 추가하는 언어
        -   브라우저가 `<script>` 태그를 만나면 파싱 중단 → 코드 실행
        -   브라우저/서버(Node.js) 모두에서 동작 (V8, SpiderMonkey 등 다양한 엔진)

        ### 📌 2. 컴파일 기본 개념

        -   소스코드를 기계어로 번역하는 과정
        -   목적: 사람이 이해하는 언어(고급언어)를 컴퓨터가 이해하는 언어(기계어)로

        **컴파일러 vs 인터프리터**

        -   **컴파일러**: 전체 코드 → 기계어 변환 → 실행 파일
        -   **인터프리터**: 코드를 한 줄씩 읽으면서 바로 실행
        -   JavaScript는 전통적으로 인터프리터 방식 사용
        -   인터프리터는 이식성, 컴파일러는 속도에 강점

        ### 📌 3. JIT 컴파일러 (Just In Time)

        -   런타임에 코드를 기계어로 번역
        -   바이트 코드 → 기계어로 변환 후 캐시에 저장하여 재사용
        -   인터프리터보다 빠르고, 컴파일러만큼은 아님
        -   단점: 메모리 많이 사용, 초기 컴파일 시간 존재

        ### 📌 4. JavaScript에서의 실행 과정

        1. **소스코드 → 바이트 코드**

        -   렉싱 → 파싱(AST) → 바이트코드 생성 (Ignition)

        2. **바이트 코드 → 실행**

        -   Ignition 인터프리터로 실행
        -   반복이 많은 부분(hotspot)은 JIT 컴파일러(TurboFan)가 native code로 변환 후 실행

        **문제점**

        -   JS는 동적 타입 → JIT이 예외 케이스까지 모두 고려해야 함
        -   hotspot이 적은 경우가 많음 → native code 생성 오버헤드
        -   일부 연구에서는 JS JIT 효과가 크지 않다고 분석

        ### 📌 5. Adaptive JIT (적응형 컴파일)

        -   요즘 JS 엔진(V8 등)은 Adaptive JIT을 사용
        -   실행 초기에는 인터프리터로 실행
        -   **Hotspot 발견 시 JIT 적용**
        -   JIT도 단계적 (baseline → optimizing)
        -   타입 프로파일링을 통해 타입이 안 바뀌면 최적화된 코드 사용
        -   예외 상황 시 다시 baseline JIT 코드로 복귀

        **요약**

        -   **전통적인 JS 코드**: 인터프리터 효율적
        -   **연산 많은 JS 코드**: JIT 효율적
        -   Adaptive JIT로 두 가지 상황을 모두 커버!

        ***

        ### 📌 결론: JavaScript 엔진의 실행 최적화 흐름

        ```
        소스코드
        ↓ (렉싱/파싱)
        AST
        ↓ (컴파일)
        바이트 코드 (Ignition 인터프리터)
        ↓ (핫스팟 감지 시)
        Native Code (TurboFan JIT 컴파일러)
        ```

        -   자주 실행되는 부분은 native code로 변환되어 빠르게 실행
        -   변화가 없을 것으로 예상되는 타입에 대해 aggressive 최적화
        -   동적인 변화 발생 시 baseline 코드로 복귀

-   [x] css
    -   css 잘 설계하는법
    -   css 잘하는법
        -   [링크](https://velog.io/@teo/CSS-%EA%B3%B5%EB%B6%80-%EC%96%B4%EB%96%BB%EA%B2%8C-%ED%95%B4%EC%95%BC-%ED%95%98%EB%82%98%EC%9A%94-%EC%9D%B4%EB%A1%A0%ED%8E%B8-feat.-figma)
            -   마진을 가급적 쓰지마라
                -   css가 애매해지고 복잡해지는 첫 번째 이유이다.
                    -   마진을 쓰면 고려해야하는게 많다. (마진 콜랩스, 등등)
                    -   꼭 마진을 써야하나 고민해보기
            -   대부분의 레이아웃은 거의 Flexbox로 가능하다.
-   js

    -   abortcontroller
        -   자바스크립트에서 fetch 요청을 중단할 수 있는 것, 비동기 테스트 중단시키는 기술
    -   v8 엔진 [url](https://velog.io/@qlgks1/javascript-node-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC)
    -   js 컴파일 과정

## 알고리즘

-   강의 수강(코딩 테스트 팁 ~ 시간복잡도 총 정리)
    -   자료구조 : 데이터를 저장하고 관리하는 방식
        -   데이터를 체계적으로 저장하여 메모리를 효율적으로 사용할 수 있게 하고, 빠르고 안정적으로 데이터를 처리할 수 있도록 도와줌
    -   알고리즘 : 문제 해결 방법 : 어떠한 문제를 해결하기 위해 정해진 일련의 절차나 방법

### 코딩테스트를 위한 시간복잡도

> 문제 이해하기 -> 접근 방법 -> 코드 설계 -> 코드 구현

-   시간 복잡도 활용법 in 코테

    1. 시간복잡도 이해하고 외우기
    2. 제한 조건 보는 법
    3. 다양한 접근

-   Step1 문제 이해하기
    -   1.2 제한조건 보는법
        -   보통 10 의 8승
            -   인풋중에 어떤걸 n으로 설정 가능한지
            -   인풋에서 어떤 정보가 실행 시간을 을리는지
                -   그리고 나서야 시간복잡도가 몇인 알고리즘을 써야할지 결정

### 시간 복잡도 특강

-   실행시간

    -   프로그램이 실제로 실행되는 데 걸리는 시간
    -   측정 방법 : 프로그램을 실제로 실행해보는 방법, 여러 번 실행하여 평균값을 구하는 방식이 일반적
    -   결론 실행시간은 결국 실제 돌려봐야 안다.
        -   실행시간에 영향을 주는 요소
            -   시스템 부하 : 현재 실행중인 다른 프로그램
            -   I/O 대기 시간 :디스크, 네트워크 등 외부 자원에 대한 접근 시간
            -   하드웨어 성능 : CPU, 메모리 등의 성능 차이
            -   운영체제의 스케줄링 : 프로세스 스케줄러에 의한 CPU 자원 배분
    -   javascript는 console.time() 사용

-   시간 복잡도

    -   실행 시관과 입력값 n의 합수 관계
    -   어떤 수치가 반복 횟수에 영향을 주는지
    -   빅오(점근표기법)
        -   복잡한 시간복잡도를 간단하게 표현하기 위해서 시간복잡도의 최고차항수만은 이용해 빅오 표기법을 쓸 수 있음

-   실행시간 vs 시간 복잡도

    -   시간복잡도를 통해서 실행 시간을 정확하게 알 수 는 없다.
    -   그냥 경향성만 파악하는게 우리 목표다.

-   sort : nlogn
-   deque
    -   파이썬에선 (deque와 list 둘다 가능한데 list로 구현하면 pop시 모든 값들을 앞으로 떙겨줘야해서 O(n) deque는 O(1))
        -   deque
        -   list

### 시간복잡도 심화

-   for문과 while문이 중첩되었다고 n 제곱이 아니다.

### 표기법 종류

-   위 그래프에서 보이는 것처럼 시간복잡도의 효율성에 따라서 구분되는 알고리즘에 따른 표기법이 있습니다.
    > 효율성 : O(1) >O(log n) > O(n) > O(n x log n) > O(n^2) > O(2^n)

### 대표 알고리즘

-   O(1): Operation push and pop on Stack
-   O(log n): Binary Tree
-   O(n): for loop
-   O(n×log n): Quick Sort, Merge Sort, Heap Sort
-   O(n2): Double for loop, Insert Sort, Bubble Sort, Selection Sort
-   O(2n): Fibonacci Sequence
