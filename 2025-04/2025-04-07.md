# TIL | 2025.04.07

### 오늘 진행 순서 예정

-   [x] 가벼운 런닝
-   [x] 스픽
-   [x] TIL 작성 방식 고민하기
-   [x] 하루 루틴 선정 기준 고민하기
-   [x] 블로그 하나 읽기 ([당근 썸머테크 인턴십 후기](https://velog.io/@gyutato/2023-%EC%8D%B8%EB%A8%B8%ED%85%8C%ED%81%AC-%ED%9B%84%EA%B8%B0))
-   [] 주시 작업

    -   [x] 개선 필요한 부분 검토

-   [] 주시 회의
-   [] 주시 작업
-   [] 공부할 키워드 공부
-   [] 스마게 작업
-   [] 알고리즘 강의 수강

---

# TIL

## TIL 작성 방식 및

> TIL : 본인이 오늘 하루 배운 것 혹은 경험하고 느낀 것들을 기록하고 회고하는 것

### TIL 작성 틀

-   난 이 TIL을 TODO 용으로도 사용하고있다. 우선 하루를 시작할떄 오늘 진행할 작업의 대략적인 틀을 작성한다.
    -   구체적으로 작성하려고 노력은 하겠지만 거기에 너무 많은 시간을 뺏기지 않게 진행하려한다.
        -   정해진 작업을 수행하면서 일정이 어떻게 달라질지 모르고 시간이 얼마나 소요될지 애매한 부분도 있기에 진행하면서 일정을 조율하려한다.
            -   일정 산출하는것도 실력이라 생각하기에 그런 연습까지도 진행하려고 하고있다.

### 기본적인 회고 관련

-   TIL을 쓰면서 경험하고 기록하고 회고하는 것은 하고있었지만 회고하는 과정에서 무언가 적기를 망설이게 되었다 예를들어 오늘 진행한 어떤 작업에대해서 기록하고 회고하면서 ~~ 내가 진행한 방식이 과연 좋은 방식인가 또는 맞는 방식인가를 잘 모르겠어서 적기를 꺼려한적도 있다.
-   하지만 오늘부터는 우선 적으면서 고민하고 점진적으로 올바른 방식을 찾아가기 위한 발판으로 삼으려고 결정했다.

### TIL 공유회

-   TIL 공유회를 위해서 오늘 내가 한 작업이나 새롭게 알게된 내용이라도 상대방이 알것 같으면 새로운 키워드나 모를것 같은 내용을 준비하려고 한적도 있는데 오히려 나도 잘 모르고 갑자기 찾아본거라 내가 기다한것 이상으로는 좋은 효과를 가져오지는 못하는 것 같다.
-   그래서 말 그대로 나의 TIL 즉 내가 오늘 하루 배운 것 혹은 경험하고 느낀 것을 공유하기로 마음먹었다.
-   말하는것도 연습이 필요하다. 내가 경험한 것이기에 어느정도 두루뭉실하게 말하면 난 알지만 상대방은 모른다. 상대방의 입장에서 상대방의 집중이 끊기지 않게 의식하며 전달하려는 노력을 할 예정이다.

---

## 미라클 모닝

-   최근 미라클 모닝을 위해서 계획을 세우고 진행하는데 뜻대로 되지않는 날이 생각보다 많았고 그 이유와 개선하기 위해 좋은 방법들을 찾아보고 적어보려한다.

### 미라클 모닝이 무너지는 이유(분석)

-   모든 습관을 30분,1시간이 아니라 5분단위로 형성한다.

    -   하기 싫고 힘들어보이는 일일수록 '작게 시작'하는 방법을 시도하면 효과적이다.
        -   전두엽이 계획과 집중력, 실행을 담당하고, 기저핵은 '습관'을 통제하는데 새로운 습관을 만들기 위해서는 전두엽을 사용해야한다.
            -   이 때 평소에 하지 않던 일을 하게 되면 전두엽에서 에너지를 과하게 사용하게 되는데, 에너지가 모두 떨어지면 습관을 담당하는 기저핵이 활동하게 된다
                -   그러면 기존에 하던 대로 방탕한 생활로 돌아가는데 요점은 이를 피하기 위해서는 아주 작게 시작해야 한다는 것이다.
                    -   > 매일 1분단위로 작게 전두엽을 훈련시켜서 뇌를 길들이자.

-   적절한 수면이 필요하다
    -   성인은 평균 7시간 (개인마다 피로함을 느끼지 않는 수면 시간이 있다. 본인의 에너지 패턴분석 필요)
-   바이오 리듬을 무너뜨리는 3가지 습관

    1.  자기 3시간 전까지 식사를 끝낸다.
        -   자기 전에 식사를하면 뇌와 몸을 회복해야 하는 에너지가 소화에 쓰인다.
    2.  자기 2시간 전에 샤워를 마무리한다.(보통은 자기 1~2시간 전에 따뜻한 샤워가 가장 효과적)
        -   자기 전에 따뜻한 물로 샤워하는것은 수면에 도움이 된다. 문제는 체온이 높아져 수면을 방해한다.
            -   샤워하면서 몸을 따뜻하게 하면, 피부 표면의 혈관이 확장돼서 열을 많이 방출할 준비를 함
            -   샤워가 끝나고 나면 체온이 빠르게 떨어지는데, 이 체온이 떨어지는 과정이 수면 유도를 도움
    3.  자기 직전까지 청색광(스마트폰,TV,PC)를 보진 않는가
        -   청색광은 수면 호르몬인 멜라토닌의 분비를 방해하여 깊은 수면에 드는것을 방해함 (우리가 지쳐 잠들때 뇌는 거의 1시간 동안 스마트폰의 자극으로 인해 꺠어 있는 상태가 됨)

### 미라클 모닝이 무너졌을때 돌파 방법(오늘 실패했을떄 다음으로 미루지말고 방법을 조정해서 내일 다시 시도한다.)

-   조금 무리라고 생각된다면 크기를 줄여서, 또는 다른 방식을 시도하기

-   미라클 모닝을 하려고 노력할거다. 원래는 쪽잠을 활용하여 중간에 잠오는 문제를 해결하였다. 이 방식에 대해서도 고민하고 찾아보려 한다.
    -   쪽잠을 자는 이유 20분정도 잠깐자면 이후 몇시간의 집중도가 올라가는데 잠자는시간 20분에 잠 꺠는 시간 10분이 아까워서 몇시간을 날리는게 손해라고 생각했다.
        -   하지만 실제로는 20분자고 10분 잠 깨고 핸드폰 보면 40분정도 지난다. 그리고 중요한건 잠을 늦게잔다. 최소 1시 30분
            -   > 이로인해 미라클 모닝이 힘들다.
-   오늘부터는 1시 이전에 잠이오면 그때는 낮잠을 자고 그 이후에 잠이오면 자지 않으려고 할것이다. 목표는 기상시간 6시가 목표이다.

### 나만의 아침 루틴에대한 고민

-   위와같은 내용을 이번 기회에 알았고 조금씩 노력해보려한다. 아래는 내가 추구하는 목표이다.

    > 아래는 내가 목표로하는 아침 루틴이다. 이 모든 작업은 9시까지 완료한다.

-   런닝(기상과 동시에): 예상 소요시간 20분
-   팔굽혀펴기 100개 : 10분
-   어떠한 운동(코어, 권혁 루틴 등등) : 20분
-   샤워 및 커피 세팅 : 20분
-   영어공부(스픽,cake도 고민중) : 20분
-   알고리즘 : 1시간?

> 도합 2시간 30분으로 6:30분에 기상하면 가능한 루틴이다.

## 블로그 하나 읽기 ([당근 썸머테크 인턴십 후기](https://velog.io/@gyutato/2023-%EC%8D%B8%EB%A8%B8%ED%85%8C%ED%81%AC-%ED%9B%84%EA%B8%B0))

### 준비 과정

-   당근 인턴으로서 내가 어필할 수 있는 부분은 무엇일지 고민하며 작성
-   프로젝트 진행 과정에서 내가 느꼈던 문제의식과 그에 따라 재 정의한 문제들, 해결 과정 전달하려고 노력함
    -   읽는 사람에게 내용들이 막힘없이 스토리텔링 될 수 있도록 함
-   공부했더 ㄴ내용들을 미리 블로그에 정리해두었던 것도 많은 도움이됨
-   이력서는 노션으로 만들지 않음 부족한 솜씨에 오히려 디메리트라 생각해 원티드로 작성

### 면접

-   구두로 간단히 주어진 케이스에 대해 어떻게 해결(구현)할 것인지 대답하기
-   평소 개발 스타일, 삶의 방식
-   인턴십을 통해 무엇을 얻어가고 싶은지
-   이력서에 적은 내용은 이미 포트폴리오와 블로그에 내용이 다 적혀있어서 면접 때 굳이 질문하지 않음

### 손가락 멈춰!

먼저, 냅다 손가락부터 움직이는 습관을 고치고 데이터의 흐름과 구조를 먼저 들여다보게 되었다. 코드 파악이 덜 된 상태에서 빠르게 기능을 만들어내는 데 집중하다 보니 여기저기 side-effect를 유발했고, 불필요한 수정이 잦아지는 걸 느꼈다.

-   대체 컴포넌트 만들면서 인터페이스 바꿔버리기
-   상위 컴포넌트에서 하위 컴포넌트 스타일링 제어하기
-   버그 발생 지점(원인 지점 X)에서 바로 수정하기 등등

잠깐만 생각해 봐도 내 발목을 붙잡았던 여러 실수들이 스쳐지나간다. 구조를 조금 더 넓은 시야로 봤어야 했는데, 당장 문제가 보이는 그 지점에 꽂혀서 바로 구현에 들어간 것이 원인인 경우가 많았다. 더군다나 데이터 흐름이나 구조가 머릿속에서 충분히 정리되지 않은 상태로 구현을 시작하면, 처음에는 무언가 되는 것 같다가도 마무리 단계에서 깔끔하게 태스크를 끝내지 못하고 자잘한 수정들로 늘어지거나 코드 속에서 길을 잃는 것이 느껴졌다. 그래서 태스크를 시작하면 가장 먼저 관련 로직들과 데이터 흐름을 파악해서 정리해 놓고, 머릿속에서 어느정도 구조가 잡힐 때 구현에 들어가려 노력했다.

> 문제 해결 방식 4단계 [문제 재현 → 데이터 흐름 → 원인 파악 → 가설 수립 및 검증]
>
> -   문제 재현
> -   데이터 흐름
> -   원인 파악
> -   가설 수립 및 검증

### 자신감 넘치는 디버깅을 위해

-   문제를 진단하는 프로세스 만들기 - 모든 디버깅은 소거법 (가능한 케이스들을 찾고, 빠르게 지워 나가야함, 이 관점에서 디버깅이 늘어나는 이유 원인 진단 필요) - 가설을 정확히 정의하지 못한 경우 - 가설을 정확히 정의했으나, 검증의 답을 명확히 얻지 못한 경우
    > 이 두가지 이유의 근본적인 문제는 '기반 지식의 부족'
-   ex : 렌더링 이슈
    -   리엑트 컴포넌트 생명 주기와 렌더링 순서, 이에 영향을 미치는 effect등에 대한 개념이 정확하게 들어 있어야 가설을 빠르게 세우고 검증 가능한데 그게 안됨
-   가설을 최대한 작게, 구체적으로 세우기

### 이유를 댈 수 있는 코드 작성하기

-   코든 코드는 결정사항이다.
    -   어떤 구조로 만들어야 유지보수성이 지속될 수 있을지, 어떤 방식으로 구현해야 기존의 성능을 해치지 않을지, 관심사는 어떤 형태로 분리하는게 좋을지

### 목적 조직에서 기여하기

-   얼마 만큼의 리소스를 들여 어느정도로 문제를 해결할 지 스스로 정할 수 있는 기준
    -   어떤 문제를 해결할려 하는지
    -   해결하고 난 상태는 어떻게 되어 있어야 하는지
    -   어떤 과정을 거쳐야 이 문제가 해결되는지
-   각 태스크에 적용할 미니 OKR 만들고 최대한 따라 보려고 노력하기

---

## 알고리즘

-   강의 수강(코딩 테스트 팁 ~ 시간복잡도 총 정리)

## 주시

-   css
    -   css 잘 설계하는법
    -   css 잘하는법
    -   css variant
-   js
    -   abortcontroller
    -   v8 엔진
    -   js 컴파일 과정
-   타입 스크립트
    -   타입스크립트의 컴파일 과정
-   공통 컴포넌트 설계
    -   rest
    -   기본 타입 확장
        -   공통 버튼 컴포넌트 만드는데 어떻게 해야할지 모르겠음,
-   React
    -   리엑트에서의 단일 책임 원칙
    -   리엑트 쿼리 사람답게 쓰기
        -   []
-   next
    -   next Image
    -   next 에서 fetch
    -   next에서 react query
    -   Next.js 에서 local, development, production 환경 셋팅하기
-   작업
    -   next에서 fetch params next invalidate
    -   리엑트 쿼리의 도입이 올바른가
    -   현재 구현된 소켓 로직 다시 생각
        -   현재 구조를 그려보기
        -   개선점 파악하기
        -   있다면 개선
        -   에러처리 생각하기
        -   최적화 부분 생각하기
    -   구현한 폴링 방식 올바른가 (그려보기)
        -   현재 구조를 그려보기
        -   개선점 파악하기
        -   있다면 개선
        -   에러처리 생각하기
        -   최적화 부분 생각하기

## 스마게

-   DM
    -   연아님이 작성하신 다이렉트 메세지 컴포넌트 분리(워크스페이스 홈의 사이드바에서 다이렉트 메세지 누르면 해당 다이렉트 메세지 나와야하는데 안되어있음)
-   채팅
    -   싹 다 고쳐야함

---

# 한 입 크기로 잘라먹는 타입스크립트

-

# 패턴으로 익히고 설계로 완성하는 리액트

-   ch4 리액트 컴포넌트 설계하기 ~

---

## 1. 타입스크립트 동작 원리

### 타입스크립트의 컴파일 과정

-   TypeScript는 `.ts` 파일을 **JavaScript로 컴파일**하는 정적 타입 언어이다.
-   실제 실행은 브라우저나 Node.js가 하며, TypeScript는 **타입 검사 후 JavaScript 코드로 트랜스파일**된다.
-   타입 정보는 런타임에서 제거되고 **개발 시점에서만 존재**한다.

```txt
.ts (타입 검사 + 트랜스파일) → .js → Node.js 또는 브라우저 실행
```

-   컴파일러(tsc)는 설정(`tsconfig.json`)에 따라 코드 검사 및 변환을 수행한다.

---

### `implements`로 추상 클래스 구현

-   TypeScript에서 `implements`는 클래스가 인터페이스나 추상 클래스의 **타입 구조를 만족**하도록 강제하는 키워드이다.
-   추상 클래스는 실제 JavaScript에서는 **컴파일 시 사라진다**.
-   즉, 타입 수준에서만 체크되며, 런타임에는 **interface나 abstract class 모두 존재하지 않음**.

---

## 2. 구조적 타이핑 (Structural Typing)

-   TypeScript는 **구조적 타입 시스템**을 가진다.
-   이름보다 **형태(shape)** 를 기준으로 타입을 비교한다.
-   명시적으로 `Point` 타입이 아니어도 **구조만 맞으면 통과**된다.

---

## 3. `extends` vs `implements` 차이

| 구분        | `extends`                        | `implements`          |
| ----------- | -------------------------------- | --------------------- |
| 대상        | 클래스, 추상 클래스              | 인터페이스            |
| 의미        | 상속 (상위 클래스 기능 물려받음) | 구조(인터페이스) 만족 |
| 런타임 영향 | 있음 (프로토타입 체인)           | 없음 (타입 체크만)    |

-   `extends`는 실제 실행 코드에도 영향을 줌.
-   `implements`는 **타입 검사**를 위한 선언에 불과함.

---

## 4. `class`와 `interface` 차이

| 항목        | `class`             | `interface`              |
| ----------- | ------------------- | ------------------------ |
| 런타임 존재 | 있음                | 없음                     |
| 인스턴스화  | 가능                | 불가능                   |
| 상속 방식   | extends (단일 상속) | extends (다중 상속 가능) |
| 목적        | 구현체              | 타입 정의                |

-   `interface`는 오직 **타입 검사 용도**
-   `class`는 실제 **코드 구조와 동작을 포함**

---

## React Query는 HTTP 요청 외의 비동기 작업에도 사용할 수 있다.

React Query는 **"비동기 작업"을 캐시하고 관리하는 라이브러리**지, 꼭 HTTP 요청에만 국한되지 않는다.

### 주의

-   **queryKey**는 식별자 역할
-   side-effect가 없고, 순수하게 캐시 가능한 작업에 적합

---

# 프론트엔드 아키텍처

## 뷰 로직과 비즈니스 로직의 분리

### 목적

-   **컴포넌트 재사용성 증가**
-   **유지보수성 향상**
-   **테스트 용이성 확보**

### 예시

#### 뷰 로직 (UI 컴포넌트)

```tsx
const ProductCard = ({ product, onBuy }: Props) => {
    return (
        <div>
            <p>{product.name}</p>
            <button onClick={() => onBuy(product.id)}>구매</button>
        </div>
    );
};
```

#### 비즈니스 로직 (커스텀 훅)

```ts
const useBuyProduct = () => {
    const mutation = useMutation((productId) => buyAPI(productId));
    return mutation;
};
```

### 좋은 구조

-   UI: 입력 → 출력에 집중 (props 기반)
-   로직: 상태 관리, 요청 처리 등은 **hooks나 service 파일로 분리**

## 공부하고 싶은 키워드

## 1. **소프트웨어 설계 원칙 관련**

| 주요 개념                                  | 설명                                           | 함께 공부하면 좋은 개념                                                                   |
| ------------------------------------------ | ---------------------------------------------- | ----------------------------------------------------------------------------------------- |
| **관심사의 분리 (Separation of Concerns)** | 기능/책임/영역을 나눠서 복잡도를 낮추는 원칙   | - SRP (단일 책임 원칙)<br>- 모듈화(Modularity)<br>- MVC/MVVM 패턴<br>- 레이어드 아키텍처  |
| **추상화 계층 (Abstraction Layer)**        | 하위 로직을 숨기고 필요한 기능만 노출하는 구조 | - 캡슐화<br>- 인터페이스 / 추상 클래스<br>- 레이어드 아키텍처<br>- 의존성 역전 원칙 (DIP) |
| **비즈니스 로직 (Business Logic)**         | 애플리케이션의 핵심 규칙/기능을 수행하는 부분  | - 도메인 모델<br>- 서비스 계층<br>- 유스케이스<br>- 엔티티(Entity), DTO                   |

---

## 2. **프론트엔드 구조/설계**

| 주요 개념                                | 설명                                        | 함께 공부하면 좋은 개념                                                     |
| ---------------------------------------- | ------------------------------------------- | --------------------------------------------------------------------------- |
| **Container vs Presentational 컴포넌트** | 비즈니스 로직과 UI 로직을 나누는 React 설계 | - 관심사 분리<br>- 컴포넌트 책임 분리<br>- Hooks 구조화                     |
| **상태 관리 구조 (Zustand, Redux, etc)** | 상태를 어디서/어떻게 다룰지 정의            | - 비즈니스 로직 위치<br>- Store 분리 전략<br>- Selector, middleware         |
| **API Layer 분리**                       | API 요청을 별도 레이어로 나눔               | - Axios 커스텀 인스턴스<br>- Query Hook abstraction<br>- Service Layer 구조 |

---

## 4. **실무 적용 관점 (실제로 설계할 때 유용한 개념)**

| 실무에서 접하는 개념    | 연관 개념                                     |
| ----------------------- | --------------------------------------------- |
| 서비스 레이어 설계      | 비즈니스 로직 분리, 추상화 계층, 관심사 분리  |
| 공통 API 오류 처리      | Axios 인터셉터, API 추상화 계층               |
| 유저 인증 흐름          | 상태 관리 분리, 관심사 분리, 로직 단위 모듈화 |
| 파일 구조 설계          | 기능/도메인 기반 구조 → 관심사 분리           |
| 테스트 설계 (단위/통합) | 비즈니스 로직과 UI 로직 분리 필요             |

### 참조

-   https://ssocoit.tistory.com/253
