# TIL | 2025.04.10

## 주간 목표

-   계획한 미라클 모닝 자리잡기
-   스픽 루비티어에서 승급구간 유지해서 승급하기
-   루틴 확립하기
-   오늘 다하려고 진행 순서에 적어둔게 아니다 내일 까먹을까봐 순서에 넣어둔거다
-   [벨로그](https://velog.io/@pigpgw/%EB%82%98%EC%9D%98-%EA%B0%9C%EB%B0%9C-%EC%84%B1%EC%9E%A5-%EC%A0%84%EB%9E%B5-%EC%83%9D%EA%B0%81%ED%95%98%EB%8A%94-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A1%9C-%EB%82%98%EC%95%84%EA%B0%80%EA%B8%B0)에 작성한 것들 습관화하기

### 오늘 진행 순서 예정

-   [] 아침 운동 : 조깅 걷뛰 1.5km + 팔굽 100개 + 코어 5분
-   [] 스픽
-   [] 알고리즘
    -   [] 링크드 리스트 문제 풀기
    -   [] 알고리즘 강의 수강
-   [] 항해 99 면접 챌린지
-   [] 블로그 하나 읽기
-   [] 유익한 유튜브 시청하기
-   [] 주시 회의
-   [] 스마게 작업
    -   [] 현재 코드 문제 상황 작성하기
    -   [] 구현하기
-   [] 주시 작업 (작업 보류하고 공부하기 지금으로선 그게 맞을듯)
    -   [] api 연결 실패시 폴링 무효화 처리
-   [] 책 읽기(안티패턴을 넘어 TDD와 리펙터링으로 완성하는 리액트 설계)
-   [] 헬스(어깨) : 4분할(가볍게 30분 ~ 40분) + 조깅 걷뛰 1.5km(최대한 하려고 노력중)
-   [] TIL 공유회
-   [] 강의 수강(타입스크립트, 알고리즘)

---

# TIL

# 블로그 읽기

---

## 알고리즘

-   시간 복잡도 강의 듣기
    -   for - while 중첨되었다고 무적권 n제곱이 아니다.
        -   어떻게 코드를 작성하냐에 따라 다름
    -   상수 시간도 완전 무시할 순 없다.
    -   코테 시간제한 기준점 : 10 ^ 8
    -   시간복잡도는 만능이 아니다.
    -   풀이에 대한 확신
    -   알고리즘 떠올리기

### 코테 적용 방법

-   Step1 문제 이해하기
    -   문제를 제대로 읽기
    -   제약조건 읽기
        -   효율성 테스트 10^8 넘으면 안됨
        -   원소 값의 범위
            -   int === 4byte => 1bit는 부호 31bit는 수 표현 -2^31 ~ 2^31 + 1
                -   2의 31승은 10의 9승 그러면 인트형 변수에 저장 불가
-   Step2 접근 방법
    -   직관적으로 생각하기
        -   보통 완전 탐색으로 시작
        -   문제 상황을 단순화 하여 생각하기
        -   문제 상황을 극한화 하여 생각하기
    -   자료구조와 알고리즘 활용
        -   Step1 문제이해 에서 파악한 내용을 토대로 어떤 자료구조를 사용하는게 가장 적합한지 결정
        -   대놓고 특정 자료구조와 알고리즘을 묻는 문제도 많음
        -   자료구조에 따라 선택할 수 있는 알고리즘을 문제에 적용
    -   메모리 사용
        -   시간복잡도를 줄이기 위해 메모리를 사용하는 방법
        -   대표적으로 해시테이블

### 대표 알고리즘

-   O(1): Operation push and pop on Stack
-   O(log n): Binary Tree
-   O(n): for loop
-   O(n×log n): Quick Sort, Merge Sort, Heap Sort
-   O(n2): Double for loop, Insert Sort, Bubble Sort, Selection Sort
-   O(2n): Fibonacci Sequence

### 링크드리스트 코테 적용

1. 링크드리스트 자유자재로 구현 (선형 자료구조 + 중간에 데이터 추가/삭제 용이)

### 문제 풀이 과정

-   step1 문제 이해하기
    -   input, output 확인
        -   input 값의 특징 (정수인가? 값 크기의 범위는? 마이너스도 된느건가? 소수인가? 자료형은 문자열인가? 등등)
        -   Output 값의 특징 (내가 어떤 값을 반환해줘야 하는지, 정해진 형식대로 반환하려면 어떻게 구현할지)
    -   input size N 확인
        -   시간복잡도를 계산하기 위한 ㅑnput size N 또는 M 이 무엇인지 확인
    -   제약조건 확인
        -   시간복잡도 제한이 있는지 확인
        -   내가 선택할 수 있는 알고리즘이 무엇이 있는지
    -   예상할 수 있는 오류 파악
        -   상황을 가정하면서 에상할 수 있는 오류를 파악
        -   입력값의 범위 ,stack overflow 등

---

### 항해 99 면접 챌린지

-   [] 질문 1 :
-   [] 질문 2 :

    -

---

# 스마게

### 스마게 작업

-   이전 채팅 기능이 올바르게 작동하지 않은 이유 정리
-   어제 조언을 토대로 고민

    -   오늘 친구와 무한 스크롤이 왜 우리 프로젝트(채팅 히스토리)에 적합하지 않은지, 그리고 어떤 방향으로 가야 할지에 대해 깊게 대화를 나눴다.

        무한 스크롤의 본래 목적은 **새롭고 다양한 데이터를 지속적으로 노출하는 것**이다. 피드나 콘텐츠 추천 같은 데서 많이 쓰이는 UX인데, 이미 나눈 대화를 보는 채팅 히스토리에서는 맞지 않는다. 채팅은 과거의 히스토리를 조회하는 형태라서, 페이지네이션 방식이 더 자연스럽다. 즉, 우리가 채팅에서 원하는 것은 계속해서 새로운 대화가 아니라 **기존에 나눴던 대화를 필요한 시점에 효율적으로 가져오는 것**이기 때문에 무한 스크롤보다는 페이지네이션이 적합하다는 결론을 내렸다.

        특히 무한 스크롤은 **캐싱 관리가 매우 어렵다.**  
        페이지가 다르더라도 같은 쿼리에 저장되는 방식이라서, 예를 들면 1페이지부터 10페이지까지 다 한 캐시에 들어가 버린다.  
        결국 캐시를 페이지나 댓글 수 단위로 나눠서 관리해야 하는데, 그렇지 않으면 캐시가 꼬이고 관리가 복잡해진다. 우리 프로젝트에서는 **"페이지 단위로 캐시를 관리하는 구조"** 가 더 맞다.

        그래서 현재는 **스크롤되는 페이지네이션 형태**로 구현하는 게 좋다는 방향을 잡았다. 사용자는 스크롤로 자연스럽게 히스토리를 조회할 수 있고, 내부적으로는 페이지 단위로 데이터를 효율적으로 관리할 수 있다.

        또한, React Virtualization (가상화 렌더링) 에 대해서도 이야기했는데, 이건 스크롤하는 컴포넌트가 많아지면 고려할 수 있는 기술이다. 윈도잉 기법으로 사용자의 뷰에 보이는 요소만 렌더링해서 성능을 최적화하는 방식이다.  
        하지만 성능 최적화는 너무 성급하게 적용할 필요는 없다고 조언을 받았다. 일단 최대한 고민하고, 성능 저하 문제가 실제로 발생할 때 적용하는 게 맞다. **문제가 발생하지 않았는데 무조건 최적화를 적용하는 것은 오히려 불필요한 복잡도를 만든다.**

        결론적으로, 나는 우리 프로젝트에서는 우선 페이지네이션으로 구현하고, 필요할 때 가상화 렌더링 같은 기술을 고민하는 방향으로 가기로 정리했다. 성능과 유지보수 모두 고려한 선택이라고 생각한다.

# 주시

---

# TIL 공유회

---

# 공부할 키워드

-   공통 컴포넌트 설계
    -   rest
    -   기본 타입 확장
        -   공통 버튼 컴포넌트 만드는데 어떻게 해야할지 모르겠음,
-   React
    -   리엑트에서의 단일 책임 원칙
    -   리엑트 쿼리 사람답게 쓰기
-   next
    -   axios가 필요할까
    -   axios와 fetch가 다른점
    -   next Image
    -   next 에서 fetch
    -   next에서 react query
    -   Next.js 에서 local, development, production 환경 셋팅하기
-   작업
    -   next에서 fetch params next invalidate
    -   현재 폴링을 리엑트 쿼리로 구현함 올바른가?
        -   fetch로는 안되냐?
        -   왜 fetch로 폴링 구현하면 개발서버에서는 안되고 배포 서버에서만 되냐
    -   현재 구현된 소켓 로직 다시 생각
        -   현재 구조를 그려보기
        -   개선점 파악하기
        -   있다면 개선
        -   에러처리 생각하기
        -   최적화 부분 생각하기
    -   구현한 폴링 방식 올바른가 (그려보기)
        -   현재 구조를 그려보기
        -   개선점 파악하기
        -   있다면 개선
        -   에러처리 생각하기
        -   최적화 부분 생각하기
-   패키지 매니저
    -   package.json
        -   ^ 메이저 버전 이상 아무거나
    -   packagelock.json
        -   정확한 현재 프로젝트에 설치된 라이브러리 버전 명시

---

# 한 입 크기로 잘라먹는 타입스크립트

-

# 패턴으로 익히고 설계로 완성하는 리액트

-   ch4 리액트 컴포넌트 설계하기 ~

# 프론트엔드 아키텍처

## 뷰 로직과 비즈니스 로직의 분리

### 목적

-   **컴포넌트 재사용성 증가**
-   **유지보수성 향상**
-   **테스트 용이성 확보**

### 예시

#### 뷰 로직 (UI 컴포넌트)

```tsx
const ProductCard = ({ product, onBuy }: Props) => {
    return (
        <div>
            <p>{product.name}</p>
            <button onClick={() => onBuy(product.id)}>구매</button>
        </div>
    );
};
```

#### 비즈니스 로직 (커스텀 훅)

```ts
const useBuyProduct = () => {
    const mutation = useMutation((productId) => buyAPI(productId));
    return mutation;
};
```

### 좋은 구조

-   UI: 입력 → 출력에 집중 (props 기반)
-   로직: 상태 관리, 요청 처리 등은 **hooks나 service 파일로 분리**

## 공부하고 싶은 키워드

## 1. **소프트웨어 설계 원칙 관련**

| 주요 개념                                  | 설명                                           | 함께 공부하면 좋은 개념                                                                   |
| ------------------------------------------ | ---------------------------------------------- | ----------------------------------------------------------------------------------------- |
| **관심사의 분리 (Separation of Concerns)** | 기능/책임/영역을 나눠서 복잡도를 낮추는 원칙   | - SRP (단일 책임 원칙)<br>- 모듈화(Modularity)<br>- MVC/MVVM 패턴<br>- 레이어드 아키텍처  |
| **추상화 계층 (Abstraction Layer)**        | 하위 로직을 숨기고 필요한 기능만 노출하는 구조 | - 캡슐화<br>- 인터페이스 / 추상 클래스<br>- 레이어드 아키텍처<br>- 의존성 역전 원칙 (DIP) |
| **비즈니스 로직 (Business Logic)**         | 애플리케이션의 핵심 규칙/기능을 수행하는 부분  | - 도메인 모델<br>- 서비스 계층<br>- 유스케이스<br>- 엔티티(Entity), DTO                   |

---

## 2. **프론트엔드 구조/설계**

| 주요 개념                                | 설명                                        | 함께 공부하면 좋은 개념                                                     |
| ---------------------------------------- | ------------------------------------------- | --------------------------------------------------------------------------- |
| **Container vs Presentational 컴포넌트** | 비즈니스 로직과 UI 로직을 나누는 React 설계 | - 관심사 분리<br>- 컴포넌트 책임 분리<br>- Hooks 구조화                     |
| **상태 관리 구조 (Zustand, Redux, etc)** | 상태를 어디서/어떻게 다룰지 정의            | - 비즈니스 로직 위치<br>- Store 분리 전략<br>- Selector, middleware         |
| **API Layer 분리**                       | API 요청을 별도 레이어로 나눔               | - Axios 커스텀 인스턴스<br>- Query Hook abstraction<br>- Service Layer 구조 |

---

## 4. **실무 적용 관점 (실제로 설계할 때 유용한 개념)**

| 실무에서 접하는 개념    | 연관 개념                                     |
| ----------------------- | --------------------------------------------- |
| 서비스 레이어 설계      | 비즈니스 로직 분리, 추상화 계층, 관심사 분리  |
| 공통 API 오류 처리      | Axios 인터셉터, API 추상화 계층               |
| 유저 인증 흐름          | 상태 관리 분리, 관심사 분리, 로직 단위 모듈화 |
| 파일 구조 설계          | 기능/도메인 기반 구조 → 관심사 분리           |
| 테스트 설계 (단위/통합) | 비즈니스 로직과 UI 로직 분리 필요             |

### 참조

-   https://ssocoit.tistory.com/253
-   https://gngsn.tistory.com/167
