# TIL | 2025.04.11

## 주간 목표

-   계획한 미라클 모닝 자리잡기
-   스픽 루비티어에서 승급구간 유지해서 승급하기
-   루틴 확립하기
-   오늘 다하려고 진행 순서에 적어둔게 아니다 내일 까먹을까봐 순서에 넣어둔거다
-   [벨로그](https://velog.io/@pigpgw/%EB%82%98%EC%9D%98-%EA%B0%9C%EB%B0%9C-%EC%84%B1%EC%9E%A5-%EC%A0%84%EB%9E%B5-%EC%83%9D%EA%B0%81%ED%95%98%EB%8A%94-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A1%9C-%EB%82%98%EC%95%84%EA%B0%80%EA%B8%B0)에 작성한 것들 습관화하기

### 오늘 진행 순서 예정

-   [x] 아침 운동 : 조깅 걷뛰 1.5km + 팔굽 100개 + 코어 5분
-   [x] 스픽
-   [x] 책 읽기(안티패턴을 넘어 TDD와 리펙터링으로 완성하는 리액트 설계)
-   [x] 블로그 하나 읽기[VSC 마우스 없이 사용하기](https://velog.io/@joch2712/VSC-%EB%A7%88%EC%9A%B0%EC%8A%A4-%EC%97%86%EC%9D%B4-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-%EC%8A%A4%EC%95%95-%EC%A3%BC%EC%9D%98)
-   [x] 알고리즘

    -   [x] 링크드 리스트 문제 풀기
    -   [x] 알고리즘 강의 수강
    -   [x] 링크드리스트 문제 배열로 풀어보기

-   [x] 항해 99 면접 챌린지
-   [x] 유익한 유튜브 시청하기
-   [x] 주시 회의
-   [x] 스마게 작업
    -   [x] 현재 코드 문제 상황 문서화
    -   [x] 구현하기
-   [x] 주시 작업 (작업 보류하고 공부하기 지금으로선 그게 맞을듯)
    -   [x] 아이폰 16pro에서 시위 상세페이지 스크롤 무너지는 문제를 해결한다.
-   [x] 등 + 가슴
-   [] TIL 공유회
-   [] 강의 수강(타입스크립트, 알고리즘)

---

# TIL

## 책 읽기(안티패턴을 넘어 TDD와 리펙터링으로 완성하는 리액트 설계)

### 리액트 테스팅

#### 5.2 여러 종류 테스트

-   단위 테스트 : 개별 컴포넌트나 함수의 기능을 격리하여 각각 예상대로 동작하는지를 확인
-   통합 테스트 : 다른 모듈과 서비스들이 원활하게 상호작용하여 함께 잘 동작하는지를 검사
-   E2E 테스트 : 전체 애플리케이션의 흐름을 시작부터 종료까지 실제 사용자 행동을 묘사하여 텟트 진행
-   시각적 회귀 테스트는 각기 다른 시점에서 웹페이지 또는 컴포넌트의 스크립샷이나 스냅샷을 찍어 픽셀단위로 비교하여 시각적 차이점을 찾아냄
-   정적 검사 : 오류를 잡아내고 코딩 표준을 보장하기 위해 코드를 실행시키지 않고 구문을 분석하는 것

-   마이크 콘이 고안한 테스트 피라미드에서는 통합 테스트나 E2E 테스트보다 단위 테스트를 더 많이 수행할 것을 권장 : 단위 테스트는 빠르고 간순하며 유지하기 쉽기 때문
-   하지만 현대의 프론트엔드 개발에서 이 모델은 진화중 : 애플리케이션 복잡도가 높아지고 상호작용이 많아지면서, 통합 테스트와 E2E 테스트가 더욱 중요해징
    -   Cypress, puppeteer와 같은 도구를 이용하면 브라우저에서 사용자 행동을 모방하는 E2E테스트를 쉽게 작성 가능

## 블로그 읽기 [VSC 마우스 없이 사용하기](https://velog.io/@joch2712/VSC-%EB%A7%88%EC%9A%B0%EC%8A%A4-%EC%97%86%EC%9D%B4-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-%EC%8A%A4%EC%95%95-%EC%A3%BC%EC%9D%98)

-   파일 포커스 목록 : 코드 편집 영역과 파일 탐색 사이를 전환하는 단축키
    -   cmd + shift + e
-   파일 디록토리 생성 (따로 설정해야함) Open Keyboard Shortcuts(JSON)에서
    -   파일 만들기 : cmd + n
    -   디렉토리 만들기 : ctrl + n
-   파일 이름 변경, 삭제
    -   파일 이름 변경 : enter
    -   파일 삭제 : 백스페이스
-   터미널 빠르게 이동하기
    -   ctrl + 백틱
-   터미널 창 열기 닫기
    -   command + j

---

## 알고리즘

-   시간 복잡도 강의 듣기
    -   for - while 중첨되었다고 무적권 n제곱이 아니다.
        -   어떻게 코드를 작성하냐에 따라 다름
    -   상수 시간도 완전 무시할 순 없다.
    -   코테 시간제한 기준점 : 10 ^ 8
    -   시간복잡도는 만능이 아니다.
    -   풀이에 대한 확신
    -   알고리즘 떠올리기

### 코테 적용 방법

-   Step1 문제 이해하기
    -   문제를 제대로 읽기
    -   제약조건 읽기
        -   효율성 테스트 10^8 넘으면 안됨
        -   원소 값의 범위
            -   int === 4byte => 1bit는 부호 31bit는 수 표현 -2^31 ~ 2^31 + 1
                -   2의 31승은 10의 9승 그러면 인트형 변수에 저장 불가
-   Step2 접근 방법
    -   직관적으로 생각하기
        -   보통 완전 탐색으로 시작
        -   문제 상황을 단순화 하여 생각하기
        -   문제 상황을 극한화 하여 생각하기
    -   자료구조와 알고리즘 활용
        -   Step1 문제이해 에서 파악한 내용을 토대로 어떤 자료구조를 사용하는게 가장 적합한지 결정
        -   대놓고 특정 자료구조와 알고리즘을 묻는 문제도 많음
        -   자료구조에 따라 선택할 수 있는 알고리즘을 문제에 적용
    -   메모리 사용
        -   시간복잡도를 줄이기 위해 메모리를 사용하는 방법
        -   대표적으로 해시테이블

### 대표 알고리즘

-   O(1): Operation push and pop on Stack
-   O(log n): Binary Tree
-   O(n): for loop
-   O(n×log n): Quick Sort, Merge Sort, Heap Sort
-   O(n2): Double for loop, Insert Sort, Bubble Sort, Selection Sort
-   O(2n): Fibonacci Sequence

### 링크드리스트 코테 적용

1. 링크드리스트 자유자재로 구현 (선형 자료구조 + 중간에 데이터 추가/삭제 용이)

### 문제 풀이 과정

-   step1 문제 이해하기
    -   input, output 확인
        -   input 값의 특징 (정수인가? 값 크기의 범위는? 마이너스도 된느건가? 소수인가? 자료형은 문자열인가? 등등)
        -   Output 값의 특징 (내가 어떤 값을 반환해줘야 하는지, 정해진 형식대로 반환하려면 어떻게 구현할지)
    -   input size N 확인
        -   시간복잡도를 계산하기 위한 ㅑnput size N 또는 M 이 무엇인지 확인
    -   제약조건 확인
        -   시간복잡도 제한이 있는지 확인
        -   내가 선택할 수 있는 알고리즘이 무엇이 있는지
    -   예상할 수 있는 오류 파악
        -   상황을 가정하면서 에상할 수 있는 오류를 파악
        -   입력값의 범위 ,stack overflow 등

# JavaScript 메모리 관리와 자료구조 — 내가 이해한 정리

---

## 자료구조: ArrayList vs LinkedList

### ArrayList (배열 기반)

JavaScript의 배열은 고수준 동적 배열이다.  
초기에 고정된 크기를 할당받고 생성되며, 초과 시 동적으로 크기를 늘린다.  
인덱스로 빠르게 접근할 수 있어 접근 시간 복잡도는 O(1)이다.

하지만 중간 삽입이나 삭제는 O(n)의 시간 복잡도가 발생한다.  
splice, slice 같은 메서드를 사용할 때 삭제 또는 복사하는 요소의 개수만큼 연산이 필요하기 때문이다.  
특히 forward 기록이 많을 때 visit() 연산에서 불필요한 forward 기록을 삭제하는 데 많은 시간이 걸릴 수 있다.

### LinkedList (연결 리스트)

연결 리스트는 각 요소(Node)가 prev / next 포인터로 서로 연결된다.  
새로운 노드를 연결하거나 기존 노드를 연결 해제하는 작업은 O(1)로 매우 빠르다.  
forward 기록 삭제 시 포인터만 바꾸면 되므로 매우 효율적이다.

다만, 뒤로 가기나 앞으로 가기 연산은 steps 만큼 포인터를 이동해야 하므로 O(steps)의 시간 복잡도가 발생한다.

### 결론

| 연산                  | ArrayList                        | LinkedList             |
| --------------------- | -------------------------------- | ---------------------- |
| 새 방문 (visit)       | O(n) (forward 기록 많을 때 느림) | O(1)                   |
| 뒤로 가기 (back)      | O(1) (인덱스 이동)               | O(steps) (포인터 이동) |
| 앞으로 가기 (forward) | O(1) (인덱스 이동)               | O(steps) (포인터 이동) |

BrowserHistory 같은 문제에서는 LinkedList 가 더 안정적인 선택이 될 수 있다.  
forward 기록이 많아지면 ArrayList 의 visit() 연산이 느려지지만, LinkedList 는 항상 포인터만 이동하면 되기 때문이다.

---

## JavaScript 메모리 구조

### 메모리 구조는 크게 세 가지로 구분된다

1. Code Area  
   실행할 JavaScript 코드를 저장하는 공간이다.

2. Call Stack  
   함수 실행 순서를 저장하는 공간으로, 지역 변수나 원시 타입 값들이 저장된다.  
   LIFO(Last In First Out) 구조로 동작한다.

3. Heap  
   객체나 배열 등 참조 타입의 데이터가 저장되는 공간이다.  
   Call Stack 과는 달리 메모리 할당이 랜덤하게 배치된다.  
   Heap 영역은 메모리 누수를 방지하기 위해 JS 엔진의 메모리 관리자가 항상 관리한다.

---

## 메모리 생명 주기

자바스크립트에서 메모리 생명 주기는 다음과 같은 단계를 따른다.

1. 필요할 때 메모리를 할당한다.
2. 할당된 메모리를 사용한다 (읽기 또는 쓰기).
3. 더 이상 필요하지 않은 메모리는 해제된다.

자바스크립트는 저수준 언어처럼 프로그래머가 명시적으로 메모리를 해제하지 않아도 된다.  
하지만 메모리가 언제 어떻게 할당되고 해제되는지 이해하는 것은 매우 중요하다.

---

## 가비지 컬렉션 (Garbage Collection)

JavaScript 엔진은 가비지 컬렉션을 통해 메모리를 자동으로 관리한다.  
더 이상 사용되지 않는 메모리를 식별하고 해제하여 메모리 누수를 방지한다.

### 주요 가비지 컬렉션 알고리즘

1. 참조 카운팅 (Reference Counting)  
   객체가 참조되는 횟수를 추적하고, 참조 횟수가 0이 되면 메모리를 해제하는 방식이다.  
   하지만 순환 참조가 발생할 경우 참조가 0이 되지 않아 메모리를 해제하지 못하는 문제가 있다.

2. 마크 앤 스윕 (Mark and Sweep)  
   루트 객체에서 시작해 도달 가능한 객체를 마크하고, 도달할 수 없는 객체를 메모리에서 제거한다.  
   이 방법은 순환 참조 문제를 해결할 수 있어 현대 브라우저에서는 주로 이 방식을 사용한다.

---

## 메모리 누수를 방지하려면

자동 메모리 관리에도 불구하고, 다음과 같은 상황에서는 메모리 누수가 발생할 수 있다.

-   전역 변수의 과도한 사용  
    전역 변수는 프로그램 종료 시까지 메모리에 남아 있으므로 불필요한 전역 변수 선언은 피해야 한다.

-   이벤트 리스너 미제거  
    DOM 요소에 등록된 이벤트 리스너를 제거하지 않으면 해당 요소가 메모리에서 해제되지 않을 수 있다.

-   클로저의 부적절한 사용  
    클로저가 외부 스코프의 변수를 참조하면 해당 변수가 메모리에서 해제되지 않을 수 있다.

이러한 문제를 방지하기 위해, 필요하지 않은 참조는 null 로 설정하거나 이벤트 리스너를 명시적으로 제거하는 등의 조치가 필요하다.

---

## 정리

자바스크립트는 자동으로 메모리를 관리해주는 언어이지만, 개발자가 메모리 구조와 가비지 컬렉션의 원리를 이해하고 있어야 예상치 못한 메모리 누수를 예방할 수 있다.  
자료구조 선택 또한 프로그램의 메모리 효율과 성능에 큰 영향을 준다.  
특히 히스토리 관리처럼 메모리 사용이 많은 기능을 구현할 때는 자료구조의 복잡도를 고려하는 것이 중요하다.

### 자바스크립트의 요상한 값 falsy

-   null, NaN, undefined는 다른 프로그래밍 언어에 없는 falsy값
    -   이들은 모두 값이 없음을 나타내는 특별한 값(조건문에서 false로 평가)
    -   null : 어느 reference 변수에 대해 주소값이 없는 것을 표현하기 위한 키워드, 값은 없지만 값을 담을 수 있는 그릇은 있는 것
    -   undefined : 변수가 정의되어 있지 않은 상태, 즉 값이 할당되지 않은상태

---

### 항해 99 면접 챌린지

-   질문 1 공통 : 기술 부채 관리
    -   프로젝트에서 기술 부채를 어떻게 정의하고, 그것을 정량화하거나 체계적으로 관리해본 경험이 있다면 설명해주세요. 그 과정을 통해 어떤 효과가 있었는지도 함께 이야기해주세요.
        -   프로젝트에서 저는 기술 부채를 "이상적인 구현 방식이 있음에도 불구하고, 현 시점의 시간과 리소스, 팀의 역량을 고려해 당장 선택하는 최선의 구현 방식"이라고 정의했습니다. 첫 팀 프로젝트였던 만큼 팀원들도 경험이 많지 않아 기술 부채가 발생하는 상황을 직접 겪었습니다. 그 과정에서 저는 팀원들의 일정을 조율하고, 기술적 선택지들을 조사해 대체 가능한 서비스나 도구들을 찾아 구현 난이도를 고려해 결정했습니다. 특히 프로젝트 일정 관리에서 주어진 기간보다 약 일주일 정도 더 여유를 두고 계획해 일정 압박을 완화했고, 그 결과 프로젝트를 안정적으로 마무리할 수 있었습니다. 이 경험을 통해 기술 부채를 단순히 피하는 것이 아니라, **관리 가능한 형태로 인지하고 계획적으로 대응하는 것이 중요하다**는 것을 배웠습니다.
-   질문 2 인성 : 의견 충돌

    -   팀 내에서 기술적 의견 차이가 있었던 상황에서, 본인의 입장을 유지하면서도 상대와 타협하거나 협상을 이끌어낸 경험이 있다면 공유해주세요.
        -   깃헙 API 를 활용해서 파일을 참조하는 방법에 대해 팀원과 의견 차이가 있었습니다. 저는 특정 방식으로 구현해야 원하는 기능을 정확하게 구현할 수 있다고 판단했지만, 팀원은 다른 접근 방식을 주장했습니다. 저는 우선 제 입장을 유지하면서, 상대방의 방식으로 구현할 경우 기능적으로 어떤 한계가 발생하는지 실제로 구현해 예시를 통해 보여주었습니다. 이렇게 구체적인 결과를 근거로 제시하면서 상대방도 문제를 명확히 이해할 수 있었고, 자연스럽게 저의 의견으로 방향을 맞춰 합의할 수 있었습니다.

-   질문 3 프론트 : 코드 스플리팅 & Lazy Loading

    -   대규모 애플리케이션에서 코드 스플리팅이나 Lazy loading을 적용하며 성능 최적화를 시도한 경험이 있다면,
        구현 중 어떤 문제를 마주했고, 어떻게 해결했는지 설명해주세요.

        -   프로젝트 성능 최적화를 위해 Lazy loading 을 적용했는데, 어떤 기준으로 적용할지 고민이 많았습니다. 무조건 모든 컴포넌트에 적용한 건 아니지만, 사용자 유입이 많은 주요 화면에도 적용하면서 렌더링 지연이 생겼습니다. 문제를 인지한 후에는 **사용자 흐름과 컨텐츠 중요도** 에 따라 적용 범위를 조정했습니다. 중요한 컨텐츠는 바로 로딩하고, 나중에 보게 되는 부가적인 부분만 Lazy loading 을 적용하고 스켈레톤을 제공함으로써 초기 로딩 속도와 사용자 경험을 개선했습니다.

            -

---

# 스마게

### 스마게 작업

-   이전 채팅 기능이 올바르게 작동하지 않은 이유 정리
-   어제 조언을 토대로 고민

    -   오늘 친구와 무한 스크롤이 왜 우리 프로젝트(채팅 히스토리)에 적합하지 않은지, 그리고 어떤 방향으로 가야 할지에 대해 깊게 대화를 나눴다.

        무한 스크롤의 본래 목적은 **새롭고 다양한 데이터를 지속적으로 노출하는 것**이다. 피드나 콘텐츠 추천 같은 데서 많이 쓰이는 UX인데, 이미 나눈 대화를 보는 채팅 히스토리에서는 맞지 않는다. 채팅은 과거의 히스토리를 조회하는 형태라서, 페이지네이션 방식이 더 자연스럽다. 즉, 우리가 채팅에서 원하는 것은 계속해서 새로운 대화가 아니라 **기존에 나눴던 대화를 필요한 시점에 효율적으로 가져오는 것**이기 때문에 무한 스크롤보다는 페이지네이션이 적합하다는 결론을 내렸다.

        특히 무한 스크롤은 **캐싱 관리가 매우 어렵다.**  
        페이지가 다르더라도 같은 쿼리에 저장되는 방식이라서, 예를 들면 1페이지부터 10페이지까지 다 한 캐시에 들어가 버린다.  
        결국 캐시를 페이지나 댓글 수 단위로 나눠서 관리해야 하는데, 그렇지 않으면 캐시가 꼬이고 관리가 복잡해진다. 우리 프로젝트에서는 **"페이지 단위로 캐시를 관리하는 구조"** 가 더 맞다.

        그래서 현재는 **스크롤되는 페이지네이션 형태**로 구현하는 게 좋다는 방향을 잡았다. 사용자는 스크롤로 자연스럽게 히스토리를 조회할 수 있고, 내부적으로는 페이지 단위로 데이터를 효율적으로 관리할 수 있다.

        또한, React Virtualization (가상화 렌더링) 에 대해서도 이야기했는데, 이건 스크롤하는 컴포넌트가 많아지면 고려할 수 있는 기술이다. 윈도잉 기법으로 사용자의 뷰에 보이는 요소만 렌더링해서 성능을 최적화하는 방식이다.  
        하지만 성능 최적화는 너무 성급하게 적용할 필요는 없다고 조언을 받았다. 일단 최대한 고민하고, 성능 저하 문제가 실제로 발생할 때 적용하는 게 맞다. **문제가 발생하지 않았는데 무조건 최적화를 적용하는 것은 오히려 불필요한 복잡도를 만든다.**

        결론적으로, 나는 우리 프로젝트에서는 우선 페이지네이션으로 구현하고, 필요할 때 가상화 렌더링 같은 기술을 고민하는 방향으로 가기로 정리했다. 성능과 유지보수 모두 고려한 선택이라고 생각한다.

# 주시

---

# TIL 공유회

---
