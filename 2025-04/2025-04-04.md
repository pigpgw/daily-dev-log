# TIL | 2025.04.04

### 오늘 진행 순서 예정

> 패턴으로 읽히고 설계로 완성하는 리액트 -> 주시 작업 -> 주시 회의 -> 주시 작업 -> 스마게 작업 -> 알고리즘

## 📌 TIL

## 알고리즘

-   트리

### 소켓 폴링 구현

-   리엑트 쿼리의 도입이 올바른가
-   구현한 폴링 방식 올바른가
    -   필요한 데이터와 상태 흐름을 정리한다
    -   UI 렌더링을 위한 로직과 비즈니스 로직(기능 흐름이나 데이터 처리에 필요한 로직) 생각한다
    -   API 요청 및 응답 흐름을 설계한다
    -   예외 상황(빈 값, 실패, 에러 등)을 예상하고 대응 방식을 고민한다
    -   전체 UI 구조와 컴포넌트 트리를 대략 그려본다
-   해야할거
    -   충돌날거라서 ui-images 브랜치에있고
    -   socket-effects에 있거든

## 주시

-   [x] css
    -   css 잘 설계하는법
    -   css 잘하는법
        -   [링크](https://velog.io/@teo/CSS-%EA%B3%B5%EB%B6%80-%EC%96%B4%EB%96%BB%EA%B2%8C-%ED%95%B4%EC%95%BC-%ED%95%98%EB%82%98%EC%9A%94-%EC%9D%B4%EB%A1%A0%ED%8E%B8-feat.-figma)
            -   마진을 가급적 쓰지마라
                -   css가 애매해지고 복잡해지는 첫 번째 이유이다.
                    -   마진을 쓰면 고려해야하는게 많다. (마진 콜랩스, 등등)
                    -   꼭 마진을 써야하나 고민해보기
            -   대부분의 레이아웃은 거의 Flexbox로 가능하다.
    -   css variant
-   js

    -   abortcontroller
        -   자바스크립트에서 fetch 요청을 중단할 수 있는 것, 비동기 테스트 중단시키는 기술
    -   v8 엔진 [url](https://velog.io/@qlgks1/javascript-node-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC)
    -   js 컴파일 과정

        ### 📌 1. 자바스크립트 개요

        -   웹페이지에 동적 기능을 추가하는 언어
        -   브라우저가 `<script>` 태그를 만나면 파싱 중단 → 코드 실행
        -   브라우저/서버(Node.js) 모두에서 동작 (V8, SpiderMonkey 등 다양한 엔진)

        ### 📌 2. 컴파일 기본 개념

        -   소스코드를 기계어로 번역하는 과정
        -   목적: 사람이 이해하는 언어(고급언어)를 컴퓨터가 이해하는 언어(기계어)로

        **컴파일러 vs 인터프리터**

        -   **컴파일러**: 전체 코드 → 기계어 변환 → 실행 파일
        -   **인터프리터**: 코드를 한 줄씩 읽으면서 바로 실행
        -   JavaScript는 전통적으로 인터프리터 방식 사용
        -   인터프리터는 이식성, 컴파일러는 속도에 강점

        ### 📌 3. JIT 컴파일러 (Just In Time)

        -   런타임에 코드를 기계어로 번역
        -   바이트 코드 → 기계어로 변환 후 캐시에 저장하여 재사용
        -   인터프리터보다 빠르고, 컴파일러만큼은 아님
        -   단점: 메모리 많이 사용, 초기 컴파일 시간 존재

        ### 📌 4. JavaScript에서의 실행 과정

        1. **소스코드 → 바이트 코드**

        -   렉싱 → 파싱(AST) → 바이트코드 생성 (Ignition)

        2. **바이트 코드 → 실행**

        -   Ignition 인터프리터로 실행
        -   반복이 많은 부분(hotspot)은 JIT 컴파일러(TurboFan)가 native code로 변환 후 실행

        **문제점**

        -   JS는 동적 타입 → JIT이 예외 케이스까지 모두 고려해야 함
        -   hotspot이 적은 경우가 많음 → native code 생성 오버헤드
        -   일부 연구에서는 JS JIT 효과가 크지 않다고 분석

        ### 📌 5. Adaptive JIT (적응형 컴파일)

        -   요즘 JS 엔진(V8 등)은 Adaptive JIT을 사용
        -   실행 초기에는 인터프리터로 실행
        -   **Hotspot 발견 시 JIT 적용**
        -   JIT도 단계적 (baseline → optimizing)
        -   타입 프로파일링을 통해 타입이 안 바뀌면 최적화된 코드 사용
        -   예외 상황 시 다시 baseline JIT 코드로 복귀

        **요약**

        -   **전통적인 JS 코드**: 인터프리터 효율적
        -   **연산 많은 JS 코드**: JIT 효율적
        -   Adaptive JIT로 두 가지 상황을 모두 커버!

        ***

        ### 📌 결론: JavaScript 엔진의 실행 최적화 흐름

        ```
        소스코드
        ↓ (렉싱/파싱)
        AST
        ↓ (컴파일)
        바이트 코드 (Ignition 인터프리터)
        ↓ (핫스팟 감지 시)
        Native Code (TurboFan JIT 컴파일러)
        ```

        -   자주 실행되는 부분은 native code로 변환되어 빠르게 실행
        -   변화가 없을 것으로 예상되는 타입에 대해 aggressive 최적화
        -   동적인 변화 발생 시 baseline 코드로 복귀

---

# 한 입 크기로 잘라먹는 타입스크립트

-   타입 계층도
-   객체 타입은 프로퍼티 기준으로함 (타입 스크립트는 프로퍼티 기준으로 타입을 정의하는 구조적 타입 시스템)

    -   객체 타입관의 관계를 정의할때는 추가 타입이 더 많은게 슈퍼타입이 아니라 추가 타입이 더 적은게 슈퍼타입이 된다

-   초과 프로퍼티 검사
    -   변수를 초기화할때 객체 타입 변수를 사용할떄 객체 리터럴을 사용하면 실제 타입에는 정의하지 않은 프로퍼티를 초기화시에 넣어주면 오류가남
        -   객체 리터럴을 사용하지 않으면됨,인수에 저장하고 할당하면 됨
-   암묵적 애니타입
    -   직접 애니타입이라고 지정하진 않았지만 아무 탕비도 지정하지 않은것
    -   값을 할당하면 그 값에 맞게 타입이 할당됨
    -   초기값 없이 변수를 선언하면 암묵적으로 any 타입되고 점점 진화함
    -   any 타입을 할당하는거랑 다름
-   const 키워드로 변수 만들고 초기값을 넣어주면 타입이 해당 값을 가짐, 어차피 상수이기에 다른값 안담음
    -   -   배열은 안에 원소들 타입들을 가짐
-   let은 범용적인 타입으로 해줌 let num = 2 // type number (타입 넓히기)
-   타입 단언
-   as const
    -   객체타입과 사용할떄 유용
    -   모든 프로퍼티가 읽기전용으로 됨, 구지 다 readonly 안붙여져도됨
    -
