# TIL | 2025.04.25

## 주간 목표

-   계획한 미라클 모닝 자리잡기
-   스픽 챌린저
-   루틴 확립하기
    -   충분한 수면을 가져가려고 노력하기 (TIL 공유를 조금 늦은 시간에 진행하고 2시에 취침하고 7시에 기상해서 운동까지 해버리니 너무 피곤함)
    -   일어나서 런닝하는건 지양한다. (피곤해지기 때문에)
    -   런닝은 하루 일과를 마무리하고 근력운동 전 또는 후에 진행한다.
    -   스픽을 운동하고 씻고 딱 한개만실시한다.
    -   최대한 이동하는 시간을 활용해서 진행한다.(다 남는 시간이다.)
    -   하루에 최소 알고리즘 하나를 풀도록 노력하기
    -   책은 내용을 암기하는게 아니다 가볍게 흘러가듯이 읽자
-   [벨로그](https://velog.io/@pigpgw/%EB%82%98%EC%9D%98-%EA%B0%9C%EB%B0%9C-%EC%84%B1%EC%9E%A5-%EC%A0%84%EB%9E%B5-%EC%83%9D%EA%B0%81%ED%95%98%EB%8A%94-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A1%9C-%EB%82%98%EC%95%84%EA%B0%80%EA%B8%B0)에 작성한 것들 습관화하기

### 중요 일정

-   4.28 ~ 5.2 : sqld 원서 접수
-   2025년 05월 10일 (토) 12:40 : 정보처리기사 필기

### 오늘 진행 순서 예정

-   [x] 알고리즘
-   [x] 블로그 하나 읽기 [넥스트 캐싱](https://velog.io/@clydehan/Next.js%EC%9D%98-%EC%BA%90%EC%8B%B1-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0)
-   [] 유익한 유튜브 시청하기
-   [x] 주시 회의
-   [x] 주시 작업

---

# TIL

### 오늘 진행 순서 예정

## 책 읽기

## 블로그 하나 읽기 [넥스트 캐싱](https://velog.io/@clydehan/Next.js%EC%9D%98-%EC%BA%90%EC%8B%B1-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0)

-   https://velog.io/@yonghyeun/NextJS-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%99%80-RSC-Payload

### SSR과 CSR의 차이

-   SSR(Server-side Rendering) : 서버 쪽에서 렌더링 준비를 끝마친 상태로 클라이언트에게 전달하는 방식입니다.
-   CSR(Client-side Rendering) : SSR과 달리 렌더링이 클라이언트 쪽에서 일어납니다. 즉, 서버는 요청을 받으면 클라이언트에 HTML와 JS파일을 보내줍니다. 클라이언트는 그것을 받아 렌더링을 시작합니다.

### Next

-   CSR인 React를 SSR 방식으로 구현할 수 있도록 도와주는 프레임워크 Next.js는 SPA이며 SSG (Static Site Generation)를 기본으로 사용하고, SSR을 사용할 수 있음
-   Next는 기본적으로 SSG를 사용하기 때문에 빌드 시점에만 서버 사이드에서 사전 렌더링한 파일들을 보내주고 그 이후에는 CSR로 페이지를 이동함

⭐️ SSR의 경우 매 요청마다 추가적인 리소스를 불러오는 것입니다.

> 결론적으로는, Next.js는 CSR을 사용하여 페이지 이동을 처리합니다. 필요한 경우에만 서버에 추가적인 데이터를 요청합니다. 따라서 SSR을 사용하더라고 페이지 이동 시마다 HTML과 JS파일을 전체적으로 다시 불러오는 것은 아니며, 필요한 데이터의 업데이트만 수행하게 됩니다.

> Next.js가 가지고 있는 가장 강력한 장점은 Pre-rendering과 CSR의 장점을 모두 사용할 수 있게 해준다는 것입니다.

### Next.js에서 사전 렌더링 하는 방식은 2가지

-   SSG(Static-site Generation)

    -   빌드 타임에 HTML이 생성되어 매 요청마다 이를 재사용. 즉, 빌드 시점 이후에는 서버에게 따로 요청X
        → 데이터가 바뀌지 않는 블로그 글, 상품 정보 페이지 등에서 사용한다

-   SSR(Server-side Rendering)
    -   매 요청마다 HTML을 생성. 여기서의 '매 요청'은 웹 사이트의 페이지를 접속하거나 페이지를 새로고침할 때 발생하는 요청을 말한다.
    -   SSR 방식에서는 클라이언트의 각 요청마다 서버가 해당 페이지의 데이터와 리소스를 가져와서 HTML을 동적으로 생성
        -   → 최신 콘텐츠를 제공해야 할 때 사용

### 데이터나 결과를 임시로 저장해 두는 것을 말함

-   불필료한ㄷ 데이터 요청 = 서버 낭비 + 로딩 느림
-   이미 불러온 데이터를 재사용 = 빠른 반응 + 효율적인 처리

### Next의 캐싱

-   Next.js는 브라우저와 서버가 협력해서 동작하는 프레임워크이다. - 따라서 캐싱도 서버와 클라이언트 라는 두 환경에서 각기 다르게 동작한다
    > 대부분의 캐싱은 서버 환경에서 동작하고, 클라이언트 쪽에는 보조적인 캐시만 존재한다

### 서버 캐싱

-   서버에서 실행되는 컴포넌트나 API에서는 데이터 요청, 렌더링 결과, HTML등을 저장하고 재사용하는 고급 캐싱 기능이 적용됨
    -   Request memoization : 서버 렝더링 중 중복된 fetch 요청을 한 번만 실행
    -   data cache : 외부 API나 DB데이터를 서버에 저장하고 여러 요청 간 재사용
    -   full route cache : HTML과 RCS Payload 전체를 저장해서 페이지 전체를 캐싱
-   이 세가지 모두 서버 컴포넌트 또는 서버 API 에서만 작동함 (클라이언트 컴포넌트에서는 작용되지 않음)

### 클라이언트 캐싱

-   브라우저 환경에서도 캐시가 존재함, 하지만 서버처럼 데이터를 따로 저장하거나 fetch를 재사용하진 않는다. 클라이언트에서 사용하는 캐시는 오직 Router Cache 하나뿐이다. - 사용자가 어떤 페이지를 방문하면 - 서버에서 받은 RSC Payload 전체가 클라이언트(브라우저 메모리에) 저장되고, - 이후 다시 해당 경로에 이동하면, 서버에 새 요청 없이 즉시 렌더링된 결과가 재사용 됨
    > 즉 클라이언트 캐시는 서버 결과물을 전체 덩어리로 저장해두는 방식, 서버처럼 fetch() 결과를 따로 캐싱하거나 API 결과는 저장하지는 않는다.

### Hydration

-   Next.js는 서버에서 HTML을 문자열로 가져온 후에, 클라이언트에서 서버로부터 보내준 HTML을 render(), hydrate()하여 브라우저에 렌더링 했습니다. 이 일련의 과정을 Hydration이라고 합니다!

### Next.js가 Hydration하기까지의 과정 정리

1. 서버에서 전달된 HTML 수신
2. 클라이언트 측 렌더링 (render()) : 클라이언트는 수신된 HTML을 우선 렌더링하고, 인터렉션을 위한 JS파일을 로드한다.
3. hydrate() 호출 : 전달된 HTML에 이벤트 핸들러를 연결
4. 클라이언트 측 렌더링 완료 : hydrate 과정이 완료되면 클라이언트에서 페이지의 렌더링과 인터렉션을 관리할 수 있게 된다.

### 참고

> Full Route Cache 와 Router Cache 는 모두 페이지 전체를 저장하지만
> Full Router Cache는 서버가 다시 렌더링하지 않기 위해
> Router Cache 는 클라이언트가 서버에 다시 요청하지 않기 위해 존재함

## 알고리즘

### 주시 작업

-   자바스크립트 동적 타입언어라 런타입 중에 오류 방생확률 어렵고 팀원간 코드 의사소통 어려움
-   타입스크립트는 변수와 데이터의 종류를 명확히 지정해주기 때문에 이런 단점들이 보완될 수 있는 것
    -   대부분의 에러를 컴파일 환경에서 코드를 입력하는 동안 체크할 수 있음

### 코테 적용 방법

-   Step1 문제 이해하기
    -   문제를 제대로 읽기
    -   제약조건 읽기
        -   효율성 테스트 10^8 넘으면 안됨
        -   원소 값의 범위
            -   int === 4byte => 1bit는 부호 31bit는 수 표현 -2^31 ~ 2^31 + 1
                -   2의 31승은 10의 9승 그러면 인트형 변수에 저장 불가
-   Step2 접근 방법
    -   직관적으로 생각하기
        -   보통 완전 탐색으로 시작
        -   문제 상황을 단순화 하여 생각하기
        -   문제 상황을 극한화 하여 생각하기
    -   자료구조와 알고리즘 활용
        -   Step1 문제이해 에서 파악한 내용을 토대로 어떤 자료구조를 사용하는게 가장 적합한지 결정
        -   대놓고 특정 자료구조와 알고리즘을 묻는 문제도 많음
        -   자료구조에 따라 선택할 수 있는 알고리즘을 문제에 적용
    -   메모리 사용
        -   시간복잡도를 줄이기 위해 메모리를 사용하는 방법
        -   대표적으로 해시테이블

### 대표 알고리즘

-   O(1): Operation push and pop on Stack
-   O(log n): Binary Tree
-   O(n): for loop
-   O(n×log n): Quick Sort, Merge Sort, Heap Sort
-   O(n2): Double for loop, Insert Sort, Bubble Sort, Selection Sort
-   O(2n): Fibonacci Sequence
