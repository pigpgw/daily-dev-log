# TIL | 2025.04.28

## 주간 목표

-   계획한 미라클 모닝 자리잡기
-   스픽 챌린저
-   루틴 확립하기
    -   충분한 수면을 가져가려고 노력하기 (TIL 공유를 조금 늦은 시간에 진행하고 2시에 취침하고 7시에 기상해서 운동까지 해버리니 너무 피곤함)
    -   일어나서 런닝하는건 지양한다. (피곤해지기 때문에)
    -   런닝은 하루 일과를 마무리하고 근력운동 전 또는 후에 진행한다.
    -   스픽을 운동하고 씻고 딱 한개만실시한다.
    -   최대한 이동하는 시간을 활용해서 진행한다.(다 남는 시간이다.)
    -   하루에 최소 알고리즘 하나를 풀도록 노력하기
    -   책은 내용을 암기하는게 아니다 가볍게 흘러가듯이 읽자
-   [벨로그](https://velog.io/@pigpgw/%EB%82%98%EC%9D%98-%EA%B0%9C%EB%B0%9C-%EC%84%B1%EC%9E%A5-%EC%A0%84%EB%9E%B5-%EC%83%9D%EA%B0%81%ED%95%98%EB%8A%94-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A1%9C-%EB%82%98%EC%95%84%EA%B0%80%EA%B8%B0)에 작성한 것들 습관화하기

### 중요 일정

-   4.28 ~ 5.2 : sqld 원서 접수
-   2025년 05월 10일 (토) 12:40 : 정보처리기사 필기

### 오늘 진행 순서 예정

-   [x] 아침 운동 : 팔굽 100개
-   [x] 스픽
-   [x] 정처기 1회분 풀기 (2020년 6월 6일)
-   [x] 알고리즘
-   [x] 블로그 하나 읽기 [반드시 기억해야 하는 CSS 선택자 30개](https://webdesign.tutsplus.com/ko/the-30-css-selectors-you-must-memorize--net-16048t)
-   [x] 유익한 유튜브 시청하기[리엑트 까보기시리즈 개요](https://www.youtube.com/watch?v=JadWu4Ygnyc&list=PLpq56DBY9U2B6gAZIbiIami_cLBhpHYCA)
-   [x] 스마게 작업
-   [x] 책읽기

-   [x] 운동

---

# TIL

### 오늘 진행 순서 예정

## 책 읽기

### 1장

-   타입스크립트 목표
    -   그중 하나: 런타임에 오류를 발생시킬 코드를 미리 찾아내는 것 (모든 오류 찾아내는건 아님)
        -   타입 체커가 모든 오류를 찾아내지는 않음, 오류를 발생하지는 않지만 의도와 다르게 동작하는 코드도 많음
        -   타입 구문을 추가하면 더 많은 오류를 찾아낼 수 있음, 명시적으로 타입 해줘야 오류 더 많이 찾아냄
        -   noimplicityany 설정해라
        -   strictNullChecks하면 좋지만 어렵다
        -   엄격한 체크를 하고싶다면 strict 설정을 고려하라

### 아이템 3 : 코드 생성과 타입이 관계없음을 이해하기

-   타입스크립트 컴파일러는 두 가지 역할을 수행함 - 최신 타입스크립트/자바스크립트를 브라우저에서 동작할 수 있도록 구버전의 자바스크립트로 트랜스파일 - 코드의 타입 오류를 체크

> 두가지가 완벽히 독립적

-   타입스크립트가 자바스크립트로 변활될 때 코드 내의 타입에는 영향을 주지 않음
-   또한 자바스크립트의 실행 시점에도 타입은 영향을 미치지 않음

#### 타입 오류가 있는 코드도 컴파일이 가능하다

-   컴파일은 타입 체크와 독립적으로 동작하기 때문에 타입 오류가 있는 코드도 컴파일이 가능하다

#### 런타입에는 타입 체크가 불가능하다

-   실제로 자바스크립트로 컴파일되는 과정에서 모든 인터페이스, 타입, 타입 구문은 그냥 제거되어버림
-   타입스크립트는 기본적으로 자바스크립트 위에 올라가는 정적 타입 시스템
    -   타입이라는건 컴파일(빌드) 할 때만 존재하고 실제 실행(런타임) 할 때는 완전히 사라짐 : 값만 남아있고 타입 정보는 날라감
    -   런타임에는 진짜 존재하는 것 만 사용할 수 있음
        -   그래서 타입스크립트에서는 "특징"으로 타입을 구별함(내로잉이라고 부름)
            1. 속성 검사
                - 진짜 런타임에 존재하는 속성 검사
            2. 태그 추가해서 구분
                - 구분자(태그)를 만들어서 interface에 추가 (discriminated union)
            3. instanceof는 클래스에만 사용 가능
-   코드 생성은 타입 시스템과 무관, 타입스크립트 타입은 런타임 동작이나 성능에 영향을 주지 않음
-   타입 오류 존재해도 코드 생성(컴파일)은 가능
-   타입스크립트 타입은 런타임에 사용할 수 없음

### 아이템 4 구조적 타이핑에 익숙해지기

-   자바스크립트는 본질적으로 덕 타이핑 기반 : 어떤 함수의 매개변수 값이 모두 제대로 주어진다면, 그 값이 어떻게 만들어졌는지 신경쓰지 않고 사용
-   타입스크립트는 이런 동작, 즉 매개변수 값이 요구사항을 만족한다면 타입이 무엇인지 신경쓰지 않는 동작을 그대로 모델링함

#### 이 객체가 어떤 속성들을 가지고 있나

-   클래스조차도 구조적 타입으로 체크함

### 아이템 5 : any 타입 지양하기

-   타입스크립트의 타입 시스템은 점진적이고 선택적
    -   코드에 타입을 조금씩 추가할 수 있기 때문에 점진적, 언제든지 타입 체커를 래제할 수 있기 때문에 선택정

#### any 타입에는 타입 안정성이 없다

#### any는 함수 시그니처를 무시해림

-   약속된 출력을 반환하지 않을수도
-   자동완성 도움 못받음

### 2장 타입스크립트의 타입 시스템

-   타입스크립트는 코드를 자바스크립트로 변환하는 역할도 하지만 가장 중요한 역할은 타입시스템에 있다.

#### 아이템 6 편집기를 사용하여 타입 시스템 탐색하기

-   타입스크립트를 설치하면, 다음 두 가지를 실행할 수 있음
    -   타입스크립트 컴파일러
    -   단독으로 실행할 수 있는 타입스크립트 서버
        > 컴파일러 실행이 주된 목적이지만 타입스크립트 서버 또한 '언어 서비스'를 제공한다는 점에서 중요
-   언어 서비스란
    -   코드 자동완성
    -   명에 겅사
    -   겅색
    -   리팩토링

### 아이탬 13 타입과 인터페이스의 차이점

## 정처기 1회분 풀기 (2020년 6월 6일)

### 1과목

-   1번
    -   워크스루 : 검토회의 전에 요구사항 명세서를 미리 배포하여 사전 검토한 후 짧은 검토 회의를 통해 오류를 조기에 검출하는데 목적을 두는 요구 사항 검토 방법
    -   인스펙션 : 명세서 작성자를 제외한 다른 검토 전문가들이 확인하면서 결함을 발견하는 형태
-   4번
    -   데이터 흐름도(DFD)의 구성요소
        -   프로세스(Process), 자료 흐름(Flow), 자료 저장소(Data Store), 단말(Terminal)이 있다.
-   7번
-   GoF(Gang of Four)의 디자인 패턴에서 행위 패턴에 속하는 것은?
    1. Builder : 작게 분리된 인스턴스를 건축 하듯이 조합하여 객체를 생성한다
    2. Visitor : 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성한다
    3. Prototype : 원본 객체를 복제하는 방법으로 객체를 생성한다.
    4. Bridge : 구현부에서 추상층을 분리하여, 서로가 독립적으로 확장할 수 있도록 구성한다.
-   생성패턴 : 객체의 생성과 관련된 패턴
-   구조패턴 : 클래스나 객체들을 조합하여 더 큰 구조로 만들 수 있게 해주는 패턴
-   행위패턴 : 클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴

-   8번
    -   자료 사전에서 자료의 생략을 의미하는 기호
        -   정의 =
        -   구성, 연결 +
        -   반복 {}
        -   주석 \*\*
        -   선택 [|]
        -   생략 ()
-   11번
    -   XP의 5가지 가치
        -   용기, 단순성, 커뮤니케이션, 피드백, 존중
-   13번
    -   소프트웨어 개발 방법 중 요구사항 분석
        -   비용과 일정에 대한 제약설정
        -   타당성 조사
        -   요구사항 정의 문서화
-   15번
    -   공통 모듈 원칙
        -   정확성 : 해당 기능이 실제 시스템 구현시 필요한지 아닌지를 알 수 있도록 정확하게 작성
        -   명확성 : 해당 기능에 대해 일관되게 이해하고 한가지로 해석될 수 있도록 작성
        -   완전성 : 시스템이 구현될 때 필요하고 요구되는 모든 것을 기술
        -   일관성 : 공통 기능 간에 상호 충돌이 없도록 작성
        -   추적성 : 공통 기능에 대한 요구사항 출처와 관련 시스템 등의 유기적 관계에 대한 식별이 가능하도록 작성
-   17
    -   Case란 소프트웨어 개발의 자동화
        1 S/W의 생명주기 전(모든)단계의 연결
        2 모델들 사이의 모순검사
        3 오류검증
        4 자료흐름도 등 다이어그램 작성
        5 다양한 소프트웨어 개발 모형지원
        6 시스템 문서화 및 명세화를 위한 그래픽 지원

### 2과목

-   24
    -   인터페이스 구현 검증 도구
        xUnit : Java, C++ 등 다양한 언어 지원하는 단위 테스트 프레임워크
        STAF : 서비스 호출 및 컴포넌트 재사용 등 환경 지원하는 테스트 프레임워크
        FitNesse : 웹 기반 테스트케이스 설계, 실행, 결과 확인 등을 지원하는 테스트 프레임워크
        NTAF : FitNesse의 장점인 협업 기능과 STAF의 장점인 재사용 및 확장성을 통합한 네이버의 테스트 자동화 프레임워크이다.
        Selenium : 다양한 브라우저 및 개발 언어 지원하는 웹 애플리케이션 테스트 프레임워크
        Watir : Ruby를 사용하는 애플리케이션 테스트 프레임워크
        Ruby : 인터프리터 방식의 객체지향 스크립트 언어
-   26
    -   전위 : root → left → right
    -   중위 : left → root → right
    -   후위 : left → right → root
-   31
    -   차수 : 특정 노드에 연결된 자식 노드의 수
    -   노드 : 자식이 없는 노드
-   32
    -   디지털 저작권 관리(DRM)의 기술 요소
        -   암호화 / 키 관리 / 암호화 파일 생성 / 식별 기술 / 저작권 표현 / 정책 관리 / 크랙 방지 / 인증
-   37
    -   동치 분할 검사 : 입력 자료에 초점을 맞춰 케이스를 만들고 검사하는 방법 - 블랙박스 테스트 종류
    -   알파 테스트 : 개발자의 장소에서 사용자가 개발자 앞에서 행하는 테스트 기법 - 인수 테스트 종류
    -   베타 테스트 : 선정된 최종 사용자가 여러명의 사용자 앞에서 행하는 테스트 기법 - 인수 테스트 종류
-   38

    -   상향식 : Driver
    -   하향식 : Stub

    1. Stub : 하향식 통합시 위 모듈이 없으므로, 하위 모듈들 역할을 하는 스텁(Stub)을 이용
    2. Driver : 상향시 통합시 상위 모듈이 없으므로, 상위 모듈 역할을 하는 테스트 드라이버(Driver)를 이용
    3. Procedure : 특정 작업을 수행하는, 이름이 있는 PL/SQL BLOCK
    4. Function : 첫 번째 집합의 임의의 한 원소가 두 번째 집합의 오직 한 원소에만 대응하는 관계

-   41
    -   DDL(데이터 정의어): CREATE, ALTER, DROP, TRUNCATE
    -   DML(데이터 조작어): SELECT, INSERT, UPDATE, DELETE
    -   DCL(데이터 제어어): GRANT, REVOKE
    -   TCL(트랜잭션 제어어): COMMIT, ROLLBACK, CHECKPOINT
-   48
    -   하나의 애트리뷰트가 가질 수 있는 원자값들의 집합 : 도메인
-   55
    -   DML의 유형에는 SELECT, INSERT, DELETE, UPDATE 가 있다.
-   56
    -   데이터 제어언어(DCL) : 데이터 베이스 관리자가 데이터 보안, 무결성 유지, 병행 제어, 회복을 하기 위해 DBA가 사용하는 제어용 언어
-   57
    -   병행제어 로킹(Locking)
        -   데이터베이스 병행 제어를 위해 트랜잭션(transaction)이 접근하고자 하는 데이터를 잠가(lock) 다른 트랜잭션이 접근하지 못하도록 하는 병행 제어 기법이다.
        -   로킹이 되어 있는 데이터에는 다른 트랜잭션이 접근할 수 없음
        -   트랜잭션은 로킹이 된 데이터에 대해서만 연산을 수행
        -   로킹 단위: 필드, 레코드, 테이블, 파일, 데이터베이스 모두 로킹 단위가 될 수 있다.
        -   한 번에 로킹 할 수 있는 객체의 크기를 로킹 단위라고 한다.
        -   로킹단위가 커지면 로킹오버헤드가 감소한다.
-   58
    -   E-R 모델의 표현 방법
        -   개체 타입 (사각형)
        -   관계 타입 (마름모)
        -   속성 타입 (타원)
        -   연결 (선)
-   60
    -   1NF 조건 : 원자값으로 구성
    -   2NF 조건 : 부분 함수 종속 제거 (완전 함수적 종속 관계)
    -   3NF 조건 : 이행 함수 종속 제거
    -   BCNF 조건 : 결정자 함수 종속
    -   4NF 조건 : 다중값(다치) 종속성 제거
    -   5NF 조건 : 조인 종속성 제거
-   61
    -   ipv6 : IPv4의 패킷 크기가 64Kbyte로 제한되어있다.
-   62
    -   c 언어에서 비트 논리연산자
        -   ^(XOR)
        -   ? 조건문
        -   &(AND)
        -   ~(NOT)
-   63
    -   TCP/IP 프로토콜 중 전송계층 프로토콜은? : TCP
-   65

    -   은행가 알고리즘(Banker's Algorithm)은 교착상태의 해결 방법 중 어떤 기법에 해당하는가? : 회피

-   67
    -   교착 상태 발생의 필요 충분 조건
        -   상호 배제, 점유와 대기, 환형 대기 , 비선점입니다.
-   68

    -   OSI-7계층에서 종단간 신뢰성 있고 효율적인 데이터를 전송하기 위해 오류검출과 복구, 흐름 제어를 수행하는 계층은? : 전송계층

-   응용계층 - 사용자가 OSI환경에 접근할 수 있도록 서비스 제공
-   표현계층 - 응용계층으로 받은 데이터를 세션계층에 보내기 전에 통신에 적당한 형태로 변환, 세션계층에서 받은 데이터는 응용계층에 맞게 변환하는 기능
-   세션계층 - 송 수신 측 간의 관련성을 유지하고 대화 제어를 담당한다.
-   전송계층 - 논리적 안정 및 균일한 데이터 전송 서비스를 제공함으로서 종단 시스템간 투명한 데이터 전송 가능
-   네트워크 - 개방 시스템들 간의 네트워크 연결을 관리 및 데이터 교환 및 중계
-   데이터링크 - 두 개의 인접한 개방 시스템들 간 신뢰성있고 효율적인 정보 전송
-   물리계층 - 전송에 필요한 두 장치 간의 실제 접속과 절단 등 기계적, 전기적 기능적 절차 특성에 대한 규칙

-   69

    -   IPv6 : 유니캐스트(unicast) 멀티캐스트(multicast) 애니캐스트(anycast)
    -   IPv4 : 유니캐스트(unicast) 멀티캐스트(multicast) 브로드캐스트(Broadcast)

-   73
    -   비선점 스케줄링
        -   실행시간이 긴 프로세스에 불리한 SJF 을 보완하기 위해
        -   대기시간 및 서비스 시간을 이용
        -   우선순위를 계산 숫자가 높은것부터 낮은순으로 순위 부여
        -   (대기시간 + 서비스시간) / 서비스시간 = 우선순위값
-   82
    -   메모리상에서 프로그램의 복귀 주소와 변수사이에 특정 값을 저장해 두었다가 그 값이 변경되었을 경우 오버플로우 상태로 가정하여 프로그램 실행을 중단하는 기술은? : 스택가드
-   83
    -   백도어 탐지 방법으로 틀린 것은? 백도어 탐지 방법 : 무결성 검사 / 로그 분석 / SetUID 파일 검사 / 열린 포트 검사 / 바이러스 및 백도어 탐지 툴 이용
-   84
    -   IP 또는 ICMP의 특성을 악용하여 특정 사이트에 집중적으로 데이터를 보내 네트워크 또는 시스템의 상태를 불능으로 만드는 공격 방법은? : 스머핑
-   85
    -   CMM(Capability Maturity Model) 모델의 레벨 : 초기단계(initial) / 반복단계 (Repeatable) / 정의단계 (Defined) / 관리단계 (Managed)Tip. 정량적 프로세스 관리가 Keyworkd / 최적단계 (Optimizing)/
-   89
    -   유형별 COCOMO
        -   Organic : 조직형 / 소규모 소프트웨어 일괄 자료 처리 /5만 라인 이하
        -   Semi-detached : 반분리형 / 트랜잭션 처리 시스템이나 운영체제, DB / 30만 라인 이하
        -   Embedded : 내장형 / 최대형 규모 트랜잭션 처리 시스템이나 운영체제 / 30만 라인 이상
-   90

    -   여러 개의 독립된 통신장치가 UWB(Ultra Wideband)기술 또는 블루투스 기술을 사용하여 통신망을 형성하는 무선 네트워크 기술은? : PICONET

-   91
    -   프로토타입을 지속적으로 발전시켜 최종 소프트웨어 개발까지 이르는 개발방법으로 위험관리가 중심인 소프트웨어 생명주기 모형은 : 나선형 모델
-   100
    -   시스템 내의 정보는 오직 인가된 사용자만 수정할 수 있는 보안 요소는? : 무결성

## 블로그 하나 읽기 [반드시 기억해야 하는 CSS 선택자 30개](https://webdesign.tutsplus.com/ko/the-30-css-selectors-you-must-memorize--net-16048t)

-   descendant : 하위 선택자

-   type 선택자
-   :link 클릭하기 전 상태의 앵커 태그
-   :visited : 클릭했었거나 방문했던 페이지에 있는 애커 태그에만 스타일 적용
-   X > Y : 직계 자식만을 선택
-   X[title] : 속성이 있는 앵커 태그만을 선택
-   X[href^="http"]
-   X:checked : X:checked
-   X::가상 요소 : 첫 번째 줄이나 첫 글자와 같이 요소 일부분에 스타일을 적용하는데 가상 요소(::로 표기되는)를 사용할 수 있습니다. 효과를 보려면 이 요소를 반드시 블록 레벨 요소에 적용해야 합니다.
-   X:nth-child(n)
-   X:nth-last-child(n)
-   X:first-child
-   X:last-child

## 알고리즘

### 코테 적용 방법

-   Step1 문제 이해하기
    -   문제를 제대로 읽기
    -   제약조건 읽기
        -   효율성 테스트 10^8 넘으면 안됨
        -   원소 값의 범위
            -   int === 4byte => 1bit는 부호 31bit는 수 표현 -2^31 ~ 2^31 + 1
                -   2의 31승은 10의 9승 그러면 인트형 변수에 저장 불가
-   Step2 접근 방법
    -   직관적으로 생각하기
        -   보통 완전 탐색으로 시작
        -   문제 상황을 단순화 하여 생각하기
        -   문제 상황을 극한화 하여 생각하기
    -   자료구조와 알고리즘 활용
        -   Step1 문제이해 에서 파악한 내용을 토대로 어떤 자료구조를 사용하는게 가장 적합한지 결정
        -   대놓고 특정 자료구조와 알고리즘을 묻는 문제도 많음
        -   자료구조에 따라 선택할 수 있는 알고리즘을 문제에 적용
    -   메모리 사용
        -   시간복잡도를 줄이기 위해 메모리를 사용하는 방법
        -   대표적으로 해시테이블

### 대표 알고리즘

-   O(1): Operation push and pop on Stack
-   O(log n): Binary Tree
-   O(n): for loop
-   O(n×log n): Quick Sort, Merge Sort, Heap Sort
-   O(n2): Double for loop, Insert Sort, Bubble Sort, Selection Sort
-   O(2n): Fibonacci Sequence

---

## 유익한 유튜브 시청하기 [VDOM](https://www.youtube.com/watch?v=2EbCEluOO9Y&list=PLpq56DBY9U2B6gAZIbiIami_cLBhpHYCA&index=3)

-   파이버 : 리액트 18부터 본격적으로 사용한 아키텍처
    -   스택 구조를 변화한것 : 들어간 순서대로 해버리면 돔에 변화를 적용할때 꺼내는 순서가 고정이되면 유연하게 랜더링 순서를 조절 불가능함
-   VDOM

    -   프로그래밍 컨셉
        -   메모리 상에 UI 관련된 정보를 띄우고, react dom과 같은 라이브러리에 의해 실제 DOM과 sync를 맞춘다.(renderer 관여)이 과정을 재조정(reconciliation)이라 부름.(reconciler 관여)
        -   왜 가상? 실제로 하면 (mound -> paint) 가상보다 비용이 더 큼
    -   VDOM 어떻게 구현되어있지? fiber node로 구성된 tree 형태(더블 버퍼링 구조)
        -   current
            -   Dom에 mount 된 fiber
        -   workInProgress
            -   render phase 에서 작업 중인 fiber
            -   commit phase 를 지나면서 current tree가 됨
    -   구현 상세
        -   workinProgress tree 는 current tree에서 자기 복제 하여 만들어짐(서로 alternate로 참조)
        -   fiber는 첫번째 자식만을 child로 참조, 나머지 자식들은 서로 sibling으로 참조, 모든 자식은 부모를 return으로 참조
    -   컴포넌트 리렌더링 : 컴포넌트 호출 후 그 결과가 VDOM에 반영 O, DOM에 mount되어 paint x

-   React lifecycle
    -   렌더 페이즈 커밋페이즈 언제 VDOM 언제 조작하지?
-   렌더 페이즈
    -   VDOM 재조정(reconciliation)하는 단계
        -   element 추가, 수정, 삭제 -> work를 scheduler에 등록
            -   work : reconciler가 컴포넌트의 변경을 DOM에 적용하기 위해 수행하는 일
        -   reconciler가 담당(reconciler 설계 stack -> fiber 바뀌면서 abort, stop, restart 즉, 렌더링 우선순위 변경 가능 useTransation 등)
-   커밋 페이즈
    -   재조정한 VDOM을 DOM에 적용 & 라이프사이클 실행하는 단계
        -   일관성을 위해 sync 실행, 즉, DOM 조작 일괄처리 후, 리액트가 콜스택을 비워준 다음 브라우저가 paint 시작

## 주시

### 타입과 인터페이스 차이점

-   인터페이스는 확장 가능 타입은 인터페이스를 확장할 수 있음
    -   인터페이스는 유니온 타입 같은 복잡한 타입을 확장하지는 못한다는ㄱ ㅓㅅ, 복잡한 타입을 확장하고 싶다면 타입과 &를 사용해야함
-   유니온 타입은 있지만 유니온 인터페이스는 없음
-   인터페이스는 타입을 확장할 수 있지만 유니온은 할 수 없음
-   타입 키워드는 유니온이 될 수도 있고, 매핑된 타입 또는 조건부 타입같은 고급 기능에 활용됨

-   인터페이스는 타입에 없는 몇 가지 기능이 있음
    -   타입 보강이 가능
        -   선언 병합 가능

### 자동추론

-   타입이 추론될 수 있음에도 여전히 타입을 명시하고 싶은 몇가지 상황
    1. 객체 리터럴을 정의
        - 이런 정의에 타입을 명시하면, 잉여 속성 체크가 동작(아이템 11)
            - 타입 구문을 안해주면 잉여 속성 체크가 동작하지 않고, 객체를 선언한 곳이 아니라 객체가 사용되는 곳에서 타입 오류가 발생함
        - 함수의 반환에도 : 반환타입을 명시하면 구현상의 오류가 사용자 코드의 오류로 표시되지 않음
            - 반환타입을 명시해야하는 이유
                1. 반환 타입을 명시하면 함수에 대해 더욱 명확하게 알 수 있음
                2. 명명된 타입을 사용하기 위해서 : 그냥 추론하면 x:number 이런식으로 나오는데 반환타입 해두면 x:cheer 이렇게 명시적으로 나옴
