# TIL | 2025.04.14

## 주간 목표

-   계획한 미라클 모닝 자리잡기
-   스픽 에매랄드에서 승급하기
-   루틴 확립하기
-   오늘 다하려고 진행 순서에 적어둔게 아니다 내일 까먹을까봐 순서에 넣어둔거다
-   [벨로그](https://velog.io/@pigpgw/%EB%82%98%EC%9D%98-%EA%B0%9C%EB%B0%9C-%EC%84%B1%EC%9E%A5-%EC%A0%84%EB%9E%B5-%EC%83%9D%EA%B0%81%ED%95%98%EB%8A%94-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A1%9C-%EB%82%98%EC%95%84%EA%B0%80%EA%B8%B0)에 작성한 것들 습관화하기

---

### 내 코드가 유지보수하기 좋은지 고민하기

-   요구사항이 변경되었을 때 잘 대응할 수 있을까?
-   예를 들어, 상품 목록 리스트를 구현한다고 하면:
    -   나중에 상품에 다른 값들이 추가될 때 수정이 쉬울까?
    -   상품과 관련된 동작이 더 추가될 가능성은 없을까?
    -   뷰가 변경된다면, 지금 구조로 쉽게 다른 뷰로 바꿀 수 있을까?

조금 상상의 나래를 펼쳐서, 내 코드가 이런 상황에 놓였을 때 쉽게 변경이 가능한지 고민해 본다.  
사실 정말 더 좋은 방법은, 프로젝트를 진행하면서 실제로 요구사항이 바뀌는 상황을 겪어보는 것.

그렇게 경험한 후에, 이론적인 개념과 매칭시키면서 회고해 보는 게 더 효과적이다.

> 문제 상황을 발견 → 근거를 가지고 리팩터링 → 회고  
> (이런 과정을 반복하면서, "이런 이유 때문에 바꿨다", 혹은 "좋은 코드니까 유지한다"는 식으로 계속 시도해 본다.)

-   코드의 본질적인 부분에 대해 많이 고민하는 것이 중요하다.
-   화려한 기술을 써야 하는 상황일 때도 있지만, 사이드 프로젝트나 개인 프로젝트에서는 본질에 더 집중하는 게 좋다.

---

### 오늘 진행 순서 예정

-   [x] 아침 운동 : 조깅 걷뛰 1.5km + 팔굽 100개 + 코어 5분
-   [x] 스픽
-   [x] 책 읽기
-   [x] 블로그 하나 읽기 [Zustand와 React Context](https://velog.io/@ojj1123/zustand-and-react-context)
-   [x] 정처기 필기 신청
-   [x] 알고리즘
    -   할거
        -   강의 들은대까지 관련 문제 풀기
    -   강의
        -   [x] 날짜온도 문제 풀기
        -   [x] 해쉬테이블
    -   알고리즘 답을 본 문제
    -   알고리즘 답을 아직 못 푼 문제
-   [] 항해 99 면접 챌린지

    -   [] 클라이언트 보안 : 웹 클라이언트에서 발생할 수 있는 보안 취약점을 방지하기 위해 어떤 전략을 설계하고 구현했는지 실제 사례를 들어 설명해 주세요.
    -   [] 컨테이너화와 오케스트레이션 : 컨테이너화 및 오케스트레이션 도구를 통해 개발/배포 환경을 효율화한 사례가 있다면, 그 방식과 효과를 구체적으로 설명해 주세요.
    -   [] 리더십 발휘 순간 : 프로젝트나 팀 활동 중 리더십을 발휘했던 경험이 있다면, 어떤 방식으로 팀을 이끌었고 어떤 결과를 냈는지 설명해 주세요.

-   [x] 유익한 유튜브 시청하기
-   [x] 주시 회의
-   [] 주시 작업

    -   [x] 프로젝트 디렉토리 구조 개선 이유 및 선정이유
    -   [x] fetch란 ,axios와 다른점
    -   [] 리펙토링
    -   [] fetch 대신 react query를 사용한 이유
    -   [] next에서 fetch가 강력한 이유
    -   [] react query가 필요 없는 이유
    -   [] react query -> fetch
    -   [] next 강의

-   [] 스마게 알림 api 추가
-   [x] 하체 + 런닝
-   [x] TIL 공유회
-   [x] 강의 수강
    -   알고리즘 : LIFO 2번째 문제 ~
    -   TS : 섹션8
    -   Next : 섹션4 App Router ~

---

# TIL

### 오늘 진행 순서 예정

## 책 읽기

### 11.2.2 클래스 기반의 모델로 변환

-   ACL 패턴을 적용하기 (안티패턴 책 280P)
    -   타입스크립트의 클래스를 사용해서 데이터와 로직을 한 곳에 모다 모델로 캡슐화
        -   메뉴 아이템 타입을 클래스로 바꾸고, 모든 변환 로직을 한굿에 모으는것
            -   이 설정은 이후 데이터 형태의 변경이나 관련 로직을 다루는 별도의 허브 역할을 하게 됨
                ```ts
                export class MenuItem {
                    ~~~
                }
                // 사용
                return new MenuItem(item)
                ```
                -   어쩔때 이렇게하는게 좋을까 이걸 뭐라할까 (클래스 기반의 모델 정의)
                    -   데이터 모델이란?
                        -   클래스 기반의 모델 정의란?
                        -   클래스 기반의 모델 장점은?
                        -   인터페이스를 구현할 추상 클래스는
                        -   js 추상 클래스란?
                            -   추상 클래스는 다른 클래스의 기본 바탕이 되는 클래스로, 추상 클래스만으로는 인스턴스를 생성할 수 없음, 이것은 공통의 인터페이스 또는 파생될 클래스들을 정의하는데 사용
                            -   추상 클래스는 실제 구현 없이 선언되는 추상 메서드를 가지고 있으며, 구체적인 구현은 파생되는 클래스에 맡김
                            -   이를 통해 추상 클래스는 파생 클래스에서도 특정 메서드가 구현됨을 보장하겨 기능을 일관되게 하면서도 공통된 구조를 유지할 수 있게함
                            -   이는 객체지향 프로그래밍의 다형성과 캡슐화를 지원하는 핵심

## 블로그 하나 읽기 [Zustand와 React Context](https://velog.io/@ojj1123/zustand-and-react-context)

### zustand 마음에 안드는 한가지

-   빠르고, 간단하고, 번들 크기로 좋은데 스토어는 전역이라는게 마음에 안듬
-   하나의 컴포넌트 트리에서 전역적으로 사용할 수 있는 상태가 필요한 경우가 더 많다는 걸 많이들 느껴봄

### 전역 스토어 단점

#### props를 통한 초기화

-   전역 스토어는 reaact 컴포넌트 생명주기 외부에서 생성되서 prop으로 얻은 값으로 스토어를 초기화 할 수 없음
-   전역 스토어를 사용하려면 먼저 기본 상태로 스토어를 생성한 다음 useEffect로 props와 스토어를 동기화해야함
-   useEffect를 쓰고싶지 않은 것외에도 두가지 이유로 이상적이지 않습
    -   먼저 effect가 시작되기 전에 <ResetOfTheApp />을 bears: 0으로 렌더링한 다음 올바른 initialBears 로 다시 한 번 렌더링합
    -   실제로 initialBears 로 스토어를 초기화하는 것이 아니라 동기화합 따라서 initialBears 가 변경되면 스토어에도 업데이트가 반영되는 것을 볼 수 있습

#### 테스팅

-   zustand 테스트문서 꽤 혼란스럽고 복잡함

#### 재사용성

-   전역 store 를 사용하면 상태가 "공유" 됨
-   그런데 컴포넌트를 여러 번 사용하고 싶다면, 상태도 "독립" 되어야 함
-   전역 store 는 모든 인스턴스가 같은 상태를 사용하기 때문에, 하나의 컴포넌트에서 선택을 바꾸면 다른 컴포넌트에도 영향을 줌
-   따라서 재사용 가능한 컴포넌트를 만들 때는 전역 store 가 아니라 컴포넌트 로컬 store 를 설계해야 함

### 이러한 문제를 해결할 React Context

-   zustand createStore와 create 차이
    | 구분 | `create` | `createStore` |
    |---|---|---|
    | 목적 | 훅 기반 zustand store 만들기 (React Hook) | **vanilla** zustand store 인스턴스 만들기 (Hook 없음) |
    | 사용법 | 컴포넌트에서 바로 `useMyStore()` 처럼 사용 | store 인스턴스를 수동으로 생성하고, 원하는 곳에서 가져다 씀 |
    | store 위치 | 전역 store (앱 어디서나 접근) | 컴포넌트 안에서도 생성 가능 (컴포넌트마다 store 따로 생성) |
    | 예시 | `const useStore = create(...)` | `const store = createStore(...)` |
    | context 사용 | 필요 없음 (전역이니까) | context 와 같이 사용하면 컴포넌트 별로 독립 store 가능! |

---

#### store 생성 함수

```ts
import { createStore } from 'zustand/vanilla';

const createMyStore = () =>
    createStore((set) => ({
        count: 0,
        increase: () => set((state) => ({ count: state.count + 1 })),
    }));
```

```ts
import React, { createContext, useContext, useState } from 'react';

// 1. Context 만들기
const StoreContext = createContext(null);

// 2. Provider 만들기
const StoreProvider = ({ children }) => {
    // store 생성 (초기화는 여기서!)
    const [store] = useState(() => createMyStore());

    return <StoreContext.Provider value={store}>{children}</StoreContext.Provider>;
};
```

#### 만든 store 를 context 에 넣기

```ts
import { useStore as useZustandStore } from 'zustand';

const useStore = (selector) => {
    const store = useContext(StoreContext);
    if (!store) throw new Error('StoreProvider 안에서 써야 합니다!');
    return useZustandStore(store, selector);
};
```

-   zustand 의 useStore 훅을 연결

#### context 에서 꺼내서 쓰기

```ts
const Counter = () => {
    const count = useStore((state) => state.count);
    const increase = useStore((state) => state.increase);

    return (
        <div>
            <p>{count}</p>
            <button onClick={increase}>Increase</button>
        </div>
    );
};
```

-   컴포넌트 안에서 store 를 만들었으니까 컴포넌트마다 독립 store!
-   같은 Counter 컴포넌트를 여러 번 사용해도, 각각 독립적인 상태 🎉

## 알고리즘

-   시간 복잡도 강의 듣기
    -   for - while 중첩되었다고 무조건 n제곱이 아
        -   어떻게 코드를 작성하냐에 따라 다름
    -   상수 시간도 완전 무시할 순 없다.
    -   코테 시간제한 기준점 : 10 ^ 8
    -   시간복잡도는 만능이 아
    -   풀이에 대한 확신
    -   알고리즘 떠올리기

### 코테 적용 방법

-   Step1 문제 이해하기
    -   문제를 제대로 읽기
    -   제약조건 읽기
        -   효율성 테스트 10^8 넘으면 안됨
        -   원소 값의 범위
            -   int === 4byte => 1bit는 부호 31bit는 수 표현 -2^31 ~ 2^31 + 1
                -   2의 31승은 10의 9승 그러면 인트형 변수에 저장 불가
-   Step2 접근 방법
    -   직관적으로 생각하기
        -   보통 완전 탐색으로 시작
        -   문제 상황을 단순화 하여 생각하기
        -   문제 상황을 극한화 하여 생각하기
    -   자료구조와 알고리즘 활용
        -   Step1 문제이해 에서 파악한 내용을 토대로 어떤 자료구조를 사용하는게 가장 적합한지 결정
        -   대놓고 특정 자료구조와 알고리즘을 묻는 문제도 많음
        -   자료구조에 따라 선택할 수 있는 알고리즘을 문제에 적용
    -   메모리 사용
        -   시간복잡도를 줄이기 위해 메모리를 사용하는 방법
        -   대표적으로 해시테이블

### 대표 알고리즘

-   O(1): Operation push and pop on Stack
-   O(log n): Binary Tree
-   O(n): for loop
-   O(n×log n): Quick Sort, Merge Sort, Heap Sort
-   O(n2): Double for loop, Insert Sort, Bubble Sort, Selection Sort
-   O(2n): Fibonacci Sequence

### 문제 풀이 과정

-   step1 문제 이해하기
    -   input, output 확인
        -   input 값의 특징 (정수인가? 값 크기의 범위는? 마이너스도 되는건가? 소수인가? 자료형은 문자열인가? 등등)
        -   Output 값의 특징 (내가 어떤 값을 반환해줘야 하는지, 정해진 형식대로 반환하려면 어떻게 구현할지)
    -   input size N 확인
        -   시간복잡도를 계산하기 위한 input size N 또는 M 이 무엇인지 확인
    -   제약조건 확인
        -   시간복잡도 제한이 있는지 확인
        -   내가 선택할 수 있는 알고리즘이 무엇이 있는지
    -   예상할 수 있는 오류 파악
        -   상황을 가정하면서 예상할 수 있는 오류를 파악
        -   입력값의 범위 ,stack overflow 등

---

### 시간복잡도

-   실제로 몇번 실행되나 따지기

### 해시테이블

-   자주나오고 어느상황에 사용하냐가 중요
-   array list 로 풀면됨 (open addressing)

---

## 항해 99 면접 챌린지

-   [] 클라이언트 보안 : 웹 클라이언트에서 발생할 수 있는 보안 취약점을 방지하기 위해 어떤 전략을 설계하고 구현했는지 실제 사례를 들어 설명해 주세요.
-   [] 컨테이너화와 오케스트레이션 : 컨테이너화 및 오케스트레이션 도구를 통해 개발/배포 환경을 효율화한 사례가 있다면, 그 방식과 효과를 구체적으로 설명해 주세요.
-   [] 리더십 발휘 순간 : 프로젝트나 팀 활동 중 리더십을 발휘했던 경험이 있다면, 어떤 방식으로 팀을 이끌었고 어떤 결과를 냈는지 설명해 주세요.

## 유익한 유튜브 시청하기 [알고리즘 실력 빨리 올리는 방법](https://www.youtube.com/watch?v=LBup2VMVHXw)

1. 단순구현문제 골드까지 풀기(단계별) : 한 문제를 시간제한없이 물고 늘어지지 말기

-   시간제한을 정하여 해당시간 내에 답이 안나오면 과감히 답지를 보기(30분~1시간)
-   이때, 가볍게 보고 넘기는것이 아니라 코드 한줄한줄을 완벽에 가깝게 이해하며 누군가에게 코드의 의도를 설명할 수 있을정도로 이해해야된다.

2. 복습문제 queue 관리

-   답지를 보고 해결한 문제들을 모아놓고 특정 날이나 시간을 정해 그것들만 다시보자

3. 유형별로 풀기

-   단계별로 풀기에 더해 알고리즘 유형별로 도장깨기 (단순구현 -> 완전탐색 -> 핵심 알고리즘 -> 복잡하고 어려운 알고리즘)

## 주시

네, 마크다운 표 말고 **글로 자연스럽게** 통합해서 드릴게요.  
중복된 내용은 정리하고, 흐름 있게 설명합니다.

---

# Next.js 14 기준 — `fetch` vs `axios` 완전 정리 (중복 제거 버전)

### fetch

-   `fetch`는 JavaScript에 기본 내장된 API로 별도의 설치가 필요 없으며, 클라이언트와 서버 컴포넌트 모두에서 사용할 수 있음
-   특히 Next.js 14에서는 `fetch`가 프레임워크 차원에서 확장되어 서버 컴포넌트에서 사용할 때 자동으로 최적화됨

### axios

-   반면, `axios`는 별도의 설치가 필요한 외부 HTTP 클라이언트 라이브러리입니다. 클라이언트와 서버 컴포넌트 모두에서 사용은 가능하지만, Next.js가 제공하는 프레임워크 레벨의 최적화 기능과는 연동되지 않음, 따라서 일반적인 HTTP 클라이언트로써만 동작

---

## 2. 문법 및 사용성

### fetch

-   `fetch`는 기본 사용법이 간단하지만, 실제로는 요청 헤더 설정, 응답 파싱, 에러 처리, 요청 취소 등을 수동으로 구현해야 하는 경우가 많음

    -   예를 들어 응답을 사용할 때는 반드시 `response.json()`으로 파싱해야 하고, 요청 취소 시에는 `AbortController`를 사용해야 함

### axios

-   반대로 `axios`는 이러한 부분이 기본적으로 내장되어 있습니다. 요청 및 응답 인터셉터, 기본 헤더 설정, 요청 취소, 타임아웃 같은 기능을 지원하고, 응답 데이터도 자동으로 JSON으로 변환되며 `response.data`로 바로 사용할 수 있어 개발이 더 간편함

---

## 3. Next.js 14 기준 기능 비교

### fetch

-   Next.js 14에서는 `fetch`를 사용할 때 프레임워크 차원에서 강력한 최적화를 제공, 서버 컴포넌트에서 `fetch`를 사용하면 다음과 같은 기능이 자동으로 적용됨

    -   자동 캐싱
    -   데이터 재검증 (ISR)
    -   중복 요청 제거
    -   서버간 네트워크 비용 최적화

-   덕분에 서버에서 데이터를 미리 패칭하면서 네트워크 요청을 최소화할 수 있고, 성능 최적화 효과를 얻을 수 있음

### axios

-   반면, `axios`는 이러한 Next.js 최적화 기능이 적용되지 않음
-   서버 컴포넌트에서 사용은 가능하지만, 캐시나 재검증과 같은 기능은 수동으로 구현해야함, 결국, axios는 Next.js의 최적화 파이프라인 바깥에 있는 일반 HTTP 클라이언트

---

## 4. 렌더링 방식과의 연동

### fetch

-   Next.js는 다양한 렌더링 방식을 지원
    -   `fetch`는 Next.js의 SSG(Static Site Generation), SSR(Server Side Rendering), ISR(Incremental Static Regeneration) 과 자연스럽게 통합되어 있음
    -   서버 컴포넌트에서 사용하면 이러한 렌더링 단계에서 필요한 데이터를 자동으로 가져오고 최적화

### axios

-   반대로 `axios`는 Next.js 렌더링 단계와는 별개로 동작
-   SSR 단계에서 사용할 수는 있지만, Next.js가 제공하는 캐싱이나 ISR, 중복 요청 제거 기능 등은 적용되지 않기 때문에 fetch에 비해 렌더링 단계 최적화가 부족함

---

## 강의 수강(Next, 타입스크립트, 알고리즘)

# Next

## 섹션4. App Router 시작하기

-   라우트 그룹 (경로와 관계없이 레이아웃 적용 가능)
-   리엑트 서버 컴포넌트
    -   서버측에서만 실행됨
    -   페이지 라우터 버전에서는 지원하지 않았음
    -   상호작용이 필요 없는 컴포넌트들이 가팅 존재 자바스크립트 번들에 필요한건 상호작용이 있는 컴포넌트만 번들에 있으면됨
    -   쓸데 없이 번들 크기가 커지고 하이드레이션 오래걸리고 TTI 늘어남
    -   사전 렌더링 과정에 자바스크립트 번들에 포함될 필요 없는 애들 제거해버리기(상호작용이 필요 없는 친구들 === 브라우저에서 하디으레이션 될 필요 없는 컴포넌트들)
        -   하이드레이션 : 서버사이드에서 렌더링된 전정 페이지와 번들링된 js 파일을 클라이언트에게 보내면, 클라이언트 사이드에서 html과 js 코드를 서로 매칭시키는 과정
            -   사용자 조작이 가능해짐, 사용자는 SSR을 통해 UI를 미리 보고 Hydration을 통해 페이지 조작이 가능해지는 것
    -   서버측에서만 실행되는 컴포넌트(브라우저에서 상호작용 없어서 괜찮음)
-   서버 컴포넌트 vs 클라이언트 컴포넌트 (상호작용이 있어야하면 클라이언트 컴포넌트)
    -   서버 컴포넌트
        -   서버측에서 사전 렌더링을 진행할 때 딱 한번만 실행
        -   브라우저에서 실행 x
    -   클라이언트 컴포넌트
        -   사전 덴러딩 진행할 때 한번, 하이드레이션 진행할 때 한번 총 2번 실행
    -   페이지 대부분을 서버 컴포넌트로 구성할 것을 권장
    -   넥스트에선 기본적으로 서버 컴포넌트로 설정

## 서버 컴포넌트 주의 사항

1. 서버 컴포넌트에는 브라우저에서 실행될 코드가 포함되면 안된다
2. 클라이언트 컴포넌트는 클라이언트에서만 실행되지 않는다.
    - 클라이언트 컴포넌트는 사전 렌더링을 위해 서버에서 1번 실행 하이드레이션을 위해 브라우저에서 1번 실행 = 서버와 클라이언트에서 모두 실행됨
3. 클라이언트 컴포넌트에서 서버 컴포넌트르르 import 할 수 없다.
    - 클라이언트 컴포넌트 코드는 서버와 브라우저에서 모두 실행되지만 서버 컴포넌트 코드는 오직 서버에서만 실행되기 때문에 클라이언트 컴포넌트에서 서버 컴포넌트를 import하면 안된다.
        - 만약 클라이언트 컴포넌트에서 서버 컴포넌트를 import 한다면 터쳐버리는게 아니라 서버 컴포넌트를 클라이언트 컴포넌트로 변경해버린다.
        - 만약 클라이언트 컴포넌트가 서버 컴포넌트를 자식으로 둬야한다면 children으로 받아서 렌더링 해라
            - 넥스트는 칠드런으로 보낸 컴포넌트는 클라이언트 컴포넌트로 변경하지는 않음
4. 서버 컴포넌트에서 클라이언트 컴포넌트에게 직렬화 되지 않는 props는 전달 불가하다
    - 직렬화 : 객체, 배열, 클래스 등의 복잡한 구조의 데이터를 네트워크 상으로 전송하기 위해 아주 단순한 혀얘(문자열, Byte)로 변환하는 것
        - 자바스크립트 함수는 직렬화가 불가능하다.
        - 서버컴포넌트에서 클라이언트 컴포넌트로 향하는 Props가 될 수 없음 (서버 컴포넌트에서 함수를 props로 클라이언트 컴포넌트에 전달이 불가하다)
    - 넥스트 서버측에서 접속 요청을 받아서 JS(실행 사전 렌더링)을 진행할때 클라이언트 컴포넌트와 같이 실행됨
        - 페이지를 렌더링하기 위해서 클라이언트 서버 컴포넌트 막론하고 모든 컴포넌트를 전부 실행시켜 완성된 HTML 페이지를 생성하게 된다.
            - 엄밀히 말하면 모든 컴포넌트들이 한번에 실행되지는 않음
                - 서버 컴포넌트들이 먼저 실행됨 -> RSC Payload 생성 -> 그 이후에 클라이언트 컴포넌트들이 실행됨
                    - RSC Payload : json 과 비슷한 문자열 : 리엑트 서버 컴포넌트의 순수한 데이터(결과물),리엑트 서버 컴포넌트를 직렬화 한 결과
                        - 사바캄퍼넌트의 렌더링 결과
                        - 연결된 클라이언트 컴포넌트의 위치
                        - 클라이언트 컴포넌트에게 전달하는 Props 값
    - 개발 모드에서 사전 렌더링 적용 안됨
        - 프로덕션 모드로 실행시켜야 볼 수 있음 build -> npm run start
    - static page와 dynamic 페이지 동작이 다름
        - static page는 데이터 업데이트가 필요하지 않으니 rsc payload 와 js bunlde 불러옴
        - dynamic page는 데이터 업데이트가 필요하니 rsc payload만 불러오고 실제 페이지이동이 생겼을때만 js bunlde 불러옴

## 섹션5. 데이터 패칭

-   넥스트의 데이터 캐시 옵션

    -   다른 라이브러리는 안됨 무적권 fetch 옵션(일반적인 fetch가 아닌 넥스트가 몇개 기능 더 붙여둔 확장판 fetch )
        -   왜 우리꺼 리엑트 쿼리 해도 되나?
        -   no-store : 캐시하지 않으니 백엔드 서버에 바로 데이터 요청 (기본 값)
        -   force-cache : 요청의 결과를 무적권 캐싱하고, 한번 호출 된 이후에는 다시는 호출되지 않음 (캐싱된 데이터는 .next 폴더안에 chache 파일에 있음)
        -   rervalidate : 특정 시간을 주기로 캐시를 업데이트 함, 마치 패이지 라우터이 ISR 방식과 유사함
        -   tag : 요청이 들어왔을 때 데이터를 최신화함

-   next.config.mjs 파일

    ```ts
    const nextConfig = {
        logging: {
            fetches: {
                fullUrl: {
                    fullUrl: true,
                },
            },
        },
    };
    ```

    -   next 앱에서 발생하는 모든 데이터 패칭이 로그로 나옴

-   Request Memoization
    -   하나의 페이지를 렌더링하는 도중에 발생하는 중복되는 api 요청들을 캐싱하기 위해 존재함, 렌더링이 종료되면 모든 캐시가 소멸된다.
        -   그냥 요청 안보내면 되는거 아닌가? -> 서버 컴포넌트의 등장때문
-   데이터 캐시

    -   백엔드 서버로부터 불러온 데이터를 거의 영구적으로 보관하기 위해 사용됨, 서버 가동중에는 영구적으로 보관

-   풀 라우트 캐시
    -   Next 서버측에서 빌드 타임에 특정 페이지의 렌더링 결과를 캐싱하는 기능
        -   정적 페이지만 풀 라우트 캐시가 가능함, 다이나믹 페이지로 설정되는 기준, 특정 페이지가 접속 요청을 받을 때 마다 매번 변화가 생기거나, 데이터가 달라질 경우
        -   다이나믹 페이지 설정 기준
            -   특정 페이지가 접속 요청을 받을 때 마다 매번 변화가 생기거나, 데이터가 달라질 경우
                1. 캐시되지 않는 데이터 패칭을 사용할 경우
                2. 동적 함수(쿠키, 헤더, 쿼리스트링)을 사용하는 컴포넌트가 있을 때
        -   스태틱 페이지로 설정되는 기준
            -   다이나믹 페이지가 아니면 모두 정적 페이지 됨
-   빌드타임에 페이지를 생성하기 위해서 클라이언트 컴포넌트를 실행할때 빌드타임에 절대 값을 알 수 없는 애들은 사전 렌더링에서 베재하도록 설정해야함

    -   오직 클라이언트 측에서만 실행되도록 suspense를 감싸줘서 사전 렌더링 과정에서 베제되고 오직 클라이언트에서만 실행되게 해줘야함

-   되도록이면 정적 페이지로 만들어라
-   페이지안에 하나라도 상호작용 하 는게 있으면 동적 페이지됨

### 라우트 세그먼트 옵션

> 특정 페이지의 캐싱이나 리벨리 데이트 직접 강제로 설정할 수 있게 하는것

1. auto : 기본값, 아무것도 강제하지 않음
2. force-dynamic : 페이지를 강제로 다이나믹 페이지로 설정
3. force-static : 페이지를 강제로 static 페이지로 설정
4. error : 페이지를 강제로 static으로 설정 (설정하면 안되는 이유가 있다면 -> 빌드시 오류)

### 클라이언트 라우터 캐시 : 브라우저에 저장되는 캐시, 페이지 이동을 효율적으로 진행하기 위해 페이지의 일부 데이터를 보관함

-   루트 레이아웃, 서치바 레이아웃같은 레이아웃은 클라이언트 라우터 캐시 에 저장(중복되는 레이아웃들)
-   서버 컴포넌트다 페이지등만 불러오면 됨

### TS : 섹션8 제네릭

-   Array는 길이가 가변적이며, 동일한 타입의 요소로 구성됩 Tuple은 길이가 고정되어 있으며, 각 요소의 타입이 정해져 있음
-   JavaScript에는 없는 데이터 타입이며, TypeScript에서만 사용할 수 있음

```ts
function returnTrue<T>(data: T[]) {
    return data[0];
}

let str = returnTrue([1, 'dddd', 'asdas']);
```

-   타입이 (number | string)[] 으로 잡힘 0번째를 꺼내라했지만 타입스크립트는 그걸 몰라서 유니온 타입으로 추론해버림
-   첫번째 요소 타입을 추론하게 하고싶다면 ?
    -   튜플타입을 사용하기
    ```ts
    function returnTrue<T>(data: [T, ...unknown[]]) {
        return data[0];
    }
    ```

#### extends 를 활용한 타입 변수에 조건을 달아서 제한

```ts
function getLength<T extends { length: number }>(data: T) {
    return data.length;
}

let var1 = getLength([1, 2, 3]);
let var2 = getLength(['1234324']);
let var3 = getLength({ length: 10 });
// 오류
let var4 = getLength(10);
```

## TIL 공유회

# 공부할 키워드

### 할거
