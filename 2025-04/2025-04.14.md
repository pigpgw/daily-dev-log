# TIL | 2025.04.14

## 주간 목표

-   계획한 미라클 모닝 자리잡기
-   스픽 에매랄드에서 승급하기
-   루틴 확립하기
-   오늘 다하려고 진행 순서에 적어둔게 아니다 내일 까먹을까봐 순서에 넣어둔거다
-   [벨로그](https://velog.io/@pigpgw/%EB%82%98%EC%9D%98-%EA%B0%9C%EB%B0%9C-%EC%84%B1%EC%9E%A5-%EC%A0%84%EB%9E%B5-%EC%83%9D%EA%B0%81%ED%95%98%EB%8A%94-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A1%9C-%EB%82%98%EC%95%84%EA%B0%80%EA%B8%B0)에 작성한 것들 습관화하기

### 오늘 진행 순서 예정

-   [x] 아침 운동 : 조깅 걷뛰 1.5km + 팔굽 100개 + 코어 5분
-   [x] 스픽
-   [x] 책 읽기
-   [x] 블로그 하나 읽기 [Zustand와 React Context](https://velog.io/@ojj1123/zustand-and-react-context)
-   [] 알고리즘
    -   [] 날짜온도 문제 풀기
-   [] 정처기 필기 신청
-   [] 항해 99 면접 챌린지
-   [] 유익한 유튜브 시청하기
-   [] 주시 회의
-   [] 주시 작업

    -   [] 프로젝트 디렉토리 구조 개선 이유 및 선정이유
    -   [] 리펙토링
    -   [] fetch 대신 react query를 사용한 이유
    -   [] fetch란 ,axios와 다른점
    -   [] next에서 fetch가 강력한 이유
    -   [] react query가 필요 없는 이유
    -   [] react query -> fetch
    -   [] next 강의

-   [] 스마게 알림 api 추가
-   [] 등 + 가슴
-   [] TIL 공유회
-   [] 강의 수강
    -   알고리즘 : LIFO 2번째 문제 ~
    -   TS : 섹션8
    -   Next : 섹션4 App Router ~

---

# TIL

### 오늘 진행 순서 예정

## 책 읽기

### 11.2.2 클래스 기반의 모델로 변환

-   ACL 패턴을 적용하기 (안티패턴 책 280P)
    -   타입스크립트의 클래스를 사용해서 데이터와 로직을 한 곳에 모다 모델로 캡슐화
        -   메뉴 아이템 타입을 클래스로 바꾸고, 모든 변환 로직을 한굿에 모으는것
            -   이 설정은 이후 데이터 형태의 변경이나 관련 로직을 다루는 별도의 허브 역할을 하게 됨
                ```ts
                export class MenuItem {
                    ~~~
                }
                // 사용
                return new MenuItem(item)
                ```
                -   어쩔때 이렇게하는게 좋을까 이걸 뭐라할까 (클래스 기반의 모델 정의)
                    -   데이터 모델이란?
                        -   클래스 기반의 모델 정의란?
                        -   클래스 기반의 모델 장점은?
                        -   인터페이스를 구현할 추상 클래스는
                        -   js 추상 클래스란?
                            -   추상 클래스는 다른 클래스의 기본 바탕이 되는 클래스로, 추상 클래스만으로는 인스턴스를 생성할 수 없음, 이것은 공통의 인터페이스 또는 파생될 클래스들을 정의하는데 사용
                            -   추상 클래스는 실제 구현 없이 선언되는 추상 메서드를 가지고 있으며, 구체적인 구현은 파생되는 클래스에 맡김
                            -   이를 통해 추상 클래스는 파생 클래스에서도 특정 메서드가 구현됨을 보장하겨 기능을 일관되게 하면서도 공통된 구조를 유지할 수 있게함
                            -   이는 객체지향 프로그래밍의 다형성과 캡슐화를 지원하는 핵심

## 블로그 하나 읽기 [Zustand와 React Context](https://velog.io/@ojj1123/zustand-and-react-context)

### zustand 마음에 안드는 한가지

-   빠르고, 간단하고, 번들 크기로 좋은데 스토어는 전역이라는게 마음에 안듬
-   하나의 컴포넌트 트리에서 전역적으로 사용할 수 있는 상태가 필요한 경우가 더 많다는 걸 많이들 느껴봄

### 전역 스토어 단점

#### props를 통한 초기화

-   전역 스토어는 reaact 컴포넌트 생명주기 외부에서 생성되서 prop으로 얻은 값으로 스토어를 초기화 할 수 없음
-   전역 스토어를 사용하려면 먼저 기본 상태로 스토어를 생성한 다음 useEffect로 props와 스토어를 동기화해야함
-   useEffect를 쓰고싶지 않은 것외에도 두가지 이유로 이상적이지 않습니다.
    -   먼저 effect가 시작되기 전에 <ResetOfTheApp />을 bears: 0으로 렌더링한 다음 올바른 initialBears 로 다시 한 번 렌더링합니다.
    -   실제로 initialBears 로 스토어를 초기화하는 것이 아니라 동기화합니다. 따라서 initialBears 가 변경되면 스토어에도 업데이트가 반영되는 것을 볼 수 있습니다.

#### 테스팅

-   zustand 테스트문서 꽤 혼란스럽고 복잡함

#### 재사용성

-   전역 store 를 사용하면 상태가 "공유" 됨
-   그런데 컴포넌트를 여러 번 사용하고 싶다면, 상태도 "독립" 되어야 함
-   전역 store 는 모든 인스턴스가 같은 상태를 사용하기 때문에, 하나의 컴포넌트에서 선택을 바꾸면 다른 컴포넌트에도 영향을 줌
-   따라서 재사용 가능한 컴포넌트를 만들 때는 전역 store 가 아니라 컴포넌트 로컬 store 를 설계해야 함

### 이러한 문제를 해결할 React Context

-   zustand createStore와 create 차이
    | 구분 | `create` | `createStore` |
    |---|---|---|
    | 목적 | 훅 기반 zustand store 만들기 (React Hook) | **vanilla** zustand store 인스턴스 만들기 (Hook 없음) |
    | 사용법 | 컴포넌트에서 바로 `useMyStore()` 처럼 사용 | store 인스턴스를 수동으로 생성하고, 원하는 곳에서 가져다 씀 |
    | store 위치 | 전역 store (앱 어디서나 접근) | 컴포넌트 안에서도 생성 가능 (컴포넌트마다 store 따로 생성) |
    | 예시 | `const useStore = create(...)` | `const store = createStore(...)` |
    | context 사용 | 필요 없음 (전역이니까) | context 와 같이 사용하면 컴포넌트 별로 독립 store 가능! |

---

#### store 생성 함수

```ts
import { createStore } from 'zustand/vanilla';

const createMyStore = () =>
    createStore((set) => ({
        count: 0,
        increase: () => set((state) => ({ count: state.count + 1 })),
    }));
```

```ts
import React, { createContext, useContext, useState } from 'react';

// 1. Context 만들기
const StoreContext = createContext(null);

// 2. Provider 만들기
const StoreProvider = ({ children }) => {
    // store 생성 (초기화는 여기서!)
    const [store] = useState(() => createMyStore());

    return <StoreContext.Provider value={store}>{children}</StoreContext.Provider>;
};
```

#### 만든 store 를 context 에 넣기

```ts
import { useStore as useZustandStore } from 'zustand';

const useStore = (selector) => {
    const store = useContext(StoreContext);
    if (!store) throw new Error('StoreProvider 안에서 써야 합니다!');
    return useZustandStore(store, selector);
};
```

-   zustand 의 useStore 훅을 연결

#### context 에서 꺼내서 쓰기

```ts
const Counter = () => {
    const count = useStore((state) => state.count);
    const increase = useStore((state) => state.increase);

    return (
        <div>
            <p>{count}</p>
            <button onClick={increase}>Increase</button>
        </div>
    );
};
```

-   컴포넌트 안에서 store 를 만들었으니까 컴포넌트마다 독립 store!
-   같은 Counter 컴포넌트를 여러 번 사용해도, 각각 독립적인 상태 🎉

## 알고리즘

-   시간 복잡도 강의 듣기
    -   for - while 중첩되었다고 무조건 n제곱이 아니다.
        -   어떻게 코드를 작성하냐에 따라 다름
    -   상수 시간도 완전 무시할 순 없다.
    -   코테 시간제한 기준점 : 10 ^ 8
    -   시간복잡도는 만능이 아니다.
    -   풀이에 대한 확신
    -   알고리즘 떠올리기

### 코테 적용 방법

-   Step1 문제 이해하기
    -   문제를 제대로 읽기
    -   제약조건 읽기
        -   효율성 테스트 10^8 넘으면 안됨
        -   원소 값의 범위
            -   int === 4byte => 1bit는 부호 31bit는 수 표현 -2^31 ~ 2^31 + 1
                -   2의 31승은 10의 9승 그러면 인트형 변수에 저장 불가
-   Step2 접근 방법
    -   직관적으로 생각하기
        -   보통 완전 탐색으로 시작
        -   문제 상황을 단순화 하여 생각하기
        -   문제 상황을 극한화 하여 생각하기
    -   자료구조와 알고리즘 활용
        -   Step1 문제이해 에서 파악한 내용을 토대로 어떤 자료구조를 사용하는게 가장 적합한지 결정
        -   대놓고 특정 자료구조와 알고리즘을 묻는 문제도 많음
        -   자료구조에 따라 선택할 수 있는 알고리즘을 문제에 적용
    -   메모리 사용
        -   시간복잡도를 줄이기 위해 메모리를 사용하는 방법
        -   대표적으로 해시테이블

### 대표 알고리즘

-   O(1): Operation push and pop on Stack
-   O(log n): Binary Tree
-   O(n): for loop
-   O(n×log n): Quick Sort, Merge Sort, Heap Sort
-   O(n2): Double for loop, Insert Sort, Bubble Sort, Selection Sort
-   O(2n): Fibonacci Sequence

### 문제 풀이 과정

-   step1 문제 이해하기
    -   input, output 확인
        -   input 값의 특징 (정수인가? 값 크기의 범위는? 마이너스도 되는건가? 소수인가? 자료형은 문자열인가? 등등)
        -   Output 값의 특징 (내가 어떤 값을 반환해줘야 하는지, 정해진 형식대로 반환하려면 어떻게 구현할지)
    -   input size N 확인
        -   시간복잡도를 계산하기 위한 input size N 또는 M 이 무엇인지 확인
    -   제약조건 확인
        -   시간복잡도 제한이 있는지 확인
        -   내가 선택할 수 있는 알고리즘이 무엇이 있는지
    -   예상할 수 있는 오류 파악
        -   상황을 가정하면서 예상할 수 있는 오류를 파악
        -   입력값의 범위 ,stack overflow 등

---

## 항해 99 면접 챌린지

## 유익한 유튜브 시청하기

## 주시 회의

## 강의 수강(Next, 타입스크립트, 알고리즘)

### 알고리즘 : LIFO 2번째 문제 ~

### TS : 섹션8

### Next : 섹션4 App Router ~

## TIL 공유회

# 공부할 키워드

### 할거
