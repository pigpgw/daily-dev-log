# TIL | 2025.04.10

## 주간 목표

-   계획한 미라클 모닝 자리잡기
-   스픽 루비티어에서 승급구간 유지해서 승급하기
-   루틴 확립하기
-   오늘 다하려고 진행 순서에 적어둔게 아니다 내일 까먹을까봐 순서에 넣어둔거다
-   [벨로그](https://velog.io/@pigpgw/%EB%82%98%EC%9D%98-%EA%B0%9C%EB%B0%9C-%EC%84%B1%EC%9E%A5-%EC%A0%84%EB%9E%B5-%EC%83%9D%EA%B0%81%ED%95%98%EB%8A%94-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A1%9C-%EB%82%98%EC%95%84%EA%B0%80%EA%B8%B0)에 작성한 것들 습관화하기

### 오늘 진행 순서 예정

-   [x] 아침 운동 : 조깅 걷뛰 1.5km + 팔굽 100개 + 코어 5분
-   [x] 스픽
-   [x] 알고리즘
    -   [x] 링크드 리스트 구현
-   [x] 항해 99 면접 챌린지
    -   [x] 클로저
    -   [x] 상태관리
    -   [x] 렌더링 최적화
    -   [x] 기술 도입 과정
    -   [x] 최근 실패했던 경험
-   [] 블로그 하나 읽기 [리액트 렌더링 동작의 (거의) 완벽한 가이드](https://velog.io/@arthur/%EB%B2%88%EC%97%AD-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EB%A0%8C%EB%8D%94%EB%A7%81-%EB%8F%99%EC%9E%91%EC%9D%98-%EA%B1%B0%EC%9D%98-%EC%99%84%EB%B2%BD%ED%95%9C-%EA%B0%80%EC%9D%B4%EB%93%9C-A-Mostly-Complete-Guide-to-React-Rendering-Behavior)
-   [] 유익한 유튜브 시청하기
-   [] 책 읽기(안티패턴을 넘어 TDD와 리펙터링으로 완성하는 리액트 설계)
-   [] 스마게 작업
    -   채널 채팅 코드 분석 후 이후 작업 결정 (재작성 or 수정)
        -   [] 이전 채팅 불러오기 확인
        -   [] 어떻게 해야할지 공부
        -   [] 문제 분석하기
        -   [] 무한 스크롤 구현 방법 공부
-   [] 주시 회의
-   [] 주시 작업 (작업 보류하고 공부하기 지금으로선 그게 맞을듯)
    -   [] api 연결 실패시 폴링 무효화 처리
-   [] 헬스(어깨) : 4분할(가볍게 30분 ~ 40분) + 조깅 걷뛰 1.5km(최대한 하려고 노력중)
-   [] 알고리즘 강의 수강
-   [] TIL 공유회 (윤성이 사정상 생략)
-   [] 강의 수강(타입스크립트, 알고리즘)

---

# TIL

# 블로그 읽기

---

## 알고리즘

-   시간 복잡도 강의 듣기
    -   for - while 중첨되었다고 무적권 n제곱이 아니다.
        -   어떻게 코드를 작성하냐에 따라 다름
    -   상수 시간도 완전 무시할 순 없다.
    -   코테 시간제한 기준점 : 10 ^ 8
    -   시간복잡도는 만능이 아니다.
    -   풀이에 대한 확신
    -   알고리즘 떠올리기

### 코테 적용 방법

-   Step1 문제 이해하기
    -   문제를 제대로 읽기
    -   제약조건 읽기
        -   효율성 테스트 10^8 넘으면 안됨
        -   원소 값의 범위
            -   int === 4byte => 1bit는 부호 31bit는 수 표현 -2^31 ~ 2^31 + 1
                -   2의 31승은 10의 9승 그러면 인트형 변수에 저장 불가
-   Step2 접근 방법
    -   직관적으로 생각하기
        -   보통 완전 탐색으로 시작
        -   문제 상황을 단순화 하여 생각하기
        -   문제 상황을 극한화 하여 생각하기
    -   자료구조와 알고리즘 활용
        -   Step1 문제이해 에서 파악한 내용을 토대로 어떤 자료구조를 사용하는게 가장 적합한지 결정
        -   대놓고 특정 자료구조와 알고리즘을 묻는 문제도 많음
        -   자료구조에 따라 선택할 수 있는 알고리즘을 문제에 적용
    -   메모리 사용
        -   시간복잡도를 줄이기 위해 메모리를 사용하는 방법
        -   대표적으로 해시테이블

### 대표 알고리즘

-   O(1): Operation push and pop on Stack
-   O(log n): Binary Tree
-   O(n): for loop
-   O(n×log n): Quick Sort, Merge Sort, Heap Sort
-   O(n2): Double for loop, Insert Sort, Bubble Sort, Selection Sort
-   O(2n): Fibonacci Sequence

### 링크드리스트 코테 적용

1. 링크드리스트 자유자재로 구현 (선형 자료구조 + 중간에 데이터 추가/삭제 용이)

### 문제 풀이 과정

-   step1 문제 이해하기
    -   input, output 확인
        -   input 값의 특징 (정수인가? 값 크기의 범위는? 마이너스도 된느건가? 소수인가? 자료형은 문자열인가? 등등)
        -   Output 값의 특징 (내가 어떤 값을 반환해줘야 하는지, 정해진 형식대로 반환하려면 어떻게 구현할지)
    -   input size N 확인
        -   시간복잡도를 계산하기 위한 ㅑnput size N 또는 M 이 무엇인지 확인
    -   제약조건 확인
        -   시간복잡도 제한이 있는지 확인
        -   내가 선택할 수 있는 알고리즘이 무엇이 있는지
    -   예상할 수 있는 오류 파악
        -   상황을 가정하면서 에상할 수 있는 오류를 파악
        -   입력값의 범위 ,stack overflow 등

---

### 항해 99 면접 챌린지

-   [x] 질문 1 : 자바스크립트에서 클로저란 무엇인가
    -   클로저에 대해 설명하고 어떻게 활용될 수 있는지 예제와 함께 설명하라
        -   힌트 : 함수와 그 함수가 선언된 렉시컬 환경과의 조합을 생각해보라
        -   > 클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합으로 반환된 내부함수가 자신이 선언됬을 때의 환경인 스코프를 기억하는 함수다.
-   [x] 질문 2 : UI 상태 관리

    -   UI 상태 관리에서 어려움을 겪었던 경험이 있다면, 어떤 방식으로 구조를 개선하거나 상태를 관리했는지 설명해 주세요. 그 과정에서 적용한 성능 최적화 기법이나 고민한 점이 있다면 함께 설명해 주세요.
        -   상태 관리란 단순한 useState 부터 전역 상태 관리 라이브러리까지 포함됩니니다.
        -   어려웠던 점 -> 개선 방향 -> 성능 혹은 사용자 경험 향상을 연결해 보세요
        -   > 여러 개의 모달을 따로 관리하던 중, 불필요하게 코드가 많아지고 모달마다 상태를 가져가다 보니 모달이 쌓이는 상황이 생겼습니다. 모달이 중첩되면 사용 흐름이 복잡해지고 사용자가 비상구를 찾지 못하는 것처럼 느껴질 수 있다고 생각했습니다. 그래서 여러 가지 모달을 한 번에 관리할 수 있도록 별도의 모달 매니저라는 상태를 만들어 모달 간의 상태를 한 곳에서 다루었습니다. 이를 통해 중첩 모달을 제공하지 않고, 개발자도 다른 모달의 상태를 신경 쓰지 않아도 되도록 개선한 경험이 있습니다.

-   [x] 질문 3 [공통]

    -   기존 코드베이스에 새로운 기술이나 도구를 도입했던 경험이 있다면, 어떤 리스크를 고려했고, 이를 어떻게 관리했는지 설명해주세요.
        -   실무 경험이 없다면 팀 프로젝트나 사이드 프로젝트에서 고민했던 사례를 공유해주세요.
        -   > 시위 응원하기 기능을 구현하면서, 어떻게 하면 리액트에서 소켓을 안정적으로 다룰 수 있을지 고민했습니다. 처음에는 리액트 생명주기와 다르게 동작하는 소켓의 특성 때문에 ref를 사용하여 소켓 인스턴스를 관리했습니다. 하지만 소켓의 유일성이 보장되지 않을 것 같다는 생각이 들어, 싱글톤 패턴을 적용해 하나의 인스턴스를 유지하도록 개선했습니다. 이후 유지보수성을 높이기 위해 소켓을 추상화하여, 동일한 규격만 맞추면 어떤 소켓 라이브러리든 적용할 수 있도록 설계했습니다. 또한 소켓 연결이 실패하는 상황을 대비해, 소켓 연결 실패 시에는 폴링 방식으로 기능이 동작하도록 설계하여 안정성을 확보했습니다. 다만, 원래 의도했던 대로 숫자가 하나하나 실시간으로 변하는 모습을 사용자에게 보여주는 방식은 많은 사용자가 동시에 사용할 때 서버 자원을 과도하게 소모할 뿐만 아니라, 사용자 입장에서도 숫자가 하나하나 변하는 것이 큰 의미를 주지 않는다고 판단했습니다. 그래서 최종적으로는 폴링 방식으로 전환하여 서버의 자원 소모를 줄이고, 사용자에게도 보다 효율적인 경험을 제공할 수 있었습니다. 결과적으로, 소켓을 사용한 실시간 처리에서 출발했지만 실제 서비스 상황과 사용자 경험을 고려해 더 적합한 방식으로 개선할 수 있었습니다.

-   [x] 질문 4 [프론트엔드]

    -   사용자 화면 렌더링이 느리거나 지연됐던 경험이 있다면, 문제를 어떻게 분석하고 어떤 방식으로 개선했는지 설명해주세요. 작은 프로젝트여도 괜찮습니다.
    -   > 이건 가볍게 디바운스와 쓰로틀 경험밖에 없음 현재 진행중인 프로젝트에 최적화 문제가 있는데 해당 부분 해결 후 작성 예정

-   [x] 질문 5 [인성]
    -   최근에 실패했던 경험이 있다면 솔직하게 공유해주세요. 그 실패로부터 무엇을 배우고, 어떻게 성장했는지도 함께 이야기해주세요. 결과가 좋지 않아도 괜찮습니다.
    -   > 최근에 많은 실패를 겪으면서 성장하려고 노력 중입니다. 그중 하나가 미라클 모닝 실천입니다. 처음에는 의욕적으로 시작했지만 여러 번 실패하면서 좌절감을 느꼈습니다. 특히 새로운 습관을 만들 때 전두엽이 많이 관여하는데, 갑자기 큰 변화를 주면 전두엽이 과부하되어 기존 습관으로 돌아가 버린다는 것을 알게 되었습니다. 그래서 접근 방식을 바꾸었습니다. 모든 습관을 30분이나 1시간처럼 큰 단위로 설정하는 것이 아니라, 5분 또는 1분 단위로 아주 작게 나누어 실천하기 시작했습니다. 작은 성공 경험을 반복하면서 뇌를 훈련시키는 방식으로 점진적으로 변화를 시도한 결과, 기존에는 오전 10시에 일어나 하루 일과를 오후에 마무리했지만, 지금은 오전 7시에 기상하여 이전에는 오후에 끝내던 일과를 10시 이전에 마칠 수 있게 되었습니다. 미라클 모닝에 자꾸 실패했던 경험을 통해 변화는 큰 목표보다 작은 성공의 반복에서 시작된다는 것을 배웠고, 앞으로도 이런 방식으로 꾸준히 성장해 나가고 있습니다.

---

# 스마게

### 스마게 작업

-   채팅
    -   싹 다 고쳐야함

# 주시

# 공부할 키워드

-   공통 컴포넌트 설계
    -   rest
    -   기본 타입 확장
        -   공통 버튼 컴포넌트 만드는데 어떻게 해야할지 모르겠음,
-   React
    -   리엑트에서의 단일 책임 원칙
    -   리엑트 쿼리 사람답게 쓰기
-   next
    -   next Image
    -   next 에서 fetch
    -   next에서 react query
    -   Next.js 에서 local, development, production 환경 셋팅하기
-   작업
    -   next에서 fetch params next invalidate
    -   현재 폴링을 리엑트 쿼리로 구현함 올바른가?
        -   fetch로는 안되냐?
        -   왜 fetch로 폴링 구현하면 개발서버에서는 안되고 배포 서버에서만 되냐
    -   현재 구현된 소켓 로직 다시 생각
        -   현재 구조를 그려보기
        -   개선점 파악하기
        -   있다면 개선
        -   에러처리 생각하기
        -   최적화 부분 생각하기
    -   구현한 폴링 방식 올바른가 (그려보기)
        -   현재 구조를 그려보기
        -   개선점 파악하기
        -   있다면 개선
        -   에러처리 생각하기
        -   최적화 부분 생각하기
-   패키지 매니저
    -   package.json
        -   ^ 메이저 버전 이상 아무거나
    -   packagelock.json
        -   정확한 현재 프로젝트에 설치된 라이브러리 버전 명시

---

# 한 입 크기로 잘라먹는 타입스크립트

-

# 패턴으로 익히고 설계로 완성하는 리액트

-   ch4 리액트 컴포넌트 설계하기 ~

# 프론트엔드 아키텍처

## 뷰 로직과 비즈니스 로직의 분리

### 목적

-   **컴포넌트 재사용성 증가**
-   **유지보수성 향상**
-   **테스트 용이성 확보**

### 예시

#### 뷰 로직 (UI 컴포넌트)

```tsx
const ProductCard = ({ product, onBuy }: Props) => {
    return (
        <div>
            <p>{product.name}</p>
            <button onClick={() => onBuy(product.id)}>구매</button>
        </div>
    );
};
```

#### 비즈니스 로직 (커스텀 훅)

```ts
const useBuyProduct = () => {
    const mutation = useMutation((productId) => buyAPI(productId));
    return mutation;
};
```

### 좋은 구조

-   UI: 입력 → 출력에 집중 (props 기반)
-   로직: 상태 관리, 요청 처리 등은 **hooks나 service 파일로 분리**

## 공부하고 싶은 키워드

## 1. **소프트웨어 설계 원칙 관련**

| 주요 개념                                  | 설명                                           | 함께 공부하면 좋은 개념                                                                   |
| ------------------------------------------ | ---------------------------------------------- | ----------------------------------------------------------------------------------------- |
| **관심사의 분리 (Separation of Concerns)** | 기능/책임/영역을 나눠서 복잡도를 낮추는 원칙   | - SRP (단일 책임 원칙)<br>- 모듈화(Modularity)<br>- MVC/MVVM 패턴<br>- 레이어드 아키텍처  |
| **추상화 계층 (Abstraction Layer)**        | 하위 로직을 숨기고 필요한 기능만 노출하는 구조 | - 캡슐화<br>- 인터페이스 / 추상 클래스<br>- 레이어드 아키텍처<br>- 의존성 역전 원칙 (DIP) |
| **비즈니스 로직 (Business Logic)**         | 애플리케이션의 핵심 규칙/기능을 수행하는 부분  | - 도메인 모델<br>- 서비스 계층<br>- 유스케이스<br>- 엔티티(Entity), DTO                   |

---

## 2. **프론트엔드 구조/설계**

| 주요 개념                                | 설명                                        | 함께 공부하면 좋은 개념                                                     |
| ---------------------------------------- | ------------------------------------------- | --------------------------------------------------------------------------- |
| **Container vs Presentational 컴포넌트** | 비즈니스 로직과 UI 로직을 나누는 React 설계 | - 관심사 분리<br>- 컴포넌트 책임 분리<br>- Hooks 구조화                     |
| **상태 관리 구조 (Zustand, Redux, etc)** | 상태를 어디서/어떻게 다룰지 정의            | - 비즈니스 로직 위치<br>- Store 분리 전략<br>- Selector, middleware         |
| **API Layer 분리**                       | API 요청을 별도 레이어로 나눔               | - Axios 커스텀 인스턴스<br>- Query Hook abstraction<br>- Service Layer 구조 |

---

## 4. **실무 적용 관점 (실제로 설계할 때 유용한 개념)**

| 실무에서 접하는 개념    | 연관 개념                                     |
| ----------------------- | --------------------------------------------- |
| 서비스 레이어 설계      | 비즈니스 로직 분리, 추상화 계층, 관심사 분리  |
| 공통 API 오류 처리      | Axios 인터셉터, API 추상화 계층               |
| 유저 인증 흐름          | 상태 관리 분리, 관심사 분리, 로직 단위 모듈화 |
| 파일 구조 설계          | 기능/도메인 기반 구조 → 관심사 분리           |
| 테스트 설계 (단위/통합) | 비즈니스 로직과 UI 로직 분리 필요             |

### 참조

-   https://ssocoit.tistory.com/253
-   https://gngsn.tistory.com/167
