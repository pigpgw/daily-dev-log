# TIL | 2025.04.10

## 주간 목표

-   계획한 미라클 모닝 자리잡기
-   스픽 루비티어에서 승급구간 유지해서 승급하기
-   루틴 확립하기
-   오늘 다하려고 진행 순서에 적어둔게 아니다 내일 까먹을까봐 순서에 넣어둔거다
-   [벨로그](https://velog.io/@pigpgw/%EB%82%98%EC%9D%98-%EA%B0%9C%EB%B0%9C-%EC%84%B1%EC%9E%A5-%EC%A0%84%EB%9E%B5-%EC%83%9D%EA%B0%81%ED%95%98%EB%8A%94-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A1%9C-%EB%82%98%EC%95%84%EA%B0%80%EA%B8%B0)에 작성한 것들 습관화하기

### 오늘 진행 순서 예정

-   [x] 아침 운동 : 조깅 걷뛰 1.5km + 팔굽 100개 + 코어 5분
-   [x] 스픽
-   [x] 알고리즘
    -   [x] 링크드 리스트 구현
-   [x] 항해 99 면접 챌린지
    -   [x] 클로저
    -   [x] 상태관리
    -   [x] 렌더링 최적화
    -   [x] 기술 도입 과정
    -   [x] 최근 실패했던 경험
-   [x] 블로그 하나 읽기 [리액트 렌더링 동작의 (거의) 완벽한 가이드](https://velog.io/@arthur/%EB%B2%88%EC%97%AD-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EB%A0%8C%EB%8D%94%EB%A7%81-%EB%8F%99%EC%9E%91%EC%9D%98-%EA%B1%B0%EC%9D%98-%EC%99%84%EB%B2%BD%ED%95%9C-%EA%B0%80%EC%9D%B4%EB%93%9C-A-Mostly-Complete-Guide-to-React-Rendering-Behavior)
-   [x] 유익한 유튜브 시청하기 (프론트엔드 아키텍처 FSD)
-   [x] 책 읽기(안티패턴을 넘어 TDD와 리펙터링으로 완성하는 리액트 설계)
-   [x] 스마게 작업
    -   [x] 채널 채팅 코드 분석 후 이후 작업 결정
-   [x] 주시 회의
-   [x] 주시 작업 (작업 보류하고 공부하기 지금으로선 그게 맞을듯)
    -   [] api 연결 실패시 폴링 무효화 처리
-   [] 헬스(어깨) : 4분할(가볍게 30분 ~ 40분) + 조깅 걷뛰 1.5km(최대한 하려고 노력중)
-   [x] 알고리즘 강의 수강
-   [x] TIL 공유회 (윤성이 사정상 생략)
-   [] 강의 수강(타입스크립트, 알고리즘)

---

# TIL

# 블로그 읽기

---

## 알고리즘

-   시간 복잡도 강의 듣기
    -   for - while 중첩되었다고 무조건 n제곱이 아니다.
        -   어떻게 코드를 작성하냐에 따라 다름
    -   상수 시간도 완전 무시할 순 없다.
    -   코테 시간제한 기준점 : 10 ^ 8
    -   시간복잡도는 만능이 아니다.
    -   풀이에 대한 확신
    -   알고리즘 떠올리기

### 코테 적용 방법

-   Step1 문제 이해하기
    -   문제를 제대로 읽기
    -   제약조건 읽기
        -   효율성 테스트 10^8 넘으면 안됨
        -   원소 값의 범위
            -   int === 4byte => 1bit는 부호 31bit는 수 표현 -2^31 ~ 2^31 + 1
                -   2의 31승은 10의 9승 그러면 인트형 변수에 저장 불가
-   Step2 접근 방법
    -   직관적으로 생각하기
        -   보통 완전 탐색으로 시작
        -   문제 상황을 단순화 하여 생각하기
        -   문제 상황을 극한화 하여 생각하기
    -   자료구조와 알고리즘 활용
        -   Step1 문제이해 에서 파악한 내용을 토대로 어떤 자료구조를 사용하는게 가장 적합한지 결정
        -   대놓고 특정 자료구조와 알고리즘을 묻는 문제도 많음
        -   자료구조에 따라 선택할 수 있는 알고리즘을 문제에 적용
    -   메모리 사용
        -   시간복잡도를 줄이기 위해 메모리를 사용하는 방법
        -   대표적으로 해시테이블

### 대표 알고리즘

-   O(1): Operation push and pop on Stack
-   O(log n): Binary Tree
-   O(n): for loop
-   O(n×log n): Quick Sort, Merge Sort, Heap Sort
-   O(n2): Double for loop, Insert Sort, Bubble Sort, Selection Sort
-   O(2n): Fibonacci Sequence

### 링크드리스트 코테 적용

1. 링크드리스트 자유자재로 구현 (선형 자료구조 + 중간에 데이터 추가/삭제 용이)

### 문제 풀이 과정

-   step1 문제 이해하기
    -   input, output 확인
        -   input 값의 특징 (정수인가? 값 크기의 범위는? 마이너스도 되는건가? 소수인가? 자료형은 문자열인가? 등등)
        -   Output 값의 특징 (내가 어떤 값을 반환해줘야 하는지, 정해진 형식대로 반환하려면 어떻게 구현할지)
    -   input size N 확인
        -   시간복잡도를 계산하기 위한 input size N 또는 M 이 무엇인지 확인
    -   제약조건 확인
        -   시간복잡도 제한이 있는지 확인
        -   내가 선택할 수 있는 알고리즘이 무엇이 있는지
    -   예상할 수 있는 오류 파악
        -   상황을 가정하면서 예상할 수 있는 오류를 파악
        -   입력값의 범위 ,stack overflow 등

---

### 항해 99 면접 챌린지

-   [x] 질문 1 : 자바스크립트에서 클로저란 무엇인가
    -   클로저에 대해 설명하고 어떻게 활용될 수 있는지 예제와 함께 설명하라
        -   힌트 : 함수와 그 함수가 선언된 렉시컬 환경과의 조합을 생각해보라
        -   > 클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합으로 반환된 내부함수가 자신이 선언됬을 때의 환경인 스코프를 기억하는 함수다.
-   [x] 질문 2 : UI 상태 관리

    -   UI 상태 관리에서 어려움을 겪었던 경험이 있다면, 어떤 방식으로 구조를 개선하거나 상태를 관리했는지 설명해 주세요. 그 과정에서 적용한 성능 최적화 기법이나 고민한 점이 있다면 함께 설명해 주세요.
        -   상태 관리란 단순한 useState 부터 전역 상태 관리 라이브러리까지 포함됩니니다.
        -   어려웠던 점 -> 개선 방향 -> 성능 혹은 사용자 경험 향상을 연결해 보세요
        -   > 여러 개의 모달을 따로 관리하던 중, 불필요하게 코드가 많아지고 모달마다 상태를 가져가다 보니 모달이 쌓이는 상황이 생겼습니다. 모달이 중첩되면 사용 흐름이 복잡해지고 사용자가 비상구를 찾지 못하는 것처럼 느껴질 수 있다고 생각했습니다. 그래서 여러 가지 모달을 한 번에 관리할 수 있도록 별도의 모달 매니저라는 상태를 만들어 모달 간의 상태를 한 곳에서 다루었습니다. 이를 통해 중첩 모달을 제공하지 않고, 개발자도 다른 모달의 상태를 신경 쓰지 않아도 되도록 개선한 경험이 있습니다.

-   [x] 질문 3 [공통]

    -   기존 코드베이스에 새로운 기술이나 도구를 도입했던 경험이 있다면, 어떤 리스크를 고려했고, 이를 어떻게 관리했는지 설명해주세요.
        -   실무 경험이 없다면 팀 프로젝트나 사이드 프로젝트에서 고민했던 사례를 공유해주세요.
        -   > 시위 응원하기 기능을 구현하면서, 어떻게 하면 리액트에서 소켓을 안정적으로 다룰 수 있을지 고민했습니다. 처음에는 리액트 생명주기와 다르게 동작하는 소켓의 특성 때문에 ref를 사용하여 소켓 인스턴스를 관리했습니다. 하지만 소켓의 유일성이 보장되지 않을 것 같다는 생각이 들어, 싱글톤 패턴을 적용해 하나의 인스턴스를 유지하도록 개선했습니다. 이후 유지보수성을 높이기 위해 소켓을 추상화하여, 동일한 규격만 맞추면 어떤 소켓 라이브러리든 적용할 수 있도록 설계했습니다. 또한 소켓 연결이 실패하는 상황을 대비해, 소켓 연결 실패 시에는 폴링 방식으로 기능이 동작하도록 설계하여 안정성을 확보했습니다. 다만, 원래 의도했던 대로 숫자가 하나하나 실시간으로 변하는 모습을 사용자에게 보여주는 방식은 많은 사용자가 동시에 사용할 때 서버 자원을 과도하게 소모할 뿐만 아니라, 사용자 입장에서도 숫자가 하나하나 변하는 것이 큰 의미를 주지 않는다고 판단했습니다. 그래서 최종적으로는 폴링 방식으로 전환하여 서버의 자원 소모를 줄이고, 사용자에게도 보다 효율적인 경험을 제공할 수 있었습니다. 결과적으로, 소켓을 사용한 실시간 처리에서 출발했지만 실제 서비스 상황과 사용자 경험을 고려해 더 적합한 방식으로 개선할 수 있었습니다.

-   [x] 질문 4 [프론트엔드]

    -   사용자 화면 렌더링이 느리거나 지연됐던 경험이 있다면, 문제를 어떻게 분석하고 어떤 방식으로 개선했는지 설명해주세요. 작은 프로젝트여도 괜찮습니다.
    -   > 이건 가볍게 디바운스와 쓰로틀 경험밖에 없음 현재 진행중인 프로젝트에 최적화 문제가 있는데 해당 부분 해결 후 작성 예정

-   [x] 질문 5 [인성]
    -   최근에 실패했던 경험이 있다면 솔직하게 공유해주세요. 그 실패로부터 무엇을 배우고, 어떻게 성장했는지도 함께 이야기해주세요. 결과가 좋지 않아도 괜찮습니다.
    -   > 최근에 많은 실패를 겪으면서 성장하려고 노력 중입니다. 그중 하나가 미라클 모닝 실천입니다. 처음에는 의욕적으로 시작했지만 여러 번 실패하면서 좌절감을 느꼈습니다. 특히 새로운 습관을 만들 때 전두엽이 많이 관여하는데, 갑자기 큰 변화를 주면 전두엽이 과부하되어 기존 습관으로 돌아가 버린다는 것을 알게 되었습니다. 그래서 접근 방식을 바꾸었습니다. 모든 습관을 30분이나 1시간처럼 큰 단위로 설정하는 것이 아니라, 5분 또는 1분 단위로 아주 작게 나누어 실천하기 시작했습니다. 작은 성공 경험을 반복하면서 뇌를 훈련시키는 방식으로 점진적으로 변화를 시도한 결과, 기존에는 오전 10시에 일어나 하루 일과를 오후에 마무리했지만, 지금은 오전 7시에 기상하여 이전에는 오후에 끝내던 일과를 10시 이전에 마칠 수 있게 되었습니다. 미라클 모닝에 자꾸 실패했던 경험을 통해 변화는 큰 목표보다 작은 성공의 반복에서 시작된다는 것을 배웠고, 앞으로도 이런 방식으로 꾸준히 성장해 나가고 있습니다.

---

# 스마게

### 스마게 작업

-   코드 분석

# 주시

# TIL 공유회

### 📒 TIL - 무한 스크롤 vs. 페이지네이션 (채팅 히스토리)

오늘 친구와 무한 스크롤이 왜 우리 프로젝트(채팅 히스토리)에 적합하지 않은지, 그리고 어떤 방향으로 가야 할지에 대해 깊게 대화를 나눴다.

무한 스크롤의 본래 목적은 **새롭고 다양한 데이터를 지속적으로 노출하는 것**이다. 피드나 콘텐츠 추천 같은 데서 많이 쓰이는 UX인데, 이미 나눈 대화를 보는 채팅 히스토리에서는 맞지 않는다. 채팅은 과거의 히스토리를 조회하는 형태라서, 페이지네이션 방식이 더 자연스럽다. 즉, 우리가 채팅에서 원하는 것은 계속해서 새로운 대화가 아니라 **기존에 나눴던 대화를 필요한 시점에 효율적으로 가져오는 것**이기 때문에 무한 스크롤보다는 페이지네이션이 적합하다는 결론을 내렸다.

특히 무한 스크롤은 **캐싱 관리가 매우 어렵다.**  
페이지가 다르더라도 같은 쿼리에 저장되는 방식이라서, 예를 들면 1페이지부터 10페이지까지 다 한 캐시에 들어가 버린다.  
결국 캐시를 페이지나 댓글 수 단위로 나눠서 관리해야 하는데, 그렇지 않으면 캐시가 꼬이고 관리가 복잡해진다. 우리 프로젝트에서는 **"페이지 단위로 캐시를 관리하는 구조"** 가 더 맞다.

그래서 현재는 **스크롤되는 페이지네이션 형태**로 구현하는 게 좋다는 방향을 잡았다. 사용자는 스크롤로 자연스럽게 히스토리를 조회할 수 있고, 내부적으로는 페이지 단위로 데이터를 효율적으로 관리할 수 있다.

또한, React Virtualization (가상화 렌더링) 에 대해서도 이야기했는데, 이건 스크롤하는 컴포넌트가 많아지면 고려할 수 있는 기술이다. 윈도잉 기법으로 사용자의 뷰에 보이는 요소만 렌더링해서 성능을 최적화하는 방식이다.  
하지만 성능 최적화는 너무 성급하게 적용할 필요는 없다고 조언을 받았다. 일단 최대한 고민하고, 성능 저하 문제가 실제로 발생할 때 적용하는 게 맞다. **문제가 발생하지 않았는데 무조건 최적화를 적용하는 것은 오히려 불필요한 복잡도를 만든다.**

결론적으로, 나는 우리 프로젝트에서는 우선 페이지네이션으로 구현하고, 필요할 때 가상화 렌더링 같은 기술을 고민하는 방향으로 가기로 정리했다. 성능과 유지보수 모두 고려한 선택이라고 생각한다.

좋아요!  
친구가 말한 내용을 **TIL**용으로 자연스럽게 정리해드릴게요.  
이건 **API 추상화 / 계층 분리 / 객체 지향 메시지 통신** 에 대한 이야기였죠.

---

### 📒 TIL - API 추상화와 계층 분리, 객체 메시지 통신 (내가 공유한 내용)

오늘 친구와 깊이 있게 API 추상화에 대해 대화를 나눴다.  
특히 내가 현재 프로젝트에서 **API 요청과 응답을 어떻게 추상화하고 계층을 나누어야 할지**, 그리고 객체지향적 사고로 어떻게 풀어낼 수 있을지에 대해 많은 힌트를 얻었다.

---

### 친구가 공유한 내용

#### 📌 1. 추상화는 "적절한 인터페이스" 를 노출하는 것

-   너무 구체적이어도, 너무 넓어져도 안 된다.
-   예시: TV 리모컨
    -   음량 조절에 윗/아랫 버튼이면 충분한데 내부적으로 전극 5V~10V 입력 같은 세부 동작을 사용자에게 노출할 필요는 없음.
    -   채널 변경도 단순히 + / - 버튼이 있으면 되지, 너무 세세하게 설계하면 오히려 불편해진다.
-   결국 중요한 것은 "내 코드 (계층)를 사용하는 사람이 적절한 인터페이스를 사용할 수 있게 설계하는 것" 이다.

---

#### 📌 2. 프로젝트에 맞는 추상화 수준을 고려해야 한다

-   예를 들면, fetch API는 거의 모든 HTTP 기능을 사용할 수 있게 되어 있음. (method, headers, credentials 등)
-   하지만 우리 프로젝트에서 이런 것까지 다 노출해야 할까?  
    → **불필요하다.**
-   우리는 `fetch` 와 같은 저수준 기능이 아니라, 프로젝트에 맞는 고수준 인터페이스로 API를 감싸야 한다.
-   **중요 포인트:** 사용자가 알아야 할 것과 숨겨야 할 것을 구분하기

---

#### 📌 3. 계층 구조 설계

-   **Query 계층**
    -   react-query 관련 로직
-   **Service 계층**
    -   컴포넌트가 데이터를 "잘 읽을 수 있게" 정제
    -   예: 숫자 포맷팅, 상태 값 → 사용자 친화적인 값으로 변환 (예: "판매중" → "On Sale")
-   **Component 계층**
    -   오로지 화면 렌더링에만 집중
    -   레이아웃, 스타일 등 UI 관점에서만 고민

이렇게 계층을 나누면 각 계층의 역할이 명확해지고, 우리가 집중할 부분은 **서버 API 통신과 응답 처리 로직** 이라는 게 분명해졌다.

---

#### 📌 4. API 인스턴스와 파라미터 구분

-   적절한 추상화 수준을 위해 **자주 바뀌는 것과 거의 바뀌지 않는 것**을 구분해야 한다.
-   자주 안 바뀌는 것:
    -   baseURL, 인증 방식 (예: 토큰)
    -   → **API 인스턴스 내부에서 처리**
-   자주 바뀌는 것:
    -   HTTP method, path, query string, request body 등
    -   → **외부에서 파라미터로 전달**

이렇게 구분하면 API 인스턴스가 어떤 공통 로직을 가져야 하는지 명확해지고, 추상화의 방향성을 잡을 수 있다.

---

#### 📌 5. 반환 값 설계

-   Query 계층이 사용할 반환 값도 설계해야 한다.
-   JSON, HTTP status, 에러 등 어떤 정보를 제공할지 고민.
-   너무 과하게 많은 정보도 부담이 될 수 있으므로, 꼭 필요한 것만 선택적으로 반환하도록 설계하는 것이 중요하다.
-   추후에 필요하면 에러 전파 방식 (try-catch, throw 등) 을 고민해볼 수도 있음.

---

#### 📌 6. 인터셉터와의 차이

-   Axios 인터셉터와 비슷한 느낌이 있긴 하지만, 약간 다른 개념이다.
-   인터셉터는 Axios 인스턴스가 가진 하나의 기능이고, 요청을 가로채서 처리하는 역할.
-   우리의 API 추상화는 좀 더 "객체 간 메시지 통신" 으로 바라보면 된다.
-   즉, 객체가 서로 메시지를 주고받으면서 동작하도록 설계하는 것이 더 근본적인 접근.
-   참고로 **객체지향 사실과 오해** 책을 추천받았음! (건우는 4장까지 읽었다고 하심)

---

#### 📌 7. 정리

결국 이번 대화를 통해 나는 **"적절한 추상화란 무엇인가?"** 에 대한 큰 방향을 잡았다.

-   사용자(컴포넌트)가 너무 많은 것을 알 필요는 없다.
-   자주 바뀌는 것과 안 바뀌는 것을 구분하여, API 인스턴스를 설계한다.
-   계층마다 역할을 분리하여 책임을 분산한다.
-   객체지향적으로 보면, 객체는 메시지를 주고받으며 소통한다.

## 지금 설계하는 API 추상화가 객체 간 메시지 통신처럼 동작하게 만든다면, 확장성 있고 유지보수하기 쉬운 구조가 될 것이다!
