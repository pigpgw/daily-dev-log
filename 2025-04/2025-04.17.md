# TIL | 2025.04.17

## 주간 목표

-   계획한 미라클 모닝 자리잡기
-   스픽 루비티어에서 승급구간 유지해서 승급하기
-   루틴 확립하기
    -   충분한 수면을 가져가려고 노력하기 (TIL 공유를 조금 늦은 시간에 진행하고 2시에 취침하고 7시에 기상해서 운동까지 해버리니 너무 피곤함)
    -   일어나서 런닝하는건 지양한다. (피곤해지기 때문에)
    -   런닝은 하루 일과를 마무리하고 근력운동 전 또는 후에 진행한다.
    -   스픽을 운동하고 씻고 딱 한개만실시한다.
    -   최대한 이동하는 시간을 활용해서 진행한다.(다 남는 시간이다.)
    -   하루에 최소 알고리즘 하나를 풀도록 노력하기
-   [벨로그](https://velog.io/@pigpgw/%EB%82%98%EC%9D%98-%EA%B0%9C%EB%B0%9C-%EC%84%B1%EC%9E%A5-%EC%A0%84%EB%9E%B5-%EC%83%9D%EA%B0%81%ED%95%98%EB%8A%94-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A1%9C-%EB%82%98%EC%95%84%EA%B0%80%EA%B8%B0)에 작성한 것들 습관화하기

### 오늘 진행 순서 예정

-   [x] 아침 운동 : 팔굽 100개
-   [x] 스픽 (1개만)
-   [] 책 읽기
-   [x] 블로그 하나 읽기 [UX 관점에서 보는 로딩 상태](https://velog.io/@chlruddlf73/UX-%EA%B4%80%EC%A0%90%EC%97%90%EC%84%9C-%EB%B3%B4%EB%8A%94-%EB%A1%9C%EB%94%A9-%EC%83%81%ED%83%9C)
-   [x] 알고리즘
-   [x] 유익한 유튜브 시청하기
-   [x] 주시 회의
-   [x] 주시 작업 [프로젝트 컨벤션 적용기](https://github.com/dev-4-team/eye-on-frontend/pull/90)
-   [x] 운동 (런닝 1.5km)
-   [x] 강의 수강
    -   [x] 알고리즘 : 섹션 6 Tree level order ~
    -   TS : 섹션8 ~
    -   Next : 섹션4 App Router ~
    -   vitest : section 9 ~

---

### 내 코드가 유지보수하기 좋은지 고민하기

-   요구사항이 변경되었을 때 잘 대응할 수 있을까?
-   예를 들어, 상품 목록 리스트를 구현한다고 하면:
    -   나중에 상품에 다른 값들이 추가될 때 수정이 쉬울까?
    -   상품과 관련된 동작이 더 추가될 가능성은 없을까?
    -   뷰가 변경된다면, 지금 구조로 쉽게 다른 뷰로 바꿀 수 있을까?

조금 상상의 나래를 펼쳐서, 내 코드가 이런 상황에 놓였을 때 쉽게 변경이 가능한지 고민해 본다.  
사실 정말 더 좋은 방법은, 프로젝트를 진행하면서 실제로 요구사항이 바뀌는 상황을 겪어보는 것.

그렇게 경험한 후에, 이론적인 개념과 매칭시키면서 회고해 보는 게 더 효과적이다.

> 문제 상황을 발견 → 근거를 가지고 리팩터링 → 회고  
> (이런 과정을 반복하면서, "이런 이유 때문에 바꿨다", 혹은 "좋은 코드니까 유지한다"는 식으로 계속 시도해 본다.)

-   코드의 본질적인 부분에 대해 많이 고민하는 것이 중요하다.
-   화려한 기술을 써야 하는 상황일 때도 있지만, 사이드 프로젝트나 개인 프로젝트에서는 본질에 더 집중하는 게 좋다.

---

# TIL

### 오늘 진행 순서 예정

## 책 읽기

## 블로그 하나 읽기 [UX 관점에서 보는 로딩 상태](https://velog.io/@chlruddlf73/UX-%EA%B4%80%EC%A0%90%EC%97%90%EC%84%9C-%EB%B3%B4%EB%8A%94-%EB%A1%9C%EB%94%A9-%EC%83%81%ED%83%9C)

### 로딩 상태 표현이 UX에 긍정적인 이유. 그리고 상황, 속도, 방식에 따라 어떤 접근이 더 효율적인지를 이론적으로도 정리

-   단순히 기다리게 하는 것이 아니라, 사용자가 기다릴 수 있다고 ‘느끼게’ 만드는 것이 UX 설계의 핵심

-   도허티 임계는 시스템의 응답 시간이 0.4초 이내일 때 사용자 경험이 최적화된다는 원칙
-   책 “UI/UX의 10가지 심리학 법칙”에서는 도허티 임계값을 아래와 같이 정리함
    -   ~0.1초: 반응이 즉각적이라고 인지
    -   0.1초~0.3초: 지연이 감지되는 수준이라 인지
    -   0.4초~1초: 사용자의 주의가 분산되기 시작
    -   1초~: 사용자는 이미 집중하기 어려워지며, 필요한 정보를 놓치게 됨

> Google에서 조사한 로딩 시간별 사용자 이탈률을 보면, 도허티 임계에서 제시한 1초를 넘기는 시점부터 이탈률이 증가하기 시작하고, 3초 이후에는 급격히 상승함

### 로딩 상태처리

#### 종류

1. 스피너
2. 프로그래스 바
3. 스캘래톤 UI
4. 애니메이션

### 나누는 기준

#### 세계적인 UX 리서치 그룹 닐슨 노먼은 Progress Indicator에 대한 중요성을 강조하며 아래와 같은 주요 지침을 이야기 함

> 약 1초 이상 걸리는 작업에는 Progress Indicator를 사용하십시오.

> Loop Animation은 빠른 동작에만 사용하십시오.

> Percent-done Animation은 10초 이상 걸리는 작업에 사용하십시오.

> Static Indicator는 사용하지 마십시오.

-   [Skeleton UI가 항상 좋은 것은 아니다 : 카카로 페이 테크 블로그](https://tech.kakaopay.com/post/skeleton-ui-idea/)

    -   너무 짧은 로딩 상황에 스켈레톤을 사용하면 너무 짧은 시간만 노출되어 깜빡이는 듯한 불편한 경험을 주기에

### 쓰니가 정하신 로딩 UX 설계 기준 조합

-   0 ~ 0.2초: 아무것도 노출하지 않음
-   0.2 ~ 1초: Skeleton UI (최소 200ms 유지)
-   1 ~ 3초: 스피너 or 애니메이션
-   3 ~ 9초: 프로그래스 바
-   10초 이상: 정확한 백분율 표시기
-   정적 진행률 표시기: 사용 X

> 주관적인 생각으로는, 200ms는 사용자가 체감하기 어려울 정도로 빠른 속도라고 보심, API 응답 시간이 200ms 이내일 경우에는 빈 화면을 그대로 보여주고, Skeleton UI가 적용되는 경우라면, 최소 200ms 동안은 Skeleton이 유지된 후 실제 화면이 나타나도록 처리하려고 하심

> [좋은 블로그 로딩관련](https://velog.io/@yiseungyun/%EB%A1%9C%EB%94%A9-%ED%99%94%EB%A9%B4%EC%9D%84-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%B3%B4%EC%97%AC%EC%A4%84%EA%B9%8C)

## 알고리즘

-   시간 복잡도 강의 듣기
    -   for - while 중첩되었다고 무조건 n제곱이 아니다.
        -   어떻게 코드를 작성하냐에 따라 다름
    -   상수 시간도 완전 무시할 순 없다.
    -   코테 시간제한 기준점 : 10 ^ 8
    -   시간복잡도는 만능이 아니다.
    -   풀이에 대한 확신
    -   알고리즘 떠올리기

### 코테 적용 방법

-   Step1 문제 이해하기
    -   문제를 제대로 읽기
    -   제약조건 읽기
        -   효율성 테스트 10^8 넘으면 안됨
        -   원소 값의 범위
            -   int === 4byte => 1bit는 부호 31bit는 수 표현 -2^31 ~ 2^31 + 1
                -   2의 31승은 10의 9승 그러면 인트형 변수에 저장 불가
-   Step2 접근 방법
    -   직관적으로 생각하기
        -   보통 완전 탐색으로 시작
        -   문제 상황을 단순화 하여 생각하기
        -   문제 상황을 극한화 하여 생각하기
    -   자료구조와 알고리즘 활용
        -   Step1 문제이해 에서 파악한 내용을 토대로 어떤 자료구조를 사용하는게 가장 적합한지 결정
        -   대놓고 특정 자료구조와 알고리즘을 묻는 문제도 많음
        -   자료구조에 따라 선택할 수 있는 알고리즘을 문제에 적용
    -   메모리 사용
        -   시간복잡도를 줄이기 위해 메모리를 사용하는 방법
        -   대표적으로 해시테이블

### 대표 알고리즘

-   O(1): Operation push and pop on Stack
-   O(log n): Binary Tree
-   O(n): for loop
-   O(n×log n): Quick Sort, Merge Sort, Heap Sort
-   O(n2): Double for loop, Insert Sort, Bubble Sort, Selection Sort
-   O(2n): Fibonacci Sequence

### 문제 풀이 과정

-   step1 문제 이해하기
    -   input, output 확인
        -   input 값의 특징 (정수인가? 값 크기의 범위는? 마이너스도 되는건가? 소수인가? 자료형은 문자열인가? 등등)
        -   Output 값의 특징 (내가 어떤 값을 반환해줘야 하는지, 정해진 형식대로 반환하려면 어떻게 구현할지)
    -   input size N 확인
        -   시간복잡도를 계산하기 위한 input size N 또는 M 이 무엇인지 확인
    -   제약조건 확인
        -   시간복잡도 제한이 있는지 확인
        -   내가 선택할 수 있는 알고리즘이 무엇이 있는지
    -   예상할 수 있는 오류 파악
        -   상황을 가정하면서 예상할 수 있는 오류를 파악
        -   입력값의 범위 ,stack overflow 등

## 주시 작업

-   https://github.com/dev-4-team/eye-on-frontend/pull/90

### 알고리즘

-   https://leetcode.com/problems/number-of-islands/submissions/1609592914/
