# TIL | 2025.04.18

## 주간 목표

-   계획한 미라클 모닝 자리잡기
-   스픽 루비티어에서 승급구간 유지해서 승급하기
-   루틴 확립하기
    -   충분한 수면을 가져가려고 노력하기 (TIL 공유를 조금 늦은 시간에 진행하고 2시에 취침하고 7시에 기상해서 운동까지 해버리니 너무 피곤함)
    -   일어나서 런닝하는건 지양한다. (피곤해지기 때문에)
    -   런닝은 하루 일과를 마무리하고 근력운동 전 또는 후에 진행한다.
    -   스픽을 운동하고 씻고 딱 한개만실시한다.
    -   최대한 이동하는 시간을 활용해서 진행한다.(다 남는 시간이다.)
    -   하루에 최소 알고리즘 하나를 풀도록 노력하기
-   [벨로그](https://velog.io/@pigpgw/%EB%82%98%EC%9D%98-%EA%B0%9C%EB%B0%9C-%EC%84%B1%EC%9E%A5-%EC%A0%84%EB%9E%B5-%EC%83%9D%EA%B0%81%ED%95%98%EB%8A%94-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A1%9C-%EB%82%98%EC%95%84%EA%B0%80%EA%B8%B0)에 작성한 것들 습관화하기

### 오늘 진행 순서 예정

-   [x] 스픽
-   [x] 블로그 하나 읽기
-   [x] 알고리즘
    -   [x] 강의
    -   [x] 문풀 [DP](https://leetcode.com/problems/climbing-stairs/)
-   [x] 주시 회의
-   [x] 주시 작업

    -   [x] [react query의 도입이 올바른가?](https://github.com/dev-4-team/eye-on-frontend/issues/87)

-   [x] 스마게 작업
-   [x] 운동
-   [x] 강의 수강
    -   알고리즘 : DP 2번문제 ~
    -   TS : 섹션 8 ~ 섹션9
    -   Next : 섹션 8.2 : 인터셉트 라우팅 ~
    -   React testing

---

### 내 코드가 유지보수하기 좋은지 고민하기

-   요구사항이 변경되었을 때 잘 대응할 수 있을까?
-   예를 들어, 상품 목록 리스트를 구현한다고 하면:
    -   나중에 상품에 다른 값들이 추가될 때 수정이 쉬울까?
    -   상품과 관련된 동작이 더 추가될 가능성은 없을까?
    -   뷰가 변경된다면, 지금 구조로 쉽게 다른 뷰로 바꿀 수 있을까?

조금 상상의 나래를 펼쳐서, 내 코드가 이런 상황에 놓였을 때 쉽게 변경이 가능한지 고민해 본다.  
사실 정말 더 좋은 방법은, 프로젝트를 진행하면서 실제로 요구사항이 바뀌는 상황을 겪어보는 것.

그렇게 경험한 후에, 이론적인 개념과 매칭시키면서 회고해 보는 게 더 효과적이다.

> 문제 상황을 발견 → 근거를 가지고 리팩터링 → 회고  
> (이런 과정을 반복하면서, "이런 이유 때문에 바꿨다", 혹은 "좋은 코드니까 유지한다"는 식으로 계속 시도해 본다.)

-   코드의 본질적인 부분에 대해 많이 고민하는 것이 중요하다.
-   화려한 기술을 써야 하는 상황일 때도 있지만, 사이드 프로젝트나 개인 프로젝트에서는 본질에 더 집중하는 게 좋다.

---

# TIL

## 유익한 유튜브 시청하기

## 책 읽기

## 블로그 하나 읽기

## 알고리즘

-   시간 복잡도 강의 듣기
    -   for - while 중첩되었다고 무조건 n제곱이 아니다.
        -   어떻게 코드를 작성하냐에 따라 다름
    -   상수 시간도 완전 무시할 순 없다.
    -   코테 시간제한 기준점 : 10 ^ 8
    -   시간복잡도는 만능이 아니다.
    -   풀이에 대한 확신
    -   알고리즘 떠올리기

### 코테 적용 방법

-   Step1 문제 이해하기
    -   문제를 제대로 읽기
    -   제약조건 읽기
        -   효율성 테스트 10^8 넘으면 안됨
        -   원소 값의 범위
            -   int === 4byte => 1bit는 부호 31bit는 수 표현 -2^31 ~ 2^31 + 1
                -   2의 31승은 10의 9승 그러면 인트형 변수에 저장 불가
-   Step2 접근 방법
    -   직관적으로 생각하기
        -   보통 완전 탐색으로 시작
        -   문제 상황을 단순화 하여 생각하기
        -   문제 상황을 극한화 하여 생각하기
    -   자료구조와 알고리즘 활용
        -   Step1 문제이해 에서 파악한 내용을 토대로 어떤 자료구조를 사용하는게 가장 적합한지 결정
        -   대놓고 특정 자료구조와 알고리즘을 묻는 문제도 많음
        -   자료구조에 따라 선택할 수 있는 알고리즘을 문제에 적용
    -   메모리 사용
        -   시간복잡도를 줄이기 위해 메모리를 사용하는 방법
        -   대표적으로 해시테이블

### 대표 알고리즘

-   O(1): Operation push and pop on Stack
-   O(log n): Binary Tree
-   O(n): for loop
-   O(n×log n): Quick Sort, Merge Sort, Heap Sort
-   O(n2): Double for loop, Insert Sort, Bubble Sort, Selection Sort
-   O(2n): Fibonacci Sequence

### 문제 풀이 과정

-   step1 문제 이해하기
    -   input, output 확인
        -   input 값의 특징 (정수인가? 값 크기의 범위는? 마이너스도 되는건가? 소수인가? 자료형은 문자열인가? 등등)
        -   Output 값의 특징 (내가 어떤 값을 반환해줘야 하는지, 정해진 형식대로 반환하려면 어떻게 구현할지)
    -   input size N 확인
        -   시간복잡도를 계산하기 위한 input size N 또는 M 이 무엇인지 확인
    -   제약조건 확인
        -   시간복잡도 제한이 있는지 확인
        -   내가 선택할 수 있는 알고리즘이 무엇이 있는지
    -   예상할 수 있는 오류 파악
        -   상황을 가정하면서 예상할 수 있는 오류를 파악
        -   입력값의 범위 ,stack overflow 등

### DP

> 문제에 대한 정답이 될 가능성이 있는 모든 해결책을 "체계적"이고 "호츌적"으로 탐색하는 풀이법

-   두가지 방식 존재
    -   탑 다운 방식
    -   바텀 업 방식
-   문제 풀이
    -   접근 방법 =? 완전탐색
        -   크고 복잡한 문제를 하위 문제로 나눈다
        -   하위 문제에 대한 답을 계산한다
            -   중볻 하위 문제
            -   메모리에 저장하여 중복된 문제에 사용
        -   하위 문제에 대한 답으로 원래 문제에 대한 답을 계산한다.

### DP 총 정리

1. 완정탐색

-   하위문제로 나누기
-   계산결과 저장/재활용

2. DP
    1. Overlapping subproblem
        - problem을 작은 subproblem으로 분해
        - subproblem의 계산값을 재사용
    2. Oprimal substructure
        - subproblem의 최적 해법으로 원래 문제의 최적 해법을 구할 수 있다
3. 문제 적용
    1. Optimum value(최대 최소), 방법의 개수등을 구할 때 DP 많이 나옴
        - ~ 최소 비용은
        - ~ 최대 이익은
        - ~ 하는 방법의 개수는
        - 특정 지점에 도달할수 있는지
    2. 미래의 계사닝 앞선 계산 결과에 영향을 받을 때

< 결국은 점화식과 종료조건을 통해서 재귀를 사용해야함

-   구현 방식
    -   top down
        -   재귀 사용 => 구현 시간이 빠르다
        -   재귀풀이에서 중복되는 계산값을 저장하여 동일한 함수 ㅎ출시에 재활용한다
        -   해쉬테이블 또는 list에 계산 결과를 저장한다
    -   바텀업
        -   반복문 사용 => 실행시간이 빠르다.
        -   더 작은 문제에 대한 계산 결과를 dp table에 저장하여 더 큰 문제의 계산에 활용한다
        -   해쉬 테이블 또느 ㄴ리스트에 계산 결과를 저장한다

### 총 정리

> DP : 다이나믹 프로그래밍이란 크고 복잡한 문제를 작게 나누고, 중복되는 문제라면 한 번 계산한 결과값을 저장해높고 재사용함으로써 문제를 효율적으로 해결하는 알고리즘

> 문제풀리 : 특정한 문제를 완전 탐색 알고리즘으로 접근해보고, 시간복잡도가 너무 높다면 DP를 적용할 수 있는지 생각해보자, subproblem의 중복 여부를 판단하는것이 첫 번째 순서다.

> 구현 방법

-   1. 일단 재귀함수로 배효율적인 완전탐색 코드를 작성한다.
-   2. 중복되는 subproblem의 계산 결과를 저장한다.
-   3. 탑다운 -> 바텀업으로 코드 전환을 고려한다

## 유익한 유튜브 시청하기

## 주시

## 강의 수강(Next, 타입스크립트, 알고리즘, test)

### Next

-   error.tsx

    -   로 파일을 만들면 try catch로 안해도 에러 페이지가 처리를 해준다
        -   부분적 에더는 다른거 써야함 suspense 이런거 써야할듯
    -   클라이언트 컴포넌트로 해줘야함
        -   기본적으로 오류라는건 서버든 클라이언트든 둘 다 대응 가능해야함 어떤 환경에서 에러가 생겨도 대응가능하게 클라이언트 컴포넌트로 해줘야함
    -   동등한 루트나 하위 경로에 있는 에러들을 처리해줌
    -   error 객체를 props로 받고 그 타입은 Error 인 자바스크립트 에러 타입임
    -   Error 컴포넌트에는 error 라는 props말고 reset이라는 props를 하나 더 줌

        -   () => void 타입
        -   reset 함수는 그냥 브라우저에서만 화면을 다시 렌더링하는것에 그치지 않음 서버측에서 실행되는 서버 컴포넌트를 다시 실행시키지는 않음

            -   window.location.reload() 를 통해 리로드 해버리면 브라우저에 초기 접속하는거와 마찬가지로됨

                -   예를들어 서버가 꺼져있는 상태에서 사이트에 접속함 reset으로 재 랜더링을하면 서버 컴포넌트는 그대로니 서버를 다시켜도 오류가 해결되지 않음
                    -   근데 이 방법은 우아한 방법이 아님
                -   우아하게 에러 처리하기 (오류가 발생한 부분만 새롭게 렌더링 하는법)

                    -   next router를 활용

                        -   router.refresh()를 해서 넥스트 서버에게 서버 컴포넌트만 새롭게 랜더링해달라고 요청하고 reset()을 뒤에 호출해서 refresh를 통해서 새롭게 갱신받은 서버 컴포넌트를 브라우저에 랜더링 시키디

                        ```ts
                        router.refresh(); // 현재 페이지에 필요한 서버컴포넌트들을 다시 불러옴
                        reset(); // 에러 상태를 초기화, 컴포넌트들을 다시 렌더링
                        ```

                        -   router.refresh()는 비동기 메소드라 위처럼 하면 안됨

                            -   async await를 하면 적용 안됨

                            ```ts
                            'await' has no effect on the type of this expression.ts(80007)
                            ```

                            -   refresh 반환값이 promise가 아니라 void임 즉 프로미스 객체를 반환하지 않기에 안먹힌다는 말

                        -   startTransition을 활용해서 하면됨(하나의 콜백 함수인자로 받아서 콜백 안에 UI를 변경시키는 작업을 모두 일괄적으로 처리해줌

                        ```ts
                            onClick={() => {
                                startTransition(() => {
                                    router.refresh();
                                    reset();
                                });
                            }}
                        ```

        -   error 페이지는 하위에 다 적용됨 만약 하위에서 특정 페이지에 다른 erorr페이지가 필요하다면 해당 경로에 새로 해주면 덮어씌워줌
        -   app 하위에서해주면 모든 에러를 해주면 단점은 같은 경로의 레이아웃까지만 보여줌 하위에 다른건 무시해버려서 특정 페이지에만 적용한 레이아웃들 씹히니 원하면 각 페이지에 에러 페이지를 따로 해줘야함

### 서버 액션

-   브라우저에서 호출할 수 있는 서버에서 실행되는 비동기 함수

-   revalidatePath : 재 검증
    -   revalidatePath가 서버 액션으로부터 호출이되면 풀 라우터캐시와 데이터캐시를 제거해버림 현재 사용자가 보고있는 페이지 업데이트 해주려 백엔드로부터 다시 가져옴
        -   문제는 다음번 접속시에
    -   바로 되는게 아니라 다음 요청때 그때 실시간으로 다시 생성해서 적용함 (다이나믹 페이지처럼)
-   revalidateTag : 해당 태그만 재검증
    -   오직 해당하는 태그를 가지는 것만 삭제해서 효율적임
-   useActionState

### 페럴렐 라우트

-   여러 페이지를 한 페이지에 띄우는 방법
    -   만드는법
        -   슬롯을 만들어야함 : 하위에 골뱅이 기호가 붙은걸로 만들어야함 @sidebar 이런식으로하고 하위에 페이지를 만들면 레이아웃 페이지에 기존에 존재하던 칠드런에 추가로 넘어감 page.tsx로 만들어야함
