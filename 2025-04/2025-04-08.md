# TIL | 2025.04.07

### 오늘 진행 순서 예정

-   [x] 가벼운 런닝
-   [x] 가벼운 맨몸운동
-   [x] 스픽
-   [x] 블로그 하나 읽기
    -   [자바스크립트 Temporal 기능이 곧 도입된다.](https://velog.io/@eunbinn/javascript-temporal-is-coming)
-   [x] 알고리즘
-   [] 주시 트러블 슈팅 정리
    -   소켓 -> 폴링 적용기
-   [] 스마게 작업
-   [x] 주시 회의 (오늘 없음)
-   [] 공부할 키워드 공부
-   [] 스마게 작업
-   [] 알고리즘 강의 수강
-   [] ts 강의 수강

---

# TIL

# 블로그 읽기 (자바스크립트 Temporal 기능이 곧 도입된다를 읽으며 공부한 것)

---

## 기존 자바스크립트 Date 객체

-   자바스크립트의 `Date` 객체는 결함이 많았던 자바의 `java.util.Date` 초기 구현에서 가져온 것이다.
-   자바는 1997년에 이를 교체했지만, 자바스크립트는 거의 30년 가까이 동일한 API를 사용해왔다.
-   주요 문제점:
    -   **변경 가능한 상태**: 인스턴스를 제자리에서 수정할 수 있어 예기치 않은 부작용이 발생.
    -   **제한된 기능**: 날짜 더하기나 비교 같은 간단한 작업조차 복잡한 코드가 필요.
    -   **문자열 파싱 불일치**: 브라우저 간 해석이 일치하지 않는다.
    -   **타임존 지원 부족**: UTC와 로컬 시간 외의 타임존 처리 부족.
    -   **그레고리력만 지원**: 다른 달력 시스템을 지원하지 않는다.
    -   **혼란스러운 API**: `getMonth()`와 같은 메서드는 0부터 시작하는 등 직관적이지 않다.
-   그래서 대부분의 개발자들이 Moment.js나 date-fns 같은 외부 라이브러리를 사용해왔다.

---

## 읽으면서 공부한 키워드들

---

### 로컬 시간 (Local Time)

-   각 나라/지역에서 사용하는 실제 시간.
-   UTC를 기준으로 지역의 **타임존(시간대)** 에 따라 시차를 더하거나 빼서 계산한 시간이다.
-   예를 들어, 한국의 로컬 시간은 UTC +9시간 (Asia/Seoul), 미국 뉴욕은 UTC -5시간이다.

---

### UTC (협정 세계시, Coordinated Universal Time)

-   1972년부터 사용된 국제 표준시. UTC 이전에는 GMT가 사용되었다.
-   **GMT와 UTC는 기준 시간이 같아서 시차는 없지만**, UTC는 원자시계를 기반으로 하고 윤초를 보정하여 오차가 더 적다.
-   **오차가 적은 이유**
    -   **GMT**: 과거 천문학적 기준 (지구 자전 속도에 기반). 하지만 지구 자전은 완벽하게 일정하지 않아 시간이 점점 달라진다.
    -   **UTC**: 원자시계를 기반으로 하지만, 지구 자전 속도에 맞춰 **윤초(leap second)** 를 넣어 자연 시간과 싱크를 맞춘다.

#### 윤초 (Leap Second)

-   지구 자전은 기상, 지진, 조석 마찰 등으로 인해 속도가 완전히 일정하지 않다.
-   이로 인해 **원자시계 기반의 UTC 시간과 지구 자전 기준의 자연 시간(GMT)** 사이에 오차가 발생한다.
-   이 오차를 보정하기 위해 UTC에 1초를 추가하거나 빼는 조정을 하는데, 이를 **윤초**라고 한다.
-   윤초는 주로 6월 30일 또는 12월 31일에 추가되며, **23:59:60** 같이 60초 표기가 등장하는 경우도 있다.
-   덕분에 UTC는 원자시계의 정확성을 유지하면서도 자연 시간과의 차이를 최소화할 수 있다.

-   **둘 다 0시 기준으로 시간은 같지만**
    -   차이점:
        -   GMT: 천문학 기준 (지구 자전)
        -   UTC: 원자시계 + 윤초를 사용하여 오차를 보정

> **Time Zone (시간대)**: UTC를 기준으로 각 지역에서 ± 시차를 적용한 시간  
> 원자시계 → UTC → 각 지역 시간대 (UTC ± 시차)

---

### 원자시계

-   원자시계는 원자가 항상 일정하게 움직이는 성질을 이용해 아주 정확하게 시간을 재는 시계다.
-   우리가 일반적으로 사용하는 시계는 "태양이 떠오르고 지는 것", "지구가 도는 것"을 기준으로 시간을 정하지만, 지구는 아주 조금씩 느려지거나 빨라지기 때문에 시간이 완전히 정확하지 않다.
-   그래서 원자의 일정한 진동수를 기반으로 시간을 측정하는 시계를 만들었다.
-   원자의 진동수는 외부 요인(지진, 대기 등)에 거의 영향을 받지 않고 항상 일정해서 매우 정확하다.
-   현재 사용되는 가장 정밀한 시계가 바로 원자시계다.

---

### Timezone (시간대)

-   타임존은 동일한 로컬 시간을 사용하는 지역 단위로, 각 국가에 의해 법적으로 지정된다.  
    [TimeZoneLD : 존재하는 타임존 확인 가능](https://docs.oracle.com/middleware/12212/wcs/tag-ref/MISC/TimeZones.html)
-   시간대는 지구 자전에 따라 생기는 낮과 밤의 차이를 보정하기 위해 고안된 구분선이다.
-   영국의 그리니치 천문대를 기준으로 지역 간 시간 차이를 계산하여 적용한다.
-   UTC, Asia/Seoul 등의 표기법은 해당 시간이 어느 로컬 기준인지 명시하는 방식이다.

---

## 자바스크립트 Temporal 객체의 등장

-   Temporal 객체가 브라우저의 실험적 기능으로 도입되었다.
-   도입되면 자바스크립트에서 날짜와 시간을 다루는 작업이 훨씬 더 간단하고 현대적으로 바뀔 예정이다.
-   스케줄링, 국제화, 시간 기반 데이터 처리 같은 분야에서 내장 기능을 통해 더 효율적이고 정확하며 일관성 있게 날짜·시간·기간·캘린더를 다룰 수 있게 된다.

---

## Temporal 객체란?

-   `Temporal`은 기존 `Date` 객체를 완전히 대체하기 위해 설계되었다.
-   날짜와 시간을 보다 신뢰할 수 있고 예측 가능하게 다룰 수 있다.
-   타임존과 캘린더 표현, 변환, 비교, 계산, 포맷팅 등 다양한 내장 메서드를 제공한다.
-   **불변성(Immutable)을 기반으로 설계되어 부작용이 없다.**

---

## Temporal 핵심 개념

-   Temporal에서는 **고유한 시점 (Instant)**, **지역 시간 (Wall-clock times)**, **기간 (Duration)** 을 주요 개념으로 다룬다.
-   이를 다루기 위해 다음과 같은 API 구조를 제공한다.

### Temporal API 정리

```
기간 (Duration)
- Temporal.Duration : 두 시점 간의 시간 차이

시점 (Instant / DateTime)

- Temporal.Instant : UTC 기준 절대 시점 (시간대 없음)
- Temporal.ZonedDateTime : 시간대를 포함한 날짜-시간
- Temporal.PlainDateTime : 시간대가 없는 날짜와 시간 (연, 월, 일, 시, 분, 초 등)
- Temporal.PlainDate : 시간대가 없는 날짜만 (연, 월, 일)
- Temporal.PlainYearMonth : 시간대가 없는 연도와 월만
- Temporal.PlainMonthDay : 시간대가 없는 월과 일만
- Temporal.PlainTime : 시간대가 없는 시간만 (시, 분, 초 등)

현재 시간
- Temporal.now : 현재 시간을 다양한 Temporal 인스턴스로 가져올 수 있음
  예: Temporal.now.instant(), Temporal.now.zonedDateTime(), Temporal.now.plainDateTime()
```

---

## 마무리

-   Temporal의 도입으로 복잡하고 오류가 많았던 기존 `Date` 객체의 한계를 극복할 수 있다.
-   타임존, 윤초, 다양한 캘린더 시스템까지 지원하며 별도 라이브러리 없이도 정밀한 시간 계산이 가능해진다.
-   앞으로 스케줄링, 국제화, 시간 기반 데이터 처리 등에서 큰 도움이 될 것으로 기대된다.

---

## 알고리즘

-   시간 복잡도 강의 듣기
    -   for - while 중첨되었다고 무적권 n제곱이 아니다.
        -   어떻게 코드를 작성하냐에 따라 다름
    -   상수 시간도 완전 무시할 순 없다.
    -   코테 시간제한 기준점 : 10 ^ 8
    -   시간복잡도는 만능이 아니다.
    -   풀이에 대한 확신
    -   알고리즘 떠올리기

# 스마게

-   DM
    -   연아님이 작성하신 다이렉트 메세지 컴포넌트 분리(워크스페이스 홈의 사이드바에서 다이렉트 메세지 누르면 해당 다이렉트 메세지 나와야하는데 안되어있음)
-   채팅
    -   싹 다 고쳐야함

# 주시

-   상세 페이지에 있을때는 폴링을 하지 않게
    -   모달 상태가 있음 그거 활용하는것도?
-   히트맵
    - 

# 공부할 키워드

-   공통 컴포넌트 설계
    -   rest
    -   기본 타입 확장
        -   공통 버튼 컴포넌트 만드는데 어떻게 해야할지 모르겠음,
-   React
    -   리엑트에서의 단일 책임 원칙
    -   리엑트 쿼리 사람답게 쓰기
-   next
    -   next Image
    -   next 에서 fetch
    -   next에서 react query
    -   Next.js 에서 local, development, production 환경 셋팅하기
-   작업
    -   next에서 fetch params next invalidate
    -   리엑트 쿼리의 도입이 올바른가
    -   현재 구현된 소켓 로직 다시 생각
        -   현재 구조를 그려보기
        -   개선점 파악하기
        -   있다면 개선
        -   에러처리 생각하기
        -   최적화 부분 생각하기
    -   구현한 폴링 방식 올바른가 (그려보기)
        -   현재 구조를 그려보기
        -   개선점 파악하기
        -   있다면 개선
        -   에러처리 생각하기
        -   최적화 부분 생각하기
-   패키지 매니저
    -   package.json
        -   ^ 메이저 버전 이상 아무거나
    -   packagelock.json
        -   정확한 현재 프로젝트에 설치된 라이브러리 버전 명시

---

# 한 입 크기로 잘라먹는 타입스크립트

-

# 패턴으로 익히고 설계로 완성하는 리액트

-   ch4 리액트 컴포넌트 설계하기 ~

# 프론트엔드 아키텍처

## 뷰 로직과 비즈니스 로직의 분리

### 목적

-   **컴포넌트 재사용성 증가**
-   **유지보수성 향상**
-   **테스트 용이성 확보**

### 예시

#### 뷰 로직 (UI 컴포넌트)

```tsx
const ProductCard = ({ product, onBuy }: Props) => {
    return (
        <div>
            <p>{product.name}</p>
            <button onClick={() => onBuy(product.id)}>구매</button>
        </div>
    );
};
```

#### 비즈니스 로직 (커스텀 훅)

```ts
const useBuyProduct = () => {
    const mutation = useMutation((productId) => buyAPI(productId));
    return mutation;
};
```

### 좋은 구조

-   UI: 입력 → 출력에 집중 (props 기반)
-   로직: 상태 관리, 요청 처리 등은 **hooks나 service 파일로 분리**

## 공부하고 싶은 키워드

## 1. **소프트웨어 설계 원칙 관련**

| 주요 개념                                  | 설명                                           | 함께 공부하면 좋은 개념                                                                   |
| ------------------------------------------ | ---------------------------------------------- | ----------------------------------------------------------------------------------------- |
| **관심사의 분리 (Separation of Concerns)** | 기능/책임/영역을 나눠서 복잡도를 낮추는 원칙   | - SRP (단일 책임 원칙)<br>- 모듈화(Modularity)<br>- MVC/MVVM 패턴<br>- 레이어드 아키텍처  |
| **추상화 계층 (Abstraction Layer)**        | 하위 로직을 숨기고 필요한 기능만 노출하는 구조 | - 캡슐화<br>- 인터페이스 / 추상 클래스<br>- 레이어드 아키텍처<br>- 의존성 역전 원칙 (DIP) |
| **비즈니스 로직 (Business Logic)**         | 애플리케이션의 핵심 규칙/기능을 수행하는 부분  | - 도메인 모델<br>- 서비스 계층<br>- 유스케이스<br>- 엔티티(Entity), DTO                   |

---

## 2. **프론트엔드 구조/설계**

| 주요 개념                                | 설명                                        | 함께 공부하면 좋은 개념                                                     |
| ---------------------------------------- | ------------------------------------------- | --------------------------------------------------------------------------- |
| **Container vs Presentational 컴포넌트** | 비즈니스 로직과 UI 로직을 나누는 React 설계 | - 관심사 분리<br>- 컴포넌트 책임 분리<br>- Hooks 구조화                     |
| **상태 관리 구조 (Zustand, Redux, etc)** | 상태를 어디서/어떻게 다룰지 정의            | - 비즈니스 로직 위치<br>- Store 분리 전략<br>- Selector, middleware         |
| **API Layer 분리**                       | API 요청을 별도 레이어로 나눔               | - Axios 커스텀 인스턴스<br>- Query Hook abstraction<br>- Service Layer 구조 |

---

## 4. **실무 적용 관점 (실제로 설계할 때 유용한 개념)**

| 실무에서 접하는 개념    | 연관 개념                                     |
| ----------------------- | --------------------------------------------- |
| 서비스 레이어 설계      | 비즈니스 로직 분리, 추상화 계층, 관심사 분리  |
| 공통 API 오류 처리      | Axios 인터셉터, API 추상화 계층               |
| 유저 인증 흐름          | 상태 관리 분리, 관심사 분리, 로직 단위 모듈화 |
| 파일 구조 설계          | 기능/도메인 기반 구조 → 관심사 분리           |
| 테스트 설계 (단위/통합) | 비즈니스 로직과 UI 로직 분리 필요             |

### 참조

-   https://ssocoit.tistory.com/253
-   https://gngsn.tistory.com/167
