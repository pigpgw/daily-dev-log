# TIL | 2025.10.17

### 일정

-   10월 23일 목요일 광명 오후 7:30 기차
-   10월 24일 금요일 명준이 집들이
-   10월 25일 토요일 10시 기차
-   11월 8일 토요일 9:00시 정처기시험(제일대학교 비봉관)
-   11월 9일 일요일 12시 30분 범석이형 결혼(용인)

## 오늘 진행 순서 예정

-   [] 오픽 준비
    -   [] [여우오픽 모의고사](https://www.youtube.com/watch?v=-kapDJVUUD0&list=PLQqxXrxA9EGj_XIfyp1zC8ADRxjamZVut) : 21분 20초
-   [] 매일 매일 면접 질문
-   [] 일
-   [] 운동
-   [] 알고리즘
-   [] 딥 다이브

    1. 1단계. 에러와 네트워크 기본 이해

        - [ ] 예측 가능한 상황

            - [ ] 4xx (400, 401, 403, 404, 409 등)
            - [ ] 5xx (500, 502, 503 등)

        - [ ] 예측 불가능한 상황

            - [ ] 오프라인 감지 (`navigator.onLine`, service worker)
            - [ ] 네트워크 지연 (timeout, skeleton UI, retry 전략)
            - [ ] 네트워크 요청 취소 (`AbortController`, `axios.CancelToken`)
            - [ ] 중복 요청 방지 (throttle, debounce)
            - [ ] race condition 방지 (Promise.race, cleanup)

    2. 2단계. Abort & Axios Interceptor 딥다이브

        - [ ] AbortController로 요청 취소하기 (fetch 실습)
        - [ ] axios 요청 중단 / 재시도
        - [ ] axios 요청 & 응답 인터셉터

            - [ ] 공통 헤더 추가
            - [ ] 로깅
            - [ ] 전역 에러 처리 (response error)

        - [ ] 인터셉터에서 토큰 갱신 로직 연결

            - [ ] Access Token 발급
            - [ ] Refresh Token 재발급
            - [ ] Refresh Token 만료 시 처리
            - [ ] 다중 요청에서 refresh race condition 방지 (queue 처리)

    3. 3단계. 에러 핸들링 구조화

        - [ ] 전역 에러 핸들링 (window.onerror, try/catch)
        - [ ] React Error Boundary

            - [ ] fallback UI
            - [ ] 부분적 에러 처리
            - [ ] 에러 로깅 (Sentry, LogRocket 등)

        - [ ] 백엔드 에러 포맷 표준화

            - [ ] error code, message, status 분리
            - [ ] 프론트-백 공통 규약 정하기

        - [ ] 글로벌 에러 토스트 / Alert UX 설계
        - [ ] 환경별 에러 처리 (dev / prod 분리)

    4. 4단계. React Query 심화

        - [ ] QueryClient 설정
        - [ ] staleTime, cacheTime 이해
        - [ ] retry / retryDelay 옵션
        - [ ] onError, onSuccess 콜백
        - [ ] Suspense 모드
        - [ ] useMutation 에러 처리 (optimistic update rollback)
        - [ ] AbortController와 함께 사용
        - [ ] React Query + ErrorBoundary 연동
        - [ ] 로딩/에러/데이터 상태 관리 패턴 정리

    5. 5단계. 페이지네이션 & 무한 스크롤

        - [ ] 서버 페이지네이션 (offset / limit)
        - [ ] 커서 기반 페이지네이션
        - [ ] 프론트 페이지네이션 (react-table, slice)
        - [ ] 페이지네이션 + 검색/필터 결합
        - [ ] React Query `useInfiniteQuery`
        - [ ] Intersection Observer API로 무한 스크롤
        - [ ] 스크롤 위치 저장/복원
        - [ ] 중복 데이터 merge 처리
        - [ ] skeleton UI로 UX 개선

    6. 6단계. 가상 스크롤 & 대용량 데이터 처리

        - [ ] react-window 기본 사용법
        - [ ] react-virtualized
        - [ ] 무한 스크롤과 결합
        - [ ] 1만 개 이상 데이터 성능 실험
        - [ ] 렌더링 최적화 (memo, virtualization)

    7. 7단계. 테스트

        - 단위 테스트

            - [ ] 동기 로직 테스트
            - [ ] 비동기 로직 테스트
            - [ ] 에러 발생 테스트
            - [ ] Mock / Stub / Spy 개념
            - [ ] axios, fetch mocking
            - [ ] React Query mocking
            - [ ] custom hook 테스트

        - 모듈 테스트

            - [ ] API 모듈 테스트
            - [ ] util 함수 테스트
            - [ ] 인증 / 토큰 모듈 테스트
            - [ ] 에러 핸들링 모듈 테스트

        - E2E 테스트

            - [ ] Playwright / Cypress 환경 설정
            - [ ] 로그인 시나리오
            - [ ] API 실패 시 UI 반응
            - [ ] 페이지네이션 / 무한 스크롤 시나리오
            - [ ] 오프라인(mock offline) 테스트

    8. 8단계. 로깅 & 모니터링

        - [ ] Sentry, LogRocket, Datadog 등 연동
        - [ ] console.error / warn 관리
        - [ ] 사용자 피드백 로그 전송
        - [ ] 네트워크 요청 로깅
        - [ ] API 호출 빈도, 에러 통계 수집

    9. 9단계. 성능 & 품질 진단

        - [ ] Lighthouse로 성능 측정
        - [ ] 서버 부하 테스트 (k6, artillery)
        - [ ] 번들 크기 최적화 (tree shaking, lazy loading)
        - [ ] 네트워크 요청 최적화 (HTTP/2, 캐싱)
        - [ ] Suspense + ErrorBoundary 통합 구조
        - [ ] API 재시도 전략 (exponential backoff)

    10. 10단계. 종합 프로젝트 적용

        - [ ] 프론트-백엔드 통합 에러 처리 체계 완성
        - [ ] React Query + Axios Interceptor + Error Boundary 통합 구조 완성
        - [ ] 에러 로깅 + 재시도 + 복원 UX 구축
        - [ ] E2E 테스트로 전체 플로우 검증

    -   [ ] 독서

-   [] 새 프로젝트

    -   작업할 것
        -   1차 MVP UI 구현
            -   [] 헤더
            -   [] main
                -   [] profile section
                -   [] itinerary section
                -   [] main project section
                -   [] total project section
                -   [] blog section
                -   [] certificate section
    -   supabase 활용법
    -   next
        -   렌더링 전략
        -   이미지
    -   react
        -   컴포넌트
        -   스토리북
        -   react query
        -   무한스크롤
        -   렌더링
    -   테스트
        -   단위테스트, 통합테스트, 시스템 테스트, 인수테스트 : 나만의 테스트 적용 기준을 정하자 e2e 좋다
    -   에러처리
        -   예측 가능한 에러
            -   데이터가 없다면
            -   데이터를 못불러온다면
            -   네트워크 끊겼을때
            -   네트워크 지연시
        -   불가능한 에러

-   [] 공부
    -   [] 자바스크립트 공식문서 읽기 (참고 url: https://coder-narak.tistory.com/79)
    -   리엑트 컴포넌트 렌더링 개발도구 통해서 성능 측정방법
    -   JS 엔진 구조 (V8, SpiderMonkey)
    -   인터프리터 vs 컴파일러
    -   JIT 컴파일러 (Just-In-Time-Compiler)
    -   이벤트 루프, Call Stack, Task Queue
    -   공통 컴포넌트 설계
    -   rest
    -   기본 타입 확장
    -   공통 버튼 컴포넌트 만드는데 어떻게 해야할지 모르겠음,
    -   리엑트에서의 단일 책임 원칙
    -   리엑트 쿼리 사람답게 쓰기
    -   suspense
    -   에러 바운더리

---

# TIL

## 매일 매일 면접 질문

## 일

## 알고리즘

### 코테 적용 방법

-   Step1 문제 이해하기
    -   문제를 제대로 읽기
    -   제약조건 읽기
        -   효율성 테스트 10^8 넘으면 안됨
        -   원소 값의 범위
            -   int === 4byte => 1bit는 부호 31bit는 수 표현 -2^31 ~ 2^31 + 1
                -   2의 31승은 10의 9승 그러면 인트형 변수에 저장 불가
-   Step2 접근 방법
    -   직관적으로 생각하기
        -   보통 완전 탐색으로 시작
        -   문제 상황을 단순화 하여 생각하기
        -   문제 상황을 극한화 하여 생각하기
    -   자료구조와 알고리즘 활용
        -   Step1 문제이해 에서 파악한 내용을 토대로 어떤 자료구조를 사용하는게 가장 적합한지 결정
        -   대놓고 특정 자료구조와 알고리즘을 묻는 문제도 많음
        -   자료구조에 따라 선택할 수 있는 알고리즘을 문제에 적용
    -   메모리 사용
        -   시간복잡도를 줄이기 위해 메모리를 사용하는 방법
        -   대표적으로 해시테이블

### 대표 알고리즘

-   O(1): Operation push and pop on Stack
-   O(log n): Binary Tree
-   O(n): for loop
-   O(n×log n): Quick Sort, Merge Sort, Heap Sort
-   O(n2): Double for loop, Insert Sort, Bubble Sort, Selection Sort
-   O(2n): Fibonacci Sequence
