# TIL | 2025.10.03

## 오늘 진행 순서 예정

-   [x] 매일 매일 면접 질문 : CSS 명시도(Specificity)에 대해서 설명해주세요.
-   [x] 운동
-   [x] 알고리즘 : 에라토스테네스 체

---

# TIL

## 매일 매일 면접 질문 : CSS 명시도(Specificity)에 대해서 설명해주세요.

-   CSS 명시도는 스타일이 충돌할 때 어떤 것이 우선 적용될지를 결정하는 개념입니다. 웹 페이지에서 여러 개의 CSS 규칙이 동일한 요소에 적용될 수 있습니다. 이때 브라우저는 명시도를 계산하여 어떤 스타일을 적용할지 판단합니다.
-   CSS 명시도는 선택자의 종류에 따라 다음과 같은 우선순위를 갖습니다.
    -   1순위: 인라인 스타일
    -   2순위: id 선택자
    -   3순위: 클래스, 가상 클래스, 속성 선택자
    -   4순위: 요소 선택자
-   이러한 우선순위에 따라 점수를 부여한 뒤 합산하여 어떤 스타일을 적용할지 결정하는 것입니다. 만약 합산 점수가 동일한 경우, 나중에 선언된 것이 적용됩니다.

```css
p {
    color: blue;
} /* 요소 선택자 */
.text {
    color: red;
} /* 클래스 선택자 */
#unique {
    color: green;
} /* ID 선택자 */
```

```css
<p id="unique" class="text">Hello, CSS!</p>
```

-   이 경우, <p> 요소는 명시도가 가장 높은 ID 선택자가 적용된 #unique의 스타일을 따라 초록색(green)으로 표시됩니다.

### 명시도가 높은 스타일을 강제로 덮어쓰려면 어떻게 해야 하나요? 🤔

-   !important를 사용하면 됩니다. !important는 타일 규칙의 명시도를 무시하고 가장 높은 우선순위를 갖게 합니다. 만약 동일한 속성에 대해 여러 개의 !important 규칙이 존재하면, 그때는 일반적인 명시도 규칙을 따르게 됩니다.
-   예를 들어, 다음과 같이 기존의 규칙을 강제로 덮어쓸 수 있습니다.

```css
p {
    color: black !important;
}
```

> 다만, !important는 과도하게 사용하면 유지보수가 어려워질 수 있으므로 최대한 필요한 경우에만 사용해야 합니다.

### 📚 추가 학습 자료를 공유합니다.

-   https://specifishity.com/
-   https://developer.mozilla.org/ko/docs/Web/CSS/CSS_cascade/Specificity

## 일

## 알고리즘

### 코테 적용 방법

-   Step1 문제 이해하기
    -   문제를 제대로 읽기
    -   제약조건 읽기
        -   효율성 테스트 10^8 넘으면 안됨
        -   원소 값의 범위
            -   int === 4byte => 1bit는 부호 31bit는 수 표현 -2^31 ~ 2^31 + 1
                -   2의 31승은 10의 9승 그러면 인트형 변수에 저장 불가
-   Step2 접근 방법
    -   직관적으로 생각하기
        -   보통 완전 탐색으로 시작
        -   문제 상황을 단순화 하여 생각하기
        -   문제 상황을 극한화 하여 생각하기
    -   자료구조와 알고리즘 활용
        -   Step1 문제이해 에서 파악한 내용을 토대로 어떤 자료구조를 사용하는게 가장 적합한지 결정
        -   대놓고 특정 자료구조와 알고리즘을 묻는 문제도 많음
        -   자료구조에 따라 선택할 수 있는 알고리즘을 문제에 적용
    -   메모리 사용
        -   시간복잡도를 줄이기 위해 메모리를 사용하는 방법
        -   대표적으로 해시테이블

### 대표 알고리즘

-   O(1): Operation push and pop on Stack
-   O(log n): Binary Tree
-   O(n): for loop
-   O(n×log n): Quick Sort, Merge Sort, Heap Sort
-   O(n2): Double for loop, Insert Sort, Bubble Sort, Selection Sort
-   O(2n): Fibonacci Sequence
